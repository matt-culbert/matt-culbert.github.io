<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="The Evolution Of Evasion" /><meta property="og:locale" content="en" /><meta name="description" content="The evolution of evasion Evasion is a very interesting topic. When I say evasion, I’m referring to both evading prying eyes from analysts and avoiding their attention, as well as evading AV and EDR. We can see how espionage operations in 2000 led to advancements in EDR and OS mitigations today in 2023. The Equation Group is fascinating to study in this area because for so long their operations went unattributed. And this can be directly tied to how well they tailored their target list and worked to keep themselves from being discovered. Thanks to the Shadow Brokers and Kaspersky, we are able to now get a deep insight into their specific methodology and techniques used in one stage of their operational development. Kaspersky also provided a lot of great analysis and documentation in the year leading up to the public release of the toolsets. After analyzing some of Equation Groups leaked tools, I’ll also touch on some modern developments in evasion. The modern land scape is a lot different than even just a couple years ago - go figure. EQUATIONDRUG EQUATIONDRUG is one of the first tools that was developed in the Equation Group arsenal and one of the tools leaked through the Shadow Brokers. It is best described as a post exploitation platform that is loaded onto interesting targets following an initial infection by DOUBLEFANTASY. It was developed, possibly, as far back as 1996. It primarily targeted XP operating systems and GRAYFISH evolved from there to target additional Windows versions. Due to the extensive leaks of certain tools, anyone can examine some of these in Ghidra and PEStudio and gather some fascinating insights on their modus operandi. For example, at the bottom of the picture you can see KeServiceDescriptorTable is imported. Perusing the decompiled source, you can find how this function was utilized. I’ll be upfront that I’m not an expert in analyzing the decompiled and optimized code Ghidra returns from compiled sources, but we can see two clear calls here and correlate them with compiled information from Kaspersky. That is KeServiceDescriptorTable and KeAddSystemServiceTable. The latter of these is for adding new system calls to the SSDT which PeStudio actually missed when pulling strings out. On Vista and above this is no longer possible because there is only room for two; the kernels and win32ks. Equation Group was using these calls in order to add a new subsystem for a harder to detect angle of attack. To a modern audience, this is nothing new. Attackers have been leveraging Windows subsystem for Linux since it came out of testing. But at the time, this was quite novel since it was not a clearly documented Nt function. Going back to Kasperskys research, they identified a key feature in FANNY (discussed here later) was that it was able to replace SSDT entries for functions with their own calls to perform whatever actions they want. The implementation of the exploit in Fanny is more complex than in Stuxnet: instead of running just one payload the authors created a framework to run as many payloads as they want by replacing a system service call dispatcher nt!NtShutdownSystem with their own custom pointer from the user-space as shown in the next figure. It’s not out of the question that a similar functionality was implemented into EQUATIONDRUG based on the below excerpt from an analyzed DLL. We can breakdown the above sample in more manageable chunks. FUN_68003e16 is a function that takes an HMODULE and a char. An HMODULE is the DLLs base address. Looking at the compiled Assembly, the full instruction at this address is LEA EDI,[ESI + 0x18]. LEA is interesting because it does memory calculations to determine an offset and then store it in any register. I want to avoid diving into the weeds of this too much since it will be so easy to get lost in the nuance of what makes LEA special but basically it’s the only Assembly instruction that lets you perform memory addressing calculations without addressing the memory. This is significant because in FUN_68003e16, they call GetProcAddress for this offset and proceed to use the pointer declared to overwrite it from one instruction to another - just as was observed with FANNY. EQUATIONDRUG also had a very unique capability at the time, and that was running before system startup fully completed. This methodology was more realized in the subsequent platform GRAYFISH. This predates EDR running before system startup and takes advantage of there being limited, if any at all, telemetry on what software and drivers are running at this time. The new book Evading EDR, by Matt Hand, has a section on how EDR runs pre boot actions. Chapter 11 Early Launch Antimalware Drivers. Microsoft introduced a new anti- malware feature in Windows 8 that allows certain special drivers to load before all other boot-start drivers. Today, nearly all EDR vendors leverage this capability, called Early Launch Antimalware (ELAM), in some way, as it offers the ability to affect the system extremely early in the boot process. It also provides access to specific types of system telemetry not available to other components. Thanks to the Shadow Brokers, we can get a good idea of some of the modules that were loaded as part of the framework. An interesting example is mstcp32.sys. This is for intercepting packets and executing commands based on fields seen. Though it’s for intercepting packets, it acts as a root kit, performing kernel calls on the fly to the registry and staying away from prying eyes. This can be observed in the below in some brief example calls to the registry. DOUBLEFANTASY DOUBLEFANTASY is one of the earliest droppers that Equation Group developed and it was discovered, interestingly enough, on CD’s sent to conference attendees that were at a Houston event. It was deployed as a generic dropper alongside a custom developed AutoRun file that loaded and executed the DLL from disk. Both it and the DLL employed a set of 0days to get root access which leads to the conclusion that they probably were meant to run independently of one another. When ran, a simple XOR decryption was performed and DOUBLEFANTASY checked the registry for installed AV from a pre defined list of vendors. At the time, the method of using key enumeration was “non alarming” as opposed to directly accessing the key. Nowadays we refer to this method as T1012 and there’s many detection patterns built around it. If no known AV was found, the malware persisted and executed further. Otherwise, it cleaned up and no one was the wiser. This was a lot simpler when there was such few AV vendors, and barely any of them were worth their salt at detecting threats. Nowadays, this is far less likely to accurately find AV to avoid and the key enumeration would raise alarms. FANNY The earliest sample Kaspersky was able to analyze had a compiled time stamp of 2008, two years before the same zero days would be used in Stuxnet, in conjunction with two more, to cripple Irans nuclear efforts. FANNY, due to the nature of the sensitivity of its payload, would naturally want to remain undetected by prying eyes. This means that targeting appropriate systems and individuals is of the utmost importance. FANNY itself is easiest to think of as a persistent loader. Similar to Stuxnet, it uses the LNK exploit to autorun from USB drives even if autorun is disabled. Where they differ is that FANNY had a much broader target OS scope. Once FANNY executes, it fetches a payload from the C2 for further post-exploitation features. But it also has the ability to persist on the USB in order to relay commands back and forth from air gapped machines. This leads us into the first evasion technique that FANNY employs. Each time there is a successful infection, a counter decreases and when that hits 1, execution stops and FANNY stops further infections. This limits the spread and allows the operators to try and keep it contained within the target environment. The next evasion technique is a little counter-intuitive. How might you weed out systems that have AV or other software that can expose your operation? FANNY did this by making it quickly obvious to AV and analysts that it was typical crimeware that should be removed. Any analyst looking at it would just write it off as malware that was cleaned up, maybe reimage the system to be safe, and Equation Group would keep their real tools safe from further scrutiny. And this worked well, really well. For six years it was detected only as part of the zbot malware family until Kaspersky went hunting for the Equation Groups tools based on a library signature. If the module persisted past this point, only then would further payloads be fetched. GRAYFISH GRAYFISH is described by researchers as the Equation Groups most modern and sophisticated malware implant. This can be observed through numerous developments in methodology and tactics, such as leveraging 0days in HDD firmware to persist indefinitely after hard drive wipes , leveraging the registry to store and hide modules, and installing a bootkit to entirely control the start to finish boot process how they like. When the computer starts, GRAYFISH hijacks the OS loading mechanisms by injecting its code into the boot record. This allows it to control the launching of Windows at each stage. In fact, after infection, the computer is not run by itself more: it is GRAYFISH that runs it step by step, making the necessary changes on the fly. Normally, user space apps are not allowed to execute with ring 0 privileges. GRAYFISH bypassed this by leveraging a vulnerable driver, a technique now known as bring your own vulnerable driver (BYOVD.) This allowed the actors to execute their tools as the highest privilege available. To bypass modern OS security mechanisms that block the execution of untrusted code in kernel mode, GRAYFISH exploits several legitimate drivers, including one from the CloneCD program. This driver ( ElbyCDIO.sys) contains a vulnerability which GRAYFISH exploits to achieve kernel-level code execution. Despite the fact that the vulnerability was discovered in 2009, the digital signature has not yet been revoked. Another uncommon technique, for the time, was to live off of the registry. You can see this technique in MITRE ATT&amp;CK as T1112. The GRAYFISH implementation appears to have been designed to make it invisible to antivirus products. When used together with the bootkit, all the modules as well as the stolen data are stored in encrypted form in the registry and dynamically decrypted and executed. There are no malicious executable modules at all on the filesystem of an infected system. Unfortunately, I can’t get any samples of GRAYFISH to look at further myself, so my summary of evasion techniques is limited to what’s publicly already been discussed, and there’s little available in that regard. What’s Happening Today That’s a historical look at evasion using Equation Group as an example, but evasion continues to change every day to adapt to new and changing EDR products. Below I have a set of some of my favorite techniques that I think represent a rapid growth in the offsec research environment. I can’t do each of them justice, they all deserve a post dedicated solely to them, but I will try to accurately summarize them for quick reference and provide a project that utilizes them. Syswhispers SysWhispers allows teams to directly reference syscall numbers without having to go through NTDLL for them. Hells Gate is an evolution of this and enumerates the NTDLL table for these numbers. SysWhispers is a header library/asm file combo that you can import into your project that has the correct ID for each call needed. Since you now have the correct ID numbers, you don’t need to import NTDLL to perform your syscalls. There’s been a few evolutions from the original SysWhispers, we now have 2 and 3. Each iteration has added different support and uses different compilers. Sleep obfuscation MDSecs Peter Winter-Smith can be credited with a lot of the work that went into developing sleep obfuscation, though back in 2016 Gargoyle laid much of the ground work. The example that I will use for this is Cronos, which credits Ekko, which in turn credits Peter for their inspiration. At a base level the Cronos function RC4 encrypts the running process then changes its memory from RW to RX. But sleep obfuscation is a lot more complicated than just this. Rewinding back to 2016, when scanners originally caught onto Gargoyle marking sections as non executable, SleepyCrypt came along and performed a single byte XOR to encrypt the malicious section. Now scanners will quickly brute force this which caused researchers to look for new techniques. Foliage was the first to use encryption of the running process and leveraged a ROP chain to achieve execution after sleep. Ekko and Cronos followed suit, iterating on this with Ekko utilizing an RSP register to make the ROP chain much more stable. This is accomplished because the RSP register is your stack pointer. This article by TrustFoundry is very helpful for further understanding this. Spoofing the thread call stack This is a lot like sleep obfuscation but it has a slightly different end result. You will perform the necessary steps of loading the shellcode, acquire your function pointers, then hook the kernel32!Sleep method to point to our own version. We allocate the memory, copy the shellcode contents into it, and then call CreateThread to begin execution. As soon as the implant finishes its tasks and attempts to sleep, our custom sleep callback is invoked which will copy then overwrite the return address on the stack to 0 - meaning the code goes no where. Then the implant sleeps for the specified period and afterwards restores the copied return address to the stack allowing execution to continue. Reflective DLL loaders Reflect DLL injection is a technique to run a DLL entirely in memory. First you calculate the size of the DLL to load, allocate a memory region for it, and copy it into there. But DLLs aren’t designed to run from memory, they’re designed to export functions while on disk. Stephen Fewers example solves this by exporting a primary function that handles this loading through a version of LoadLibrary that can handle being passed memory regions to read from. I’m not doing this justice with my explanation so I encourage anyone unfamiliar with this to play around with the exampel and attempt to get it to execute. Disabling ETW ETW stands for event tracing for Windows and provides robust heuristics on running processes and syscalls. This makes it a great tool for EDR to easily monitor processes for suspicious actions. EDR especially likes this because even if their hooks are removed from NTDLL to mask calls that way, the access is still logged through ETW. Bypassing both then becomes a requirement for engagements. Another MDSec researcher (I’m seeing a trend here…) Adam Chester, has a blog post as well that is linked from within the White Knight Labs article. He simply overwrites the start of the function with the return bytes so that when it is called it just runs its clean up routine and exits. Removing hooks from NTDLL This is definitely the simplest approach to evasion and entails removing EDR hooks placed in loaded copies of NTDLL. When a new process is started, that process needs to determine different syscalls to use. Those memory locations are referenced from NTDLL. EDR knows this and patches the copy loaded so that suspicious calls JMP to the EDR for analysis before returning back to normal process flow if it is determined to be safe. There are a couple of ways to remove these hooks. You can remove on a per call basis so that maybe only CreateRemoteThread will avoid the EDR. Or you can copy the entire .text section of the file and overwrite how it is in the running process. I’ve not linked a project here because there’s a ton of different methods for doing it, all with their own ups and downs." /><meta property="og:description" content="The evolution of evasion Evasion is a very interesting topic. When I say evasion, I’m referring to both evading prying eyes from analysts and avoiding their attention, as well as evading AV and EDR. We can see how espionage operations in 2000 led to advancements in EDR and OS mitigations today in 2023. The Equation Group is fascinating to study in this area because for so long their operations went unattributed. And this can be directly tied to how well they tailored their target list and worked to keep themselves from being discovered. Thanks to the Shadow Brokers and Kaspersky, we are able to now get a deep insight into their specific methodology and techniques used in one stage of their operational development. Kaspersky also provided a lot of great analysis and documentation in the year leading up to the public release of the toolsets. After analyzing some of Equation Groups leaked tools, I’ll also touch on some modern developments in evasion. The modern land scape is a lot different than even just a couple years ago - go figure. EQUATIONDRUG EQUATIONDRUG is one of the first tools that was developed in the Equation Group arsenal and one of the tools leaked through the Shadow Brokers. It is best described as a post exploitation platform that is loaded onto interesting targets following an initial infection by DOUBLEFANTASY. It was developed, possibly, as far back as 1996. It primarily targeted XP operating systems and GRAYFISH evolved from there to target additional Windows versions. Due to the extensive leaks of certain tools, anyone can examine some of these in Ghidra and PEStudio and gather some fascinating insights on their modus operandi. For example, at the bottom of the picture you can see KeServiceDescriptorTable is imported. Perusing the decompiled source, you can find how this function was utilized. I’ll be upfront that I’m not an expert in analyzing the decompiled and optimized code Ghidra returns from compiled sources, but we can see two clear calls here and correlate them with compiled information from Kaspersky. That is KeServiceDescriptorTable and KeAddSystemServiceTable. The latter of these is for adding new system calls to the SSDT which PeStudio actually missed when pulling strings out. On Vista and above this is no longer possible because there is only room for two; the kernels and win32ks. Equation Group was using these calls in order to add a new subsystem for a harder to detect angle of attack. To a modern audience, this is nothing new. Attackers have been leveraging Windows subsystem for Linux since it came out of testing. But at the time, this was quite novel since it was not a clearly documented Nt function. Going back to Kasperskys research, they identified a key feature in FANNY (discussed here later) was that it was able to replace SSDT entries for functions with their own calls to perform whatever actions they want. The implementation of the exploit in Fanny is more complex than in Stuxnet: instead of running just one payload the authors created a framework to run as many payloads as they want by replacing a system service call dispatcher nt!NtShutdownSystem with their own custom pointer from the user-space as shown in the next figure. It’s not out of the question that a similar functionality was implemented into EQUATIONDRUG based on the below excerpt from an analyzed DLL. We can breakdown the above sample in more manageable chunks. FUN_68003e16 is a function that takes an HMODULE and a char. An HMODULE is the DLLs base address. Looking at the compiled Assembly, the full instruction at this address is LEA EDI,[ESI + 0x18]. LEA is interesting because it does memory calculations to determine an offset and then store it in any register. I want to avoid diving into the weeds of this too much since it will be so easy to get lost in the nuance of what makes LEA special but basically it’s the only Assembly instruction that lets you perform memory addressing calculations without addressing the memory. This is significant because in FUN_68003e16, they call GetProcAddress for this offset and proceed to use the pointer declared to overwrite it from one instruction to another - just as was observed with FANNY. EQUATIONDRUG also had a very unique capability at the time, and that was running before system startup fully completed. This methodology was more realized in the subsequent platform GRAYFISH. This predates EDR running before system startup and takes advantage of there being limited, if any at all, telemetry on what software and drivers are running at this time. The new book Evading EDR, by Matt Hand, has a section on how EDR runs pre boot actions. Chapter 11 Early Launch Antimalware Drivers. Microsoft introduced a new anti- malware feature in Windows 8 that allows certain special drivers to load before all other boot-start drivers. Today, nearly all EDR vendors leverage this capability, called Early Launch Antimalware (ELAM), in some way, as it offers the ability to affect the system extremely early in the boot process. It also provides access to specific types of system telemetry not available to other components. Thanks to the Shadow Brokers, we can get a good idea of some of the modules that were loaded as part of the framework. An interesting example is mstcp32.sys. This is for intercepting packets and executing commands based on fields seen. Though it’s for intercepting packets, it acts as a root kit, performing kernel calls on the fly to the registry and staying away from prying eyes. This can be observed in the below in some brief example calls to the registry. DOUBLEFANTASY DOUBLEFANTASY is one of the earliest droppers that Equation Group developed and it was discovered, interestingly enough, on CD’s sent to conference attendees that were at a Houston event. It was deployed as a generic dropper alongside a custom developed AutoRun file that loaded and executed the DLL from disk. Both it and the DLL employed a set of 0days to get root access which leads to the conclusion that they probably were meant to run independently of one another. When ran, a simple XOR decryption was performed and DOUBLEFANTASY checked the registry for installed AV from a pre defined list of vendors. At the time, the method of using key enumeration was “non alarming” as opposed to directly accessing the key. Nowadays we refer to this method as T1012 and there’s many detection patterns built around it. If no known AV was found, the malware persisted and executed further. Otherwise, it cleaned up and no one was the wiser. This was a lot simpler when there was such few AV vendors, and barely any of them were worth their salt at detecting threats. Nowadays, this is far less likely to accurately find AV to avoid and the key enumeration would raise alarms. FANNY The earliest sample Kaspersky was able to analyze had a compiled time stamp of 2008, two years before the same zero days would be used in Stuxnet, in conjunction with two more, to cripple Irans nuclear efforts. FANNY, due to the nature of the sensitivity of its payload, would naturally want to remain undetected by prying eyes. This means that targeting appropriate systems and individuals is of the utmost importance. FANNY itself is easiest to think of as a persistent loader. Similar to Stuxnet, it uses the LNK exploit to autorun from USB drives even if autorun is disabled. Where they differ is that FANNY had a much broader target OS scope. Once FANNY executes, it fetches a payload from the C2 for further post-exploitation features. But it also has the ability to persist on the USB in order to relay commands back and forth from air gapped machines. This leads us into the first evasion technique that FANNY employs. Each time there is a successful infection, a counter decreases and when that hits 1, execution stops and FANNY stops further infections. This limits the spread and allows the operators to try and keep it contained within the target environment. The next evasion technique is a little counter-intuitive. How might you weed out systems that have AV or other software that can expose your operation? FANNY did this by making it quickly obvious to AV and analysts that it was typical crimeware that should be removed. Any analyst looking at it would just write it off as malware that was cleaned up, maybe reimage the system to be safe, and Equation Group would keep their real tools safe from further scrutiny. And this worked well, really well. For six years it was detected only as part of the zbot malware family until Kaspersky went hunting for the Equation Groups tools based on a library signature. If the module persisted past this point, only then would further payloads be fetched. GRAYFISH GRAYFISH is described by researchers as the Equation Groups most modern and sophisticated malware implant. This can be observed through numerous developments in methodology and tactics, such as leveraging 0days in HDD firmware to persist indefinitely after hard drive wipes , leveraging the registry to store and hide modules, and installing a bootkit to entirely control the start to finish boot process how they like. When the computer starts, GRAYFISH hijacks the OS loading mechanisms by injecting its code into the boot record. This allows it to control the launching of Windows at each stage. In fact, after infection, the computer is not run by itself more: it is GRAYFISH that runs it step by step, making the necessary changes on the fly. Normally, user space apps are not allowed to execute with ring 0 privileges. GRAYFISH bypassed this by leveraging a vulnerable driver, a technique now known as bring your own vulnerable driver (BYOVD.) This allowed the actors to execute their tools as the highest privilege available. To bypass modern OS security mechanisms that block the execution of untrusted code in kernel mode, GRAYFISH exploits several legitimate drivers, including one from the CloneCD program. This driver ( ElbyCDIO.sys) contains a vulnerability which GRAYFISH exploits to achieve kernel-level code execution. Despite the fact that the vulnerability was discovered in 2009, the digital signature has not yet been revoked. Another uncommon technique, for the time, was to live off of the registry. You can see this technique in MITRE ATT&amp;CK as T1112. The GRAYFISH implementation appears to have been designed to make it invisible to antivirus products. When used together with the bootkit, all the modules as well as the stolen data are stored in encrypted form in the registry and dynamically decrypted and executed. There are no malicious executable modules at all on the filesystem of an infected system. Unfortunately, I can’t get any samples of GRAYFISH to look at further myself, so my summary of evasion techniques is limited to what’s publicly already been discussed, and there’s little available in that regard. What’s Happening Today That’s a historical look at evasion using Equation Group as an example, but evasion continues to change every day to adapt to new and changing EDR products. Below I have a set of some of my favorite techniques that I think represent a rapid growth in the offsec research environment. I can’t do each of them justice, they all deserve a post dedicated solely to them, but I will try to accurately summarize them for quick reference and provide a project that utilizes them. Syswhispers SysWhispers allows teams to directly reference syscall numbers without having to go through NTDLL for them. Hells Gate is an evolution of this and enumerates the NTDLL table for these numbers. SysWhispers is a header library/asm file combo that you can import into your project that has the correct ID for each call needed. Since you now have the correct ID numbers, you don’t need to import NTDLL to perform your syscalls. There’s been a few evolutions from the original SysWhispers, we now have 2 and 3. Each iteration has added different support and uses different compilers. Sleep obfuscation MDSecs Peter Winter-Smith can be credited with a lot of the work that went into developing sleep obfuscation, though back in 2016 Gargoyle laid much of the ground work. The example that I will use for this is Cronos, which credits Ekko, which in turn credits Peter for their inspiration. At a base level the Cronos function RC4 encrypts the running process then changes its memory from RW to RX. But sleep obfuscation is a lot more complicated than just this. Rewinding back to 2016, when scanners originally caught onto Gargoyle marking sections as non executable, SleepyCrypt came along and performed a single byte XOR to encrypt the malicious section. Now scanners will quickly brute force this which caused researchers to look for new techniques. Foliage was the first to use encryption of the running process and leveraged a ROP chain to achieve execution after sleep. Ekko and Cronos followed suit, iterating on this with Ekko utilizing an RSP register to make the ROP chain much more stable. This is accomplished because the RSP register is your stack pointer. This article by TrustFoundry is very helpful for further understanding this. Spoofing the thread call stack This is a lot like sleep obfuscation but it has a slightly different end result. You will perform the necessary steps of loading the shellcode, acquire your function pointers, then hook the kernel32!Sleep method to point to our own version. We allocate the memory, copy the shellcode contents into it, and then call CreateThread to begin execution. As soon as the implant finishes its tasks and attempts to sleep, our custom sleep callback is invoked which will copy then overwrite the return address on the stack to 0 - meaning the code goes no where. Then the implant sleeps for the specified period and afterwards restores the copied return address to the stack allowing execution to continue. Reflective DLL loaders Reflect DLL injection is a technique to run a DLL entirely in memory. First you calculate the size of the DLL to load, allocate a memory region for it, and copy it into there. But DLLs aren’t designed to run from memory, they’re designed to export functions while on disk. Stephen Fewers example solves this by exporting a primary function that handles this loading through a version of LoadLibrary that can handle being passed memory regions to read from. I’m not doing this justice with my explanation so I encourage anyone unfamiliar with this to play around with the exampel and attempt to get it to execute. Disabling ETW ETW stands for event tracing for Windows and provides robust heuristics on running processes and syscalls. This makes it a great tool for EDR to easily monitor processes for suspicious actions. EDR especially likes this because even if their hooks are removed from NTDLL to mask calls that way, the access is still logged through ETW. Bypassing both then becomes a requirement for engagements. Another MDSec researcher (I’m seeing a trend here…) Adam Chester, has a blog post as well that is linked from within the White Knight Labs article. He simply overwrites the start of the function with the return bytes so that when it is called it just runs its clean up routine and exits. Removing hooks from NTDLL This is definitely the simplest approach to evasion and entails removing EDR hooks placed in loaded copies of NTDLL. When a new process is started, that process needs to determine different syscalls to use. Those memory locations are referenced from NTDLL. EDR knows this and patches the copy loaded so that suspicious calls JMP to the EDR for analysis before returning back to normal process flow if it is determined to be safe. There are a couple of ways to remove these hooks. You can remove on a per call basis so that maybe only CreateRemoteThread will avoid the EDR. Or you can copy the entire .text section of the file and overwrite how it is in the running process. I’ve not linked a project here because there’s a ton of different methods for doing it, all with their own ups and downs." /><link rel="canonical" href="/posts/The-evolution-of-evasion/" /><meta property="og:url" content="/posts/The-evolution-of-evasion/" /><meta property="og:site_name" content="Culbert Report" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-08-20T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The Evolution Of Evasion" /><meta name="twitter:site" content="@mattculbert" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-08-22T19:35:33+00:00","datePublished":"2023-08-20T00:00:00+00:00","description":"The evolution of evasion Evasion is a very interesting topic. When I say evasion, I’m referring to both evading prying eyes from analysts and avoiding their attention, as well as evading AV and EDR. We can see how espionage operations in 2000 led to advancements in EDR and OS mitigations today in 2023. The Equation Group is fascinating to study in this area because for so long their operations went unattributed. And this can be directly tied to how well they tailored their target list and worked to keep themselves from being discovered. Thanks to the Shadow Brokers and Kaspersky, we are able to now get a deep insight into their specific methodology and techniques used in one stage of their operational development. Kaspersky also provided a lot of great analysis and documentation in the year leading up to the public release of the toolsets. After analyzing some of Equation Groups leaked tools, I’ll also touch on some modern developments in evasion. The modern land scape is a lot different than even just a couple years ago - go figure. EQUATIONDRUG EQUATIONDRUG is one of the first tools that was developed in the Equation Group arsenal and one of the tools leaked through the Shadow Brokers. It is best described as a post exploitation platform that is loaded onto interesting targets following an initial infection by DOUBLEFANTASY. It was developed, possibly, as far back as 1996. It primarily targeted XP operating systems and GRAYFISH evolved from there to target additional Windows versions. Due to the extensive leaks of certain tools, anyone can examine some of these in Ghidra and PEStudio and gather some fascinating insights on their modus operandi. For example, at the bottom of the picture you can see KeServiceDescriptorTable is imported. Perusing the decompiled source, you can find how this function was utilized. I’ll be upfront that I’m not an expert in analyzing the decompiled and optimized code Ghidra returns from compiled sources, but we can see two clear calls here and correlate them with compiled information from Kaspersky. That is KeServiceDescriptorTable and KeAddSystemServiceTable. The latter of these is for adding new system calls to the SSDT which PeStudio actually missed when pulling strings out. On Vista and above this is no longer possible because there is only room for two; the kernels and win32ks. Equation Group was using these calls in order to add a new subsystem for a harder to detect angle of attack. To a modern audience, this is nothing new. Attackers have been leveraging Windows subsystem for Linux since it came out of testing. But at the time, this was quite novel since it was not a clearly documented Nt function. Going back to Kasperskys research, they identified a key feature in FANNY (discussed here later) was that it was able to replace SSDT entries for functions with their own calls to perform whatever actions they want. The implementation of the exploit in Fanny is more complex than in Stuxnet: instead of running just one payload the authors created a framework to run as many payloads as they want by replacing a system service call dispatcher nt!NtShutdownSystem with their own custom pointer from the user-space as shown in the next figure. It’s not out of the question that a similar functionality was implemented into EQUATIONDRUG based on the below excerpt from an analyzed DLL. We can breakdown the above sample in more manageable chunks. FUN_68003e16 is a function that takes an HMODULE and a char. An HMODULE is the DLLs base address. Looking at the compiled Assembly, the full instruction at this address is LEA EDI,[ESI + 0x18]. LEA is interesting because it does memory calculations to determine an offset and then store it in any register. I want to avoid diving into the weeds of this too much since it will be so easy to get lost in the nuance of what makes LEA special but basically it’s the only Assembly instruction that lets you perform memory addressing calculations without addressing the memory. This is significant because in FUN_68003e16, they call GetProcAddress for this offset and proceed to use the pointer declared to overwrite it from one instruction to another - just as was observed with FANNY. EQUATIONDRUG also had a very unique capability at the time, and that was running before system startup fully completed. This methodology was more realized in the subsequent platform GRAYFISH. This predates EDR running before system startup and takes advantage of there being limited, if any at all, telemetry on what software and drivers are running at this time. The new book Evading EDR, by Matt Hand, has a section on how EDR runs pre boot actions. Chapter 11 Early Launch Antimalware Drivers. Microsoft introduced a new anti- malware feature in Windows 8 that allows certain special drivers to load before all other boot-start drivers. Today, nearly all EDR vendors leverage this capability, called Early Launch Antimalware (ELAM), in some way, as it offers the ability to affect the system extremely early in the boot process. It also provides access to specific types of system telemetry not available to other components. Thanks to the Shadow Brokers, we can get a good idea of some of the modules that were loaded as part of the framework. An interesting example is mstcp32.sys. This is for intercepting packets and executing commands based on fields seen. Though it’s for intercepting packets, it acts as a root kit, performing kernel calls on the fly to the registry and staying away from prying eyes. This can be observed in the below in some brief example calls to the registry. DOUBLEFANTASY DOUBLEFANTASY is one of the earliest droppers that Equation Group developed and it was discovered, interestingly enough, on CD’s sent to conference attendees that were at a Houston event. It was deployed as a generic dropper alongside a custom developed AutoRun file that loaded and executed the DLL from disk. Both it and the DLL employed a set of 0days to get root access which leads to the conclusion that they probably were meant to run independently of one another. When ran, a simple XOR decryption was performed and DOUBLEFANTASY checked the registry for installed AV from a pre defined list of vendors. At the time, the method of using key enumeration was “non alarming” as opposed to directly accessing the key. Nowadays we refer to this method as T1012 and there’s many detection patterns built around it. If no known AV was found, the malware persisted and executed further. Otherwise, it cleaned up and no one was the wiser. This was a lot simpler when there was such few AV vendors, and barely any of them were worth their salt at detecting threats. Nowadays, this is far less likely to accurately find AV to avoid and the key enumeration would raise alarms. FANNY The earliest sample Kaspersky was able to analyze had a compiled time stamp of 2008, two years before the same zero days would be used in Stuxnet, in conjunction with two more, to cripple Irans nuclear efforts. FANNY, due to the nature of the sensitivity of its payload, would naturally want to remain undetected by prying eyes. This means that targeting appropriate systems and individuals is of the utmost importance. FANNY itself is easiest to think of as a persistent loader. Similar to Stuxnet, it uses the LNK exploit to autorun from USB drives even if autorun is disabled. Where they differ is that FANNY had a much broader target OS scope. Once FANNY executes, it fetches a payload from the C2 for further post-exploitation features. But it also has the ability to persist on the USB in order to relay commands back and forth from air gapped machines. This leads us into the first evasion technique that FANNY employs. Each time there is a successful infection, a counter decreases and when that hits 1, execution stops and FANNY stops further infections. This limits the spread and allows the operators to try and keep it contained within the target environment. The next evasion technique is a little counter-intuitive. How might you weed out systems that have AV or other software that can expose your operation? FANNY did this by making it quickly obvious to AV and analysts that it was typical crimeware that should be removed. Any analyst looking at it would just write it off as malware that was cleaned up, maybe reimage the system to be safe, and Equation Group would keep their real tools safe from further scrutiny. And this worked well, really well. For six years it was detected only as part of the zbot malware family until Kaspersky went hunting for the Equation Groups tools based on a library signature. If the module persisted past this point, only then would further payloads be fetched. GRAYFISH GRAYFISH is described by researchers as the Equation Groups most modern and sophisticated malware implant. This can be observed through numerous developments in methodology and tactics, such as leveraging 0days in HDD firmware to persist indefinitely after hard drive wipes , leveraging the registry to store and hide modules, and installing a bootkit to entirely control the start to finish boot process how they like. When the computer starts, GRAYFISH hijacks the OS loading mechanisms by injecting its code into the boot record. This allows it to control the launching of Windows at each stage. In fact, after infection, the computer is not run by itself more: it is GRAYFISH that runs it step by step, making the necessary changes on the fly. Normally, user space apps are not allowed to execute with ring 0 privileges. GRAYFISH bypassed this by leveraging a vulnerable driver, a technique now known as bring your own vulnerable driver (BYOVD.) This allowed the actors to execute their tools as the highest privilege available. To bypass modern OS security mechanisms that block the execution of untrusted code in kernel mode, GRAYFISH exploits several legitimate drivers, including one from the CloneCD program. This driver ( ElbyCDIO.sys) contains a vulnerability which GRAYFISH exploits to achieve kernel-level code execution. Despite the fact that the vulnerability was discovered in 2009, the digital signature has not yet been revoked. Another uncommon technique, for the time, was to live off of the registry. You can see this technique in MITRE ATT&amp;CK as T1112. The GRAYFISH implementation appears to have been designed to make it invisible to antivirus products. When used together with the bootkit, all the modules as well as the stolen data are stored in encrypted form in the registry and dynamically decrypted and executed. There are no malicious executable modules at all on the filesystem of an infected system. Unfortunately, I can’t get any samples of GRAYFISH to look at further myself, so my summary of evasion techniques is limited to what’s publicly already been discussed, and there’s little available in that regard. What’s Happening Today That’s a historical look at evasion using Equation Group as an example, but evasion continues to change every day to adapt to new and changing EDR products. Below I have a set of some of my favorite techniques that I think represent a rapid growth in the offsec research environment. I can’t do each of them justice, they all deserve a post dedicated solely to them, but I will try to accurately summarize them for quick reference and provide a project that utilizes them. Syswhispers SysWhispers allows teams to directly reference syscall numbers without having to go through NTDLL for them. Hells Gate is an evolution of this and enumerates the NTDLL table for these numbers. SysWhispers is a header library/asm file combo that you can import into your project that has the correct ID for each call needed. Since you now have the correct ID numbers, you don’t need to import NTDLL to perform your syscalls. There’s been a few evolutions from the original SysWhispers, we now have 2 and 3. Each iteration has added different support and uses different compilers. Sleep obfuscation MDSecs Peter Winter-Smith can be credited with a lot of the work that went into developing sleep obfuscation, though back in 2016 Gargoyle laid much of the ground work. The example that I will use for this is Cronos, which credits Ekko, which in turn credits Peter for their inspiration. At a base level the Cronos function RC4 encrypts the running process then changes its memory from RW to RX. But sleep obfuscation is a lot more complicated than just this. Rewinding back to 2016, when scanners originally caught onto Gargoyle marking sections as non executable, SleepyCrypt came along and performed a single byte XOR to encrypt the malicious section. Now scanners will quickly brute force this which caused researchers to look for new techniques. Foliage was the first to use encryption of the running process and leveraged a ROP chain to achieve execution after sleep. Ekko and Cronos followed suit, iterating on this with Ekko utilizing an RSP register to make the ROP chain much more stable. This is accomplished because the RSP register is your stack pointer. This article by TrustFoundry is very helpful for further understanding this. Spoofing the thread call stack This is a lot like sleep obfuscation but it has a slightly different end result. You will perform the necessary steps of loading the shellcode, acquire your function pointers, then hook the kernel32!Sleep method to point to our own version. We allocate the memory, copy the shellcode contents into it, and then call CreateThread to begin execution. As soon as the implant finishes its tasks and attempts to sleep, our custom sleep callback is invoked which will copy then overwrite the return address on the stack to 0 - meaning the code goes no where. Then the implant sleeps for the specified period and afterwards restores the copied return address to the stack allowing execution to continue. Reflective DLL loaders Reflect DLL injection is a technique to run a DLL entirely in memory. First you calculate the size of the DLL to load, allocate a memory region for it, and copy it into there. But DLLs aren’t designed to run from memory, they’re designed to export functions while on disk. Stephen Fewers example solves this by exporting a primary function that handles this loading through a version of LoadLibrary that can handle being passed memory regions to read from. I’m not doing this justice with my explanation so I encourage anyone unfamiliar with this to play around with the exampel and attempt to get it to execute. Disabling ETW ETW stands for event tracing for Windows and provides robust heuristics on running processes and syscalls. This makes it a great tool for EDR to easily monitor processes for suspicious actions. EDR especially likes this because even if their hooks are removed from NTDLL to mask calls that way, the access is still logged through ETW. Bypassing both then becomes a requirement for engagements. Another MDSec researcher (I’m seeing a trend here…) Adam Chester, has a blog post as well that is linked from within the White Knight Labs article. He simply overwrites the start of the function with the return bytes so that when it is called it just runs its clean up routine and exits. Removing hooks from NTDLL This is definitely the simplest approach to evasion and entails removing EDR hooks placed in loaded copies of NTDLL. When a new process is started, that process needs to determine different syscalls to use. Those memory locations are referenced from NTDLL. EDR knows this and patches the copy loaded so that suspicious calls JMP to the EDR for analysis before returning back to normal process flow if it is determined to be safe. There are a couple of ways to remove these hooks. You can remove on a per call basis so that maybe only CreateRemoteThread will avoid the EDR. Or you can copy the entire .text section of the file and overwrite how it is in the running process. I’ve not linked a project here because there’s a ton of different methods for doing it, all with their own ups and downs.","headline":"The Evolution Of Evasion","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/The-evolution-of-evasion/"},"url":"/posts/The-evolution-of-evasion/"}</script><title>The Evolution Of Evasion | Culbert Report</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Culbert Report"><meta name="application-name" content="Culbert Report"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/thumb.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Culbert Report</a></div><div class="site-subtitle font-italic">Offensive security with a dash of becoming a better programmer. Art by Kenton Drumm</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/matt-culbert" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/mattculbert" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['matt','culbertreport.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>The Evolution Of Evasion</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>The Evolution Of Evasion</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1692489600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 20, 2023 </em> </span> <span> Updated <em class="" data-ts="1692732933" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 22, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/">Matt Culbert</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2689 words"> <em>14 min</em> read</span></div></div></div><div class="post-content"><h1 id="the-evolution-of-evasion">The evolution of evasion</h1><p>Evasion is a very interesting topic. When I say evasion, I’m referring to both evading prying eyes from analysts and avoiding their attention, as well as evading AV and EDR. We can see how espionage operations in 2000 led to advancements in EDR and OS mitigations today in 2023. The Equation Group is fascinating to study in this area because for so long their operations went unattributed. And this can be directly tied to how well they tailored their target list and worked to keep themselves from being discovered. Thanks to the Shadow Brokers and Kaspersky, we are able to now get a deep insight into their specific methodology and techniques used in one stage of their operational development. Kaspersky also provided a lot of great analysis and documentation in the year leading up to the public release of the toolsets. After analyzing some of Equation Groups leaked tools, I’ll also touch on some modern developments in evasion. The modern land scape is a lot different than even just a couple years ago - go figure.</p><h3 id="equationdrug"><span class="mr-2">EQUATIONDRUG</span><a href="#equationdrug" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>EQUATIONDRUG is one of the first tools that was developed in the Equation Group arsenal and one of the tools leaked through the Shadow Brokers. It is best described as a post exploitation platform that is loaded onto interesting targets following an initial infection by DOUBLEFANTASY. It was developed, possibly, as far back as 1996. It primarily targeted XP operating systems and GRAYFISH evolved from there to target additional Windows versions. Due to the extensive leaks of certain tools, anyone can examine some of these in Ghidra and PEStudio and gather some fascinating insights on their modus operandi. For example, at the bottom of the picture you can see <code class="language-plaintext highlighter-rouge">KeServiceDescriptorTable</code> is imported.</p><p><a href="/assets/img/evasion-tech/proc-exp.png" class="popup img-link "><img data-src="/assets/img/evasion-tech/proc-exp.png" alt="ProcExp" class="lazyload" data-proofer-ignore></a></p><p>Perusing the decompiled source, you can find how this function was utilized.</p><p><a href="/assets/img/evasion-tech/equation-add-system-calls.png" class="popup img-link "><img data-src="/assets/img/evasion-tech/equation-add-system-calls.png" alt="EventLog-Edit" class="lazyload" data-proofer-ignore></a></p><p>I’ll be upfront that I’m not an expert in analyzing the decompiled and optimized code Ghidra returns from compiled sources, but we can see two clear calls here and correlate them with compiled information from Kaspersky. That is KeServiceDescriptorTable and KeAddSystemServiceTable. The latter of these is for adding new system calls to the SSDT which PeStudio actually missed when pulling strings out. On Vista and above this is no longer possible because there is only room for two; the kernels and win32ks. Equation Group was using these calls in order to add a new subsystem for a harder to detect angle of attack. To a modern audience, this is nothing new. Attackers have been leveraging Windows subsystem for Linux since it came out of testing. But at the time, this was quite novel since it was not a clearly documented Nt function.</p><p>Going back to Kasperskys research, <a href="https://securelist.com/a-fanny-equation-i-am-your-father-stuxnet/68787/">they identified a key feature</a> in FANNY (discussed here later) was that it was able to replace SSDT entries for functions with their own calls to perform whatever actions they want.</p><blockquote><p>The implementation of the exploit in Fanny is more complex than in Stuxnet: instead of running just one payload the authors created a framework to run as many payloads as they want by replacing a system service call dispatcher nt!NtShutdownSystem with their own custom pointer from the user-space as shown in the next figure.</p></blockquote><p>It’s not out of the question that a similar functionality was implemented into EQUATIONDRUG based on the below excerpt from an analyzed DLL.</p><p><a href="/assets/img/evasion-tech/ntshutdown-replacement.png" class="popup img-link "><img data-src="/assets/img/evasion-tech/ntshutdown-replacement.png" alt="NtShutdownSystem" class="lazyload" data-proofer-ignore></a></p><p>We can breakdown the above sample in more manageable chunks. FUN_68003e16 is a function that takes an <code class="language-plaintext highlighter-rouge">HMODULE</code> and a <code class="language-plaintext highlighter-rouge">char</code>. An <code class="language-plaintext highlighter-rouge">HMODULE</code> is the DLLs base address. Looking at the compiled Assembly, the full instruction at this address is <code class="language-plaintext highlighter-rouge">LEA EDI,[ESI + 0x18]</code>. <code class="language-plaintext highlighter-rouge">LEA</code> is interesting because it does memory calculations to determine an offset and then store it in any register. I want to avoid diving into the weeds of this too much since it will be so easy to get lost in the nuance of what makes LEA special but basically it’s the only Assembly instruction that lets you perform memory addressing calculations without addressing the memory. This is significant because in FUN_68003e16, they call GetProcAddress for this offset and proceed to use the pointer declared to overwrite it from one instruction to another - just as was observed with FANNY.</p><p>EQUATIONDRUG also had a very unique capability at the time, and that was running before system startup fully completed. This methodology was more realized in the subsequent platform GRAYFISH. This predates EDR running before system startup and takes advantage of there being limited, if any at all, telemetry on what software and drivers are running at this time. The new book Evading EDR, by Matt Hand, has a section on how EDR runs pre boot actions. Chapter 11 Early Launch Antimalware Drivers.</p><blockquote><p>Microsoft introduced a new anti- malware feature in Windows 8 that allows certain special drivers to load before all other boot-start drivers. Today, nearly all EDR vendors leverage this capability, called Early Launch Antimalware (ELAM), in some way, as it offers the ability to affect the system extremely early in the boot process. It also provides access to specific types of system telemetry not available to other components.</p></blockquote><p>Thanks to the Shadow Brokers, we can get a good idea of some of the modules that were loaded as part of the framework. An interesting example is mstcp32.sys. This is for intercepting packets and executing commands based on fields seen. Though it’s for intercepting packets, it acts as a root kit, performing kernel calls on the fly to the registry and staying away from prying eyes. This can be observed in the below in some brief example calls to the registry.</p><p><a href="/assets/img/evasion-tech/call_to_delete.png" class="popup img-link "><img data-src="/assets/img/evasion-tech/call_to_delete.png" alt="Call 2 Delete Reg" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/img/evasion-tech/delete_registry.png" class="popup img-link "><img data-src="/assets/img/evasion-tech/delete_registry.png" alt="Delete Reg" class="lazyload" data-proofer-ignore></a></p><h3 id="doublefantasy"><span class="mr-2">DOUBLEFANTASY</span><a href="#doublefantasy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>DOUBLEFANTASY is one of the earliest droppers that Equation Group developed and it was discovered, interestingly enough, on CD’s sent to conference attendees that were at a Houston event. It was deployed as a generic dropper alongside a custom developed AutoRun file that loaded and executed the DLL from disk. Both it and the DLL employed a set of 0days to get root access which leads to the conclusion that they probably were meant to run independently of one another. When ran, a simple XOR decryption was performed and DOUBLEFANTASY checked the registry for installed AV from a pre defined list of vendors. At the time, the method of using key enumeration was “non alarming” as opposed to directly accessing the key. Nowadays we refer to this method as <a href="https://attack.mitre.org/techniques/T1012/">T1012</a> and there’s many detection patterns built around it. If no known AV was found, the malware persisted and executed further. Otherwise, it cleaned up and no one was the wiser. This was a lot simpler when there was such few AV vendors, and barely any of them were worth their salt at detecting threats. Nowadays, this is far less likely to accurately find AV to avoid and the key enumeration would raise alarms.</p><h3 id="fanny"><span class="mr-2">FANNY</span><a href="#fanny" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The earliest sample Kaspersky was able to analyze had a compiled time stamp of 2008, two years before the same zero days would be used in Stuxnet, in conjunction with two more, to cripple Irans nuclear efforts. FANNY, due to the nature of the sensitivity of its payload, would naturally want to remain undetected by prying eyes. This means that targeting appropriate systems and individuals is of the utmost importance.</p><p>FANNY itself is easiest to think of as a persistent loader. Similar to Stuxnet, it uses the LNK exploit to autorun from USB drives even if autorun is disabled. Where they differ is that FANNY had a much broader target OS scope. Once FANNY executes, it fetches a payload from the C2 for further post-exploitation features. But it also has the ability to persist on the USB in order to relay commands back and forth from air gapped machines. This leads us into the first evasion technique that FANNY employs. <a href="https://securelist.com/a-fanny-equation-i-am-your-father-stuxnet/68787/">Each time there is a successful</a> infection, a counter decreases and when that hits 1, execution stops and FANNY stops further infections. This limits the spread and allows the operators to try and keep it contained within the target environment.</p><p>The next evasion technique is a little counter-intuitive. How might you weed out systems that have AV or other software that can expose your operation? FANNY did this by making it quickly obvious to AV and analysts <a href="https://securelist.com/a-fanny-equation-i-am-your-father-stuxnet/68787/">that it was typical crimeware</a> that should be removed. Any analyst looking at it would just write it off as malware that was cleaned up, maybe reimage the system to be safe, and Equation Group would keep their real tools safe from further scrutiny. And this worked well, really well. For six years it was detected only as part of the zbot malware family until Kaspersky went hunting for the Equation Groups tools based on a library signature. If the module persisted past this point, only then would further payloads be fetched.</p><h3 id="grayfish"><span class="mr-2">GRAYFISH</span><a href="#grayfish" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>GRAYFISH is described by researchers as the Equation Groups most modern and sophisticated malware implant. This can be observed through numerous developments in methodology and tactics, such as leveraging 0days in HDD firmware to persist indefinitely after hard drive wipes , leveraging the registry to store and hide modules, and installing a bootkit to entirely control the start to finish boot process how they like.</p><blockquote><p><a href="https://cdn1.vox-cdn.com/uploads/chorus_asset/file/3415904/Equation_group_questions_and_answers.0.pdf">When the computer starts</a>, GRAYFISH hijacks the OS loading mechanisms by injecting its code into the boot record. This allows it to control the launching of Windows at each stage. In fact, after infection, the computer is not run by itself more: it is GRAYFISH that runs it step by step, making the necessary changes on the fly.</p></blockquote><p><a href="/assets/img/evasion-tech/grayfish-arch.png" class="popup img-link "><img data-src="/assets/img/evasion-tech/grayfish-arch.png" alt="Architecture" class="lazyload" data-proofer-ignore></a></p><p>Normally, user space apps are not allowed to execute with ring 0 privileges. GRAYFISH bypassed this by leveraging a vulnerable driver, a technique now known as bring your own vulnerable driver (BYOVD.) This allowed the actors to execute their tools as the highest privilege available.</p><blockquote><p>To bypass modern OS security mechanisms that block the execution of untrusted code in kernel mode, GRAYFISH exploits several legitimate drivers, including one from the CloneCD program. This driver ( ElbyCDIO.sys) contains a vulnerability which GRAYFISH exploits to achieve kernel-level code execution. Despite the fact that the vulnerability was discovered in 2009, the digital signature has not yet been revoked.</p></blockquote><p>Another uncommon technique, for the time, was to live off of the registry. You can see this technique in <a href="https://attack.mitre.org/techniques/T1112/">MITRE ATT&amp;CK as T1112</a>.</p><blockquote><p>The GRAYFISH implementation appears to have been designed to make it invisible to antivirus products. When used together with the bootkit, all the modules as well as the stolen data are stored in encrypted form in the registry and dynamically decrypted and executed. There are no malicious executable modules at all on the filesystem of an infected system.</p></blockquote><p>Unfortunately, I can’t get any samples of GRAYFISH to look at further myself, so my summary of evasion techniques is limited to what’s publicly already been discussed, and there’s little available in that regard.</p><h2 id="whats-happening-today"><span class="mr-2">What’s Happening Today</span><a href="#whats-happening-today" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>That’s a historical look at evasion using Equation Group as an example, but evasion continues to change every day to adapt to new and changing EDR products. Below I have a set of some of my favorite techniques that I think represent a rapid growth in the offsec research environment. I can’t do each of them justice, they all deserve a post dedicated solely to them, but I will try to accurately summarize them for quick reference and provide a project that utilizes them.</p><h3 id="syswhispers"><span class="mr-2"><a href="https://github.com/jthuraisamy/SysWhispers">Syswhispers</a></span><a href="#syswhispers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>SysWhispers allows teams to directly reference syscall numbers without having to go through NTDLL for them. Hells Gate is an evolution of this and enumerates the NTDLL table for these numbers. SysWhispers is a header library/asm file combo that you can import into your project that has the correct ID for each call needed. Since you now have the correct ID numbers, you don’t need to import NTDLL to perform your syscalls. There’s been a few evolutions from the original SysWhispers, we now have 2 and 3. Each iteration has added different support and uses different compilers.</p><h3 id="sleep-obfuscation"><span class="mr-2"><a href="https://github.com/Idov31/Cronos">Sleep obfuscation</a></span><a href="#sleep-obfuscation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>MDSecs Peter Winter-Smith can be credited with a lot of the work that went into developing sleep obfuscation, though back in 2016 Gargoyle laid much of the ground work. The example that I will use for this is Cronos, which credits Ekko, which in turn credits Peter for their inspiration. At a base level the Cronos function RC4 encrypts the running process then changes its memory from RW to RX. But sleep obfuscation is a lot more complicated than <em>just</em> this. Rewinding back to 2016, when scanners originally caught onto Gargoyle marking sections as non executable, SleepyCrypt came along and performed a single byte XOR to encrypt the malicious section. Now scanners will quickly brute force this which caused researchers to look for new techniques. Foliage was the first to use encryption of the running process and leveraged a ROP chain to achieve execution after sleep. Ekko and Cronos followed suit, iterating on this with Ekko utilizing an RSP register to make the ROP chain much more stable. This is accomplished because the RSP register is your stack pointer. <a href="https://trustfoundry.net/2019/07/18/basic-rop-techniques-and-tricks/">This article by TrustFoundry</a> is very helpful for further understanding this.</p><h3 id="spoofing-the-thread-call-stack"><span class="mr-2"><a href="https://github.com/mgeeky/ThreadStackSpoofer">Spoofing the thread call stack</a></span><a href="#spoofing-the-thread-call-stack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This is a lot like sleep obfuscation but it has a slightly different end result. You will perform the necessary steps of loading the shellcode, acquire your function pointers, then hook the kernel32!Sleep method to point to our own version. We allocate the memory, copy the shellcode contents into it, and then call CreateThread to begin execution. As soon as the implant finishes its tasks and attempts to sleep, our custom sleep callback is invoked which will copy then overwrite the return address on the stack to 0 - meaning the code goes no where. Then the implant sleeps for the specified period and afterwards restores the copied return address to the stack allowing execution to continue.</p><h3 id="reflective-dll-loaders"><span class="mr-2"><a href="https://github.com/stephenfewer/ReflectiveDLLInjection">Reflective DLL loaders</a></span><a href="#reflective-dll-loaders" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Reflect DLL injection is a technique to run a DLL entirely in memory. First you calculate the size of the DLL to load, allocate a memory region for it, and copy it into there. But DLLs aren’t designed to run from memory, they’re designed to export functions while on disk. Stephen Fewers example solves this by exporting a primary function that handles this loading through a version of LoadLibrary that can handle being passed memory regions to read from. I’m not doing this justice with my explanation so I encourage anyone unfamiliar with this to play around with the exampel and attempt to get it to execute.</p><h3 id="disabling-etw"><span class="mr-2"><a href="https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/">Disabling ETW</a></span><a href="#disabling-etw" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>ETW stands for event tracing for Windows and provides robust heuristics on running processes and syscalls. This makes it a great tool for EDR to easily monitor processes for suspicious actions. EDR especially likes this because even if their hooks are removed from NTDLL to mask calls that way, the access is still logged through ETW. Bypassing both then becomes a requirement for engagements. Another MDSec researcher (I’m seeing a trend here…) Adam Chester, has a blog post as well that is linked from within the White Knight Labs article. He simply overwrites the start of the function with the return bytes so that when it is called it just runs its clean up routine and exits.</p><h3 id="removing-hooks-from-ntdll"><span class="mr-2">Removing hooks from NTDLL</span><a href="#removing-hooks-from-ntdll" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>This is definitely the simplest approach to evasion and entails removing EDR hooks placed in loaded copies of NTDLL. When a new process is started, that process needs to determine different syscalls to use. Those memory locations are referenced from NTDLL. EDR knows this and patches the copy loaded so that suspicious calls <code class="language-plaintext highlighter-rouge">JMP</code> to the EDR for analysis before returning back to normal process flow if it is determined to be safe.</p><p>There are a couple of ways to remove these hooks. You can remove on a per call basis so that maybe only CreateRemoteThread will avoid the EDR. Or you can copy the entire .text section of the file and overwrite how it is in the running process. I’ve not linked a project here because there’s a ton of different methods for doing it, all with their own ups and downs.</p></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The%20Evolution%20Of%20Evasion%20-%20Culbert%20Report&url=%2Fposts%2FThe-evolution-of-evasion%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The%20Evolution%20Of%20Evasion%20-%20Culbert%20Report&u=%2Fposts%2FThe-evolution-of-evasion%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FThe-evolution-of-evasion%2F&text=The%20Evolution%20Of%20Evasion%20-%20Culbert%20Report" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Human-Learning-Is-Irreplaceable/">Human Learning Is Irreplaceable</a><li><a href="/posts/Building-A-Detection-Lab-Around-Suricata/">Building A Detection Lab Around Suricata</a><li><a href="/posts/Making-Red-Teaming-Safer/">Making Red Teaming Safer</a><li><a href="/posts/The-evolution-of-evasion/">The Evolution Of Evasion</a><li><a href="/posts/C2-Smackdown-Empire-vs-Mythic/">C2 Smackdown Empire Vs Mythic</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Human-Learning-Is-Irreplaceable/"><div class="card-body"> <em class="small" data-ts="1759881600" data-df="ll" > Oct 8, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Human Learning Is Irreplaceable</h3><div class="text-muted small"><p> What we call “AI” is really just a cancer attacking our ability to learn and we have very little time remaining to carve it out. A note When I began writing this, it was June in Vermont and one ...</p></div></div></a></div><div class="card"> <a href="/posts/Building-A-Detection-Lab-Around-Suricata/"><div class="card-body"> <em class="small" data-ts="1720656000" data-df="ll" > Jul 11, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Building A Detection Lab Around Suricata</h3><div class="text-muted small"><p> Building A Detection Lab Around Suricata A while back there were a flurry of posts from different people about how they were configuring their homelabs, rebuilding them to do X better than somet...</p></div></div></a></div><div class="card"> <a href="/posts/Making-Red-Teaming-Safer/"><div class="card-body"> <em class="small" data-ts="1707955200" data-df="ll" > Feb 15, 2024 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Making Red Teaming Safer</h3><div class="text-muted small"><p> I have been quietly hard at work the past few months turning an old project that didn’t quite work even half the time into a framework that provides the solid base of functionality required to bui...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/C2-Smackdown-Empire-vs-Mythic/" class="btn btn-outline-primary" prompt="Older"><p>C2 Smackdown Empire Vs Mythic</p></a> <a href="/posts/Subdomain-Takeovers/" class="btn btn-outline-primary" prompt="Newer"><p>Subdomain Takeovers</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/">Matt Culbert</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
