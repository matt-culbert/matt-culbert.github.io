<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="A Beginners Guide To Everything WebApp Pentesting" /><meta name="author" content="Matt C" /><meta property="og:locale" content="en" /><meta name="description" content="So you want to be a pentester &nbsp;&nbsp;&nbsp; There&#39;s a ton of different types of pentesting that you can do. What we&#39;ll talk about here though is website pentesting. This is the type of pentesting that will help developers secure websites that you and other people, potentially globally, will have access to so it&#39;s pretty important. But there are a lot of ways to remove any of the value that it can bring project owners. Some testers for instance will only use automated tools and don&#39;t understand the output that they generate and just hand over a report. This is unhelpful because as a pentester it&#39;s your duty to know why vulnerabilities appear on Burp and how to resolve them. Building off of that, as well as knowing the vulnerabilities, you should understand any solutions you offer and avoid canned suggestions. Today we will review the necessary prep work, what tools to use, common vulnerabilities to look for, and how to put it together in a report. This post is intended for people who are new to web app pentesting or those who want to know whats needed at a semi technical level in order to succeed. Also note, all demonstrations are either using culbertreport.com or a vulnerable version of OrangeHRM/LotusCMS. The paperwork &nbsp;&nbsp; &nbsp;Before you begin an actual pentest, there are some important items that you need to get out of the way. Of those, permission and scope will be the most important ones. Get a proper scope defined for what URLs are valid, what accounts can be targeted, and what must be explicitly avoided. In the same vein, make sure you have full permission from the web site owners to perform the pentest. Without these, you&#39;re treading on thin ice. &nbsp; &nbsp;&nbsp; &nbsp;The typical scope discussion and documentation will tell you that there are numerous URLs like subdir1.staging.culbertreport.com that are in scope, whether or not you&#39;re testing the staging environment (and you should really only test there) and whether or not it contains real data - you need to know whether or not the data you may see is potentially real PHI, for example, as there are other liabilities around this and BAA&#39;s that need to be signed. You also may or may not be given an account to use and you should also be given a point of contact who controls the webapp environment. This is to be used to relay findings but also in case you get locked out of the testing environment, something gets broken, or an attack accidentally leaks over to production and it needs to be remedied. Tools to use &nbsp;&nbsp;&nbsp; Now that you&#39;ve gotten the paper work out of the way, what tools do you use? Well there are a ton of tools, both paid and free, out there but really you will be fine with using 3/5 of the below for 99% of your engagements.&nbsp; Burp Suite &nbsp;&nbsp; &nbsp;Tried and true. This is in everyone&#39;s tool box because it has 99% of everything you will need in an engagement and, if it doesn&#39;t, there&#39;s either a plugin already made for it or you can write one for it.&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; For those unfamiliar with the tool, there&#39;s a LOT to take in with this screen. The majority of your work will be done in the proxy and the repeater tab. The proxy is where you will either direct your browsers traffic through or launch a custom Chromium instance and see all of the traffic you&#39;ve generated pass through, and the repeater allows you to send different requests repeatedly while changing whatever parameters you wish to in that request. Other tabs you may use include the sequencer, which will tell you whether or not there are issues with how cookies are generated, and the extender page where you can download extensions like I have for JSON Web Tokens. Burp Suite EnterpriseBurp Enterprise is fantastic for automating the more mundane portions of your engagements and for passively collecting vulnerability details as you work as well as running auditing scans. If your organization can afford an enterprise license, the tools that come with it will make the cost well worth it. Some highlights that are worth noting include the auditing scans to test for every exploit possible against every URL - though it&#39;s very important that this is only run against a staging environment that can be broken and you should not rely on this to find everything exploitable. Another highlight is that while you browse the site, Burp will passively note vulnerable components. For instance potentially there was a JS dependency that was missed by your manual investigation. OWASP Zap &nbsp;&nbsp; &nbsp;The lesser known cousin to Burp. It has much the same toolkit but in a slightly different UI. There&#39;s not much to say here, it&#39;s a cool tool and you can&#39;t go wrong using it.&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;If you&#39;re coming from Burp, this UI makes far less sense initially. But as you use it, it quickly becomes apparent where the features you&#39;ve come to expect with Burp hide under, and one bonus is that Zap will do passive enumeration of issues similar to how Burp Enterprise does.&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; As well as the passive enumeration, the request editor works much the same was as Burp Suites version, just a slightly different UI. &nbsp; SQLMap &nbsp;&nbsp; &nbsp;If you see SQL errors during an engagement, you can break out SQLMap to see if any of it is truly exploitable. I personally find SQLMap is best used with a valid request taken from Zap or Burp saved to a text file. This way you don&#39;t have to spend time messing with authorization parameters to reach the point you want to test. The tool will be demonstrated further below but your typical flow will look like this:&nbsp; sqlmap -r request.txt # SQLMap will figure out what position is exploitable in the request sqlmap -r request.txt --dbs&nbsp; # We then get the different databases sqlmap -r request.txt -D target_DB --tables # Get the tables from the target DBsqlmap -r request.txt -D target_DB -T target_table -dump # Then finally dump the contents of the table SSLscan&nbsp; &nbsp;&nbsp; &nbsp;This tool, for the most part, is covered by what&#39;s provided through Burp Enterprise. But if you don&#39;t have one of those licenses, this will be a nice compliment to your toolkit. SSLScan examines encrypted communications, such as HTTPS, and finds all the ciphers that are supported. This is the non flashy side of web app testing. Determining if weak ciphers are in use or if protocols that would be regulatory failings are in use is very important. Common vulnerabilities you&#39;ll test for &nbsp;&nbsp;&nbsp; Now that you&#39;ve got your tools selected and tested, you&#39;re going to start wanting to test the website. But what do you look for and why? Do you stick with the OWASP top 10? It&#39;s a respectable list but it&#39;s not nearly inclusive of everything you should look at. CSRF &nbsp;&nbsp; &nbsp;Cross-site request forgery. An easy one to test for and really important for testers to find attackable examples. This occurs when you are allowed to send requests with the referer field being set to another host. Typically, when you click a function in a site, a request is sent and the referer field tells the site where this is coming from. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;But with CSRF, this field is not properly validated. For example, see the below request. &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;In the above picture, the referer is set to attacker.com. Why is this bad? Take for example a site that requires admins manually add new users to it. Through testing, you may be able to determine the fields that are expected to sign up a user with but you still don&#39;t have the required permissions to add yourself. If you can trick an admin level user into clicking a button on another site that fires off this POST though, and that admin has a currently valid session, all of a sudden you&#39;re signed up!&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;An important note, validating the referer field is not the only way to protect against CSRF. There are token based systems that will be more reliable, but these are more complex and simply validating the referer will get you 99.99% of the way there. XSS &nbsp;&nbsp; &nbsp;Cross-site scripting. Everyone&#39;s heard of it and everyone looks for it. What is it actually doing though and why is this dangerous?&nbsp; First, there&#39;s a few different types of XSS to test for.&nbsp; The most common one I&#39;ve seen is stored, which is where you enter something like a comment on a site and then any visitors afterwards will be affected.&nbsp;Followed by that is reflected, which is when you send someone a link like https://cr.culbertreport.com/search?q=&lt;script&gt;alert(1)&lt;/script&gt; and upon clicking this link they trigger the alert popup.&nbsp;And finally is DOM. This refers to the document object model and can be thought of similarly to reflected XSS, but they attack two different functions. This one will be by far the most complicated to attack. I really encourage anyone curious to read the OWASP entry as it explains it in the best way possible. This is the only XSS that can be executed in such a way that the server has no idea that the user fell victim to this as well. This is accomplished by using a # in the URI to fragment it and have the XSS be loaded client side by the DOM.&nbsp; &nbsp;&nbsp;&nbsp; What each of these are doing is modifying web pages to have attacker supplied elements due to improper sanitization of supplied input. This can then be leveraged by an attacker to do things like stealing session cookies from users. So with the stored XSS example, we can insert an element to get the document.cookie value from users who browse there and send it off to requestbin.net. This would then let you hijack their sessions and perform actions as those compromised users.&nbsp; &nbsp;&nbsp;&nbsp; The typical protections for this are to escape special characters and sanitize the user input. Escaping in this case means to invalidate potential HTML characters like &quot;&lt;&quot; through methods like encoding. Sanitizing would be to strip those special characters entirely from the supplied input. SQLi &nbsp;&nbsp;&nbsp; Another common one. This attack exploits sites that do not properly validate user supplied input before executing SQL queries with it. A common test to do this is to append a &#39; to the end of every input field and look for the 500 internal error response or a 200 OK that returns the SQL error. What you&#39;re doing with this test is starting a string and then not closing it, hence why the server responds with a SQL error. This can be leveraged either manually or automatically with SQLMap to then do things like dump database contents or pop a shell. &nbsp;&nbsp;&nbsp; There are a number of protections against SQL injection ranging from using prepared statements to what we did with XSS and try to escape the supplied input and treat it as a string. They each have pros and cons and it&#39;s important to remember that no solution is perfect.&nbsp; Directory traversal &nbsp;&nbsp;&nbsp; This occurs when attackers can access files outside of the web sites root directory. You typically see this with people putting a series of &#39;../&#39; into the URL hoping to escape as this gets interpreted by the web server sometimes as user input to move up a directory. &nbsp;&nbsp; &nbsp;Protecting against this is typically equally as simple as the attack itself. First, ensure that user input is valid and remove unexpected characters. Then second, when processing resource requests, append the requested path to the folders canonical path. This will ensure that any requests stay inside the websites root directory. User account takeover &nbsp;&nbsp;&nbsp; This is important to test for as it could allow another bigger issue, privilege escalation. This typically takes advantage of the password reset function. Often times, this function uses your cookie to identify who you are and whose password to reset. But sometimes the application passes a user ID to the back-end which can then be modified allowing the attacker to take over another users account.&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; This falls under broken access control - a user should only have access to their own resources and so any requests like this need to be validated against their permissions. If proper validation were in place, the back-end would see this request and see that the requested user ID to edit did not match the users ID or permission level and then kick back an error. Privilege escalation &nbsp;&nbsp;&nbsp; Privilege escalation is right behind user account take over because they often use the same method - poor validation on a password reset. Another method is forceful browsing. Sometimes when logging in, the page will return a redirect to the standard user page and this can be modified to point to the admin page instead, allowing elevation of user privileges especially if functions within the admin panel do not do validation on user privilege level. Forceful browsing like this can in some cases take guessing to determine the correct admin page location unless you use a tool like Dirbuster to automate this. &nbsp;&nbsp;&nbsp; Developers should ensure that all requests are validated against the users permission level. Both of these scenarios, forced browsing and accessing other users information, also falls under broken access control. Sensitive information disclosure &nbsp;&nbsp;&nbsp; Web developers often overlook the advantage that these disclosures in error messages can give attackers. You can determine software versions, if something is a SQL back-end, what file types are allowed to be uploaded, and where in your exploitation the server stopped and kicked back an error to name a few.&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;In the above example, I&#39;ve now determined the framework version, the PHP version, and the MySQL version, as well as where errors are logged on the hosting server. This is all sensitive information as I can now look up attacks specific to these version numbers and it really simplifies the exploitation job.&nbsp; &nbsp;&nbsp; &nbsp;Returning errors like this is really handy in development, since it helps pinpoint exactly what is breaking, but in a production environment it gives away too much information. Instead, return generic error pages that only let users know something went wrong or the requested page is missing. Malicious file uploads &nbsp;&nbsp;&nbsp; If a site allows you to upload things like PHP or HTML, this can be leveraged by attackers to perform actions like listing /etc/passwd. &nbsp; &nbsp;&nbsp;&nbsp; This one is overall pretty simple. If you can upload files other than what was intended, that&#39;s an issue that needs fixing. Sometimes developers do put filters and only look for image files, but they only look for strings like jpeg in the file name. So if you upload file.jpeg.php, this will bypass their filter. &nbsp;&nbsp;&nbsp; Developers should use an allow list of extensions and avoid deny lists - the possible number of extension is far too much for any one person to keep track of. In addition to this, you should review that the allowed list of extensions only contains the bare minimum of file types needed for your application to function properly. You found a vulnerability, so what? &nbsp;&nbsp; &nbsp;Finding the vulnerability is not the end, your next responsibility is helping the client and developers fix the issues. Understanding what goes into fixing these issues is absolutely an important skill for quality pentesters to have. &nbsp;&nbsp; &nbsp;There&#39;s no shame in looking up the vulnerability on OWASP and finding a suggested solution there, but you should definitely understand why that solution works in the supplied example and be prepared for developer use cases to veer from the recommendations. Also be prepared for company priorities to shift and your finding to be downgraded. Just because OWASP says it&#39;s a high doesn&#39;t mean that your client or development team will feel the same way and ultimately it&#39;s their issue to deal with how they want.&nbsp; &nbsp;&nbsp;&nbsp; Take for example SQL injection. This is a common vulnerability to encounter and OWASP has a number of suggestions for protecting against it, so which should you pick? You have prepared statements, stored procedures, allow list input validation, and escaping all user supplied input. They each have pros and cons. For instance, escaping user supplied input assumes that you are actually catching all escape attempts. On the other hand, prepared statements are generally thought of as being able to stop SQL injection attempts against the parser, but it still leaves things like logging who writes what and user defined triggers vulnerable to SQL injection. Not to mention some people join supplied input strings to create prepared statements which defeats the purpose. There are a lot of ways that attempting to solve an issue can actually open you up to further damage, so understanding the environment and the solutions you will suggest is critical. Writing your report &nbsp;&nbsp;&nbsp; This can vary organization to organization, but typically this will include a high level discussion of the issues detected, their impact, and a total count of all the detected vulnerabilities followed by a table of each and supporting evidence. You should sort the detected vulnerabilities from high to low so that important issues catch the readers attention early and include clear steps for how to reproduce the detected issues to make developers lives easier. The faster the developers can see it in action, the faster they can determine where a fix needs to be placed and get it rolled out to staging.&nbsp;&nbsp;&nbsp; &nbsp;The high level discussion allows you to outline vulnerabilities that you thought were of note and discuss their potential impact if left unpatched. Getting across the right amount of urgency is crucial as too little will result in people leaving gaping holes while too much makes them treating future findings much more lightly then maybe they should. Think about the potential impact to client and customer data or reputational impact in order to judge how critical it is that something be patched in a week or in 90 days.&nbsp;&nbsp;&nbsp; Adding as much detail in the client facing report will reduce frustration on both ends as the developers can begin implementing fixes and the testers can focus on other work that needs to be done. Make sure you have your target audience in mind too when writing this, as going to technical will result in misunderstandings but leaving it too high level will have the report receivers scratching their heads figuring out the exact thing you meant. And that&#39;s it!&nbsp;&nbsp; This is what it takes at a basic level to be a competent pentester. Writing detailed reports and working with developers will be more than half your job. This is not a position where you can succeed by not working with others and especially be prepared to work with developers who are completely unfamiliar with working within a security context. Have sympathy as it&#39;s not their realm of expertise and they brought you in specifically to help them shore up this area. You can also learn a great deal from them on architecture and design philosophy." /><meta property="og:description" content="So you want to be a pentester &nbsp;&nbsp;&nbsp; There&#39;s a ton of different types of pentesting that you can do. What we&#39;ll talk about here though is website pentesting. This is the type of pentesting that will help developers secure websites that you and other people, potentially globally, will have access to so it&#39;s pretty important. But there are a lot of ways to remove any of the value that it can bring project owners. Some testers for instance will only use automated tools and don&#39;t understand the output that they generate and just hand over a report. This is unhelpful because as a pentester it&#39;s your duty to know why vulnerabilities appear on Burp and how to resolve them. Building off of that, as well as knowing the vulnerabilities, you should understand any solutions you offer and avoid canned suggestions. Today we will review the necessary prep work, what tools to use, common vulnerabilities to look for, and how to put it together in a report. This post is intended for people who are new to web app pentesting or those who want to know whats needed at a semi technical level in order to succeed. Also note, all demonstrations are either using culbertreport.com or a vulnerable version of OrangeHRM/LotusCMS. The paperwork &nbsp;&nbsp; &nbsp;Before you begin an actual pentest, there are some important items that you need to get out of the way. Of those, permission and scope will be the most important ones. Get a proper scope defined for what URLs are valid, what accounts can be targeted, and what must be explicitly avoided. In the same vein, make sure you have full permission from the web site owners to perform the pentest. Without these, you&#39;re treading on thin ice. &nbsp; &nbsp;&nbsp; &nbsp;The typical scope discussion and documentation will tell you that there are numerous URLs like subdir1.staging.culbertreport.com that are in scope, whether or not you&#39;re testing the staging environment (and you should really only test there) and whether or not it contains real data - you need to know whether or not the data you may see is potentially real PHI, for example, as there are other liabilities around this and BAA&#39;s that need to be signed. You also may or may not be given an account to use and you should also be given a point of contact who controls the webapp environment. This is to be used to relay findings but also in case you get locked out of the testing environment, something gets broken, or an attack accidentally leaks over to production and it needs to be remedied. Tools to use &nbsp;&nbsp;&nbsp; Now that you&#39;ve gotten the paper work out of the way, what tools do you use? Well there are a ton of tools, both paid and free, out there but really you will be fine with using 3/5 of the below for 99% of your engagements.&nbsp; Burp Suite &nbsp;&nbsp; &nbsp;Tried and true. This is in everyone&#39;s tool box because it has 99% of everything you will need in an engagement and, if it doesn&#39;t, there&#39;s either a plugin already made for it or you can write one for it.&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; For those unfamiliar with the tool, there&#39;s a LOT to take in with this screen. The majority of your work will be done in the proxy and the repeater tab. The proxy is where you will either direct your browsers traffic through or launch a custom Chromium instance and see all of the traffic you&#39;ve generated pass through, and the repeater allows you to send different requests repeatedly while changing whatever parameters you wish to in that request. Other tabs you may use include the sequencer, which will tell you whether or not there are issues with how cookies are generated, and the extender page where you can download extensions like I have for JSON Web Tokens. Burp Suite EnterpriseBurp Enterprise is fantastic for automating the more mundane portions of your engagements and for passively collecting vulnerability details as you work as well as running auditing scans. If your organization can afford an enterprise license, the tools that come with it will make the cost well worth it. Some highlights that are worth noting include the auditing scans to test for every exploit possible against every URL - though it&#39;s very important that this is only run against a staging environment that can be broken and you should not rely on this to find everything exploitable. Another highlight is that while you browse the site, Burp will passively note vulnerable components. For instance potentially there was a JS dependency that was missed by your manual investigation. OWASP Zap &nbsp;&nbsp; &nbsp;The lesser known cousin to Burp. It has much the same toolkit but in a slightly different UI. There&#39;s not much to say here, it&#39;s a cool tool and you can&#39;t go wrong using it.&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;If you&#39;re coming from Burp, this UI makes far less sense initially. But as you use it, it quickly becomes apparent where the features you&#39;ve come to expect with Burp hide under, and one bonus is that Zap will do passive enumeration of issues similar to how Burp Enterprise does.&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; As well as the passive enumeration, the request editor works much the same was as Burp Suites version, just a slightly different UI. &nbsp; SQLMap &nbsp;&nbsp; &nbsp;If you see SQL errors during an engagement, you can break out SQLMap to see if any of it is truly exploitable. I personally find SQLMap is best used with a valid request taken from Zap or Burp saved to a text file. This way you don&#39;t have to spend time messing with authorization parameters to reach the point you want to test. The tool will be demonstrated further below but your typical flow will look like this:&nbsp; sqlmap -r request.txt # SQLMap will figure out what position is exploitable in the request sqlmap -r request.txt --dbs&nbsp; # We then get the different databases sqlmap -r request.txt -D target_DB --tables # Get the tables from the target DBsqlmap -r request.txt -D target_DB -T target_table -dump # Then finally dump the contents of the table SSLscan&nbsp; &nbsp;&nbsp; &nbsp;This tool, for the most part, is covered by what&#39;s provided through Burp Enterprise. But if you don&#39;t have one of those licenses, this will be a nice compliment to your toolkit. SSLScan examines encrypted communications, such as HTTPS, and finds all the ciphers that are supported. This is the non flashy side of web app testing. Determining if weak ciphers are in use or if protocols that would be regulatory failings are in use is very important. Common vulnerabilities you&#39;ll test for &nbsp;&nbsp;&nbsp; Now that you&#39;ve got your tools selected and tested, you&#39;re going to start wanting to test the website. But what do you look for and why? Do you stick with the OWASP top 10? It&#39;s a respectable list but it&#39;s not nearly inclusive of everything you should look at. CSRF &nbsp;&nbsp; &nbsp;Cross-site request forgery. An easy one to test for and really important for testers to find attackable examples. This occurs when you are allowed to send requests with the referer field being set to another host. Typically, when you click a function in a site, a request is sent and the referer field tells the site where this is coming from. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;But with CSRF, this field is not properly validated. For example, see the below request. &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;In the above picture, the referer is set to attacker.com. Why is this bad? Take for example a site that requires admins manually add new users to it. Through testing, you may be able to determine the fields that are expected to sign up a user with but you still don&#39;t have the required permissions to add yourself. If you can trick an admin level user into clicking a button on another site that fires off this POST though, and that admin has a currently valid session, all of a sudden you&#39;re signed up!&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;An important note, validating the referer field is not the only way to protect against CSRF. There are token based systems that will be more reliable, but these are more complex and simply validating the referer will get you 99.99% of the way there. XSS &nbsp;&nbsp; &nbsp;Cross-site scripting. Everyone&#39;s heard of it and everyone looks for it. What is it actually doing though and why is this dangerous?&nbsp; First, there&#39;s a few different types of XSS to test for.&nbsp; The most common one I&#39;ve seen is stored, which is where you enter something like a comment on a site and then any visitors afterwards will be affected.&nbsp;Followed by that is reflected, which is when you send someone a link like https://cr.culbertreport.com/search?q=&lt;script&gt;alert(1)&lt;/script&gt; and upon clicking this link they trigger the alert popup.&nbsp;And finally is DOM. This refers to the document object model and can be thought of similarly to reflected XSS, but they attack two different functions. This one will be by far the most complicated to attack. I really encourage anyone curious to read the OWASP entry as it explains it in the best way possible. This is the only XSS that can be executed in such a way that the server has no idea that the user fell victim to this as well. This is accomplished by using a # in the URI to fragment it and have the XSS be loaded client side by the DOM.&nbsp; &nbsp;&nbsp;&nbsp; What each of these are doing is modifying web pages to have attacker supplied elements due to improper sanitization of supplied input. This can then be leveraged by an attacker to do things like stealing session cookies from users. So with the stored XSS example, we can insert an element to get the document.cookie value from users who browse there and send it off to requestbin.net. This would then let you hijack their sessions and perform actions as those compromised users.&nbsp; &nbsp;&nbsp;&nbsp; The typical protections for this are to escape special characters and sanitize the user input. Escaping in this case means to invalidate potential HTML characters like &quot;&lt;&quot; through methods like encoding. Sanitizing would be to strip those special characters entirely from the supplied input. SQLi &nbsp;&nbsp;&nbsp; Another common one. This attack exploits sites that do not properly validate user supplied input before executing SQL queries with it. A common test to do this is to append a &#39; to the end of every input field and look for the 500 internal error response or a 200 OK that returns the SQL error. What you&#39;re doing with this test is starting a string and then not closing it, hence why the server responds with a SQL error. This can be leveraged either manually or automatically with SQLMap to then do things like dump database contents or pop a shell. &nbsp;&nbsp;&nbsp; There are a number of protections against SQL injection ranging from using prepared statements to what we did with XSS and try to escape the supplied input and treat it as a string. They each have pros and cons and it&#39;s important to remember that no solution is perfect.&nbsp; Directory traversal &nbsp;&nbsp;&nbsp; This occurs when attackers can access files outside of the web sites root directory. You typically see this with people putting a series of &#39;../&#39; into the URL hoping to escape as this gets interpreted by the web server sometimes as user input to move up a directory. &nbsp;&nbsp; &nbsp;Protecting against this is typically equally as simple as the attack itself. First, ensure that user input is valid and remove unexpected characters. Then second, when processing resource requests, append the requested path to the folders canonical path. This will ensure that any requests stay inside the websites root directory. User account takeover &nbsp;&nbsp;&nbsp; This is important to test for as it could allow another bigger issue, privilege escalation. This typically takes advantage of the password reset function. Often times, this function uses your cookie to identify who you are and whose password to reset. But sometimes the application passes a user ID to the back-end which can then be modified allowing the attacker to take over another users account.&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; This falls under broken access control - a user should only have access to their own resources and so any requests like this need to be validated against their permissions. If proper validation were in place, the back-end would see this request and see that the requested user ID to edit did not match the users ID or permission level and then kick back an error. Privilege escalation &nbsp;&nbsp;&nbsp; Privilege escalation is right behind user account take over because they often use the same method - poor validation on a password reset. Another method is forceful browsing. Sometimes when logging in, the page will return a redirect to the standard user page and this can be modified to point to the admin page instead, allowing elevation of user privileges especially if functions within the admin panel do not do validation on user privilege level. Forceful browsing like this can in some cases take guessing to determine the correct admin page location unless you use a tool like Dirbuster to automate this. &nbsp;&nbsp;&nbsp; Developers should ensure that all requests are validated against the users permission level. Both of these scenarios, forced browsing and accessing other users information, also falls under broken access control. Sensitive information disclosure &nbsp;&nbsp;&nbsp; Web developers often overlook the advantage that these disclosures in error messages can give attackers. You can determine software versions, if something is a SQL back-end, what file types are allowed to be uploaded, and where in your exploitation the server stopped and kicked back an error to name a few.&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;In the above example, I&#39;ve now determined the framework version, the PHP version, and the MySQL version, as well as where errors are logged on the hosting server. This is all sensitive information as I can now look up attacks specific to these version numbers and it really simplifies the exploitation job.&nbsp; &nbsp;&nbsp; &nbsp;Returning errors like this is really handy in development, since it helps pinpoint exactly what is breaking, but in a production environment it gives away too much information. Instead, return generic error pages that only let users know something went wrong or the requested page is missing. Malicious file uploads &nbsp;&nbsp;&nbsp; If a site allows you to upload things like PHP or HTML, this can be leveraged by attackers to perform actions like listing /etc/passwd. &nbsp; &nbsp;&nbsp;&nbsp; This one is overall pretty simple. If you can upload files other than what was intended, that&#39;s an issue that needs fixing. Sometimes developers do put filters and only look for image files, but they only look for strings like jpeg in the file name. So if you upload file.jpeg.php, this will bypass their filter. &nbsp;&nbsp;&nbsp; Developers should use an allow list of extensions and avoid deny lists - the possible number of extension is far too much for any one person to keep track of. In addition to this, you should review that the allowed list of extensions only contains the bare minimum of file types needed for your application to function properly. You found a vulnerability, so what? &nbsp;&nbsp; &nbsp;Finding the vulnerability is not the end, your next responsibility is helping the client and developers fix the issues. Understanding what goes into fixing these issues is absolutely an important skill for quality pentesters to have. &nbsp;&nbsp; &nbsp;There&#39;s no shame in looking up the vulnerability on OWASP and finding a suggested solution there, but you should definitely understand why that solution works in the supplied example and be prepared for developer use cases to veer from the recommendations. Also be prepared for company priorities to shift and your finding to be downgraded. Just because OWASP says it&#39;s a high doesn&#39;t mean that your client or development team will feel the same way and ultimately it&#39;s their issue to deal with how they want.&nbsp; &nbsp;&nbsp;&nbsp; Take for example SQL injection. This is a common vulnerability to encounter and OWASP has a number of suggestions for protecting against it, so which should you pick? You have prepared statements, stored procedures, allow list input validation, and escaping all user supplied input. They each have pros and cons. For instance, escaping user supplied input assumes that you are actually catching all escape attempts. On the other hand, prepared statements are generally thought of as being able to stop SQL injection attempts against the parser, but it still leaves things like logging who writes what and user defined triggers vulnerable to SQL injection. Not to mention some people join supplied input strings to create prepared statements which defeats the purpose. There are a lot of ways that attempting to solve an issue can actually open you up to further damage, so understanding the environment and the solutions you will suggest is critical. Writing your report &nbsp;&nbsp;&nbsp; This can vary organization to organization, but typically this will include a high level discussion of the issues detected, their impact, and a total count of all the detected vulnerabilities followed by a table of each and supporting evidence. You should sort the detected vulnerabilities from high to low so that important issues catch the readers attention early and include clear steps for how to reproduce the detected issues to make developers lives easier. The faster the developers can see it in action, the faster they can determine where a fix needs to be placed and get it rolled out to staging.&nbsp;&nbsp;&nbsp; &nbsp;The high level discussion allows you to outline vulnerabilities that you thought were of note and discuss their potential impact if left unpatched. Getting across the right amount of urgency is crucial as too little will result in people leaving gaping holes while too much makes them treating future findings much more lightly then maybe they should. Think about the potential impact to client and customer data or reputational impact in order to judge how critical it is that something be patched in a week or in 90 days.&nbsp;&nbsp;&nbsp; Adding as much detail in the client facing report will reduce frustration on both ends as the developers can begin implementing fixes and the testers can focus on other work that needs to be done. Make sure you have your target audience in mind too when writing this, as going to technical will result in misunderstandings but leaving it too high level will have the report receivers scratching their heads figuring out the exact thing you meant. And that&#39;s it!&nbsp;&nbsp; This is what it takes at a basic level to be a competent pentester. Writing detailed reports and working with developers will be more than half your job. This is not a position where you can succeed by not working with others and especially be prepared to work with developers who are completely unfamiliar with working within a security context. Have sympathy as it&#39;s not their realm of expertise and they brought you in specifically to help them shore up this area. You can also learn a great deal from them on architecture and design philosophy." /><link rel="canonical" href="/posts/a-beginners-guide-to-webapp-pentesting/" /><meta property="og:url" content="/posts/a-beginners-guide-to-webapp-pentesting/" /><meta property="og:site_name" content="Culbert Report" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-27T02:18:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="A Beginners Guide To Everything WebApp Pentesting" /><meta name="twitter:site" content="@mattculbert" /><meta name="twitter:creator" content="@Matt C" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Matt C"},"dateModified":"2022-09-06T19:34:41+00:00","datePublished":"2022-07-27T02:18:00+00:00","description":"So you want to be a pentester &nbsp;&nbsp;&nbsp; There&#39;s a ton of different types of pentesting that you can do. What we&#39;ll talk about here though is website pentesting. This is the type of pentesting that will help developers secure websites that you and other people, potentially globally, will have access to so it&#39;s pretty important. But there are a lot of ways to remove any of the value that it can bring project owners. Some testers for instance will only use automated tools and don&#39;t understand the output that they generate and just hand over a report. This is unhelpful because as a pentester it&#39;s your duty to know why vulnerabilities appear on Burp and how to resolve them. Building off of that, as well as knowing the vulnerabilities, you should understand any solutions you offer and avoid canned suggestions. Today we will review the necessary prep work, what tools to use, common vulnerabilities to look for, and how to put it together in a report. This post is intended for people who are new to web app pentesting or those who want to know whats needed at a semi technical level in order to succeed. Also note, all demonstrations are either using culbertreport.com or a vulnerable version of OrangeHRM/LotusCMS. The paperwork &nbsp;&nbsp; &nbsp;Before you begin an actual pentest, there are some important items that you need to get out of the way. Of those, permission and scope will be the most important ones. Get a proper scope defined for what URLs are valid, what accounts can be targeted, and what must be explicitly avoided. In the same vein, make sure you have full permission from the web site owners to perform the pentest. Without these, you&#39;re treading on thin ice. &nbsp; &nbsp;&nbsp; &nbsp;The typical scope discussion and documentation will tell you that there are numerous URLs like subdir1.staging.culbertreport.com that are in scope, whether or not you&#39;re testing the staging environment (and you should really only test there) and whether or not it contains real data - you need to know whether or not the data you may see is potentially real PHI, for example, as there are other liabilities around this and BAA&#39;s that need to be signed. You also may or may not be given an account to use and you should also be given a point of contact who controls the webapp environment. This is to be used to relay findings but also in case you get locked out of the testing environment, something gets broken, or an attack accidentally leaks over to production and it needs to be remedied. Tools to use &nbsp;&nbsp;&nbsp; Now that you&#39;ve gotten the paper work out of the way, what tools do you use? Well there are a ton of tools, both paid and free, out there but really you will be fine with using 3/5 of the below for 99% of your engagements.&nbsp; Burp Suite &nbsp;&nbsp; &nbsp;Tried and true. This is in everyone&#39;s tool box because it has 99% of everything you will need in an engagement and, if it doesn&#39;t, there&#39;s either a plugin already made for it or you can write one for it.&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; For those unfamiliar with the tool, there&#39;s a LOT to take in with this screen. The majority of your work will be done in the proxy and the repeater tab. The proxy is where you will either direct your browsers traffic through or launch a custom Chromium instance and see all of the traffic you&#39;ve generated pass through, and the repeater allows you to send different requests repeatedly while changing whatever parameters you wish to in that request. Other tabs you may use include the sequencer, which will tell you whether or not there are issues with how cookies are generated, and the extender page where you can download extensions like I have for JSON Web Tokens. Burp Suite EnterpriseBurp Enterprise is fantastic for automating the more mundane portions of your engagements and for passively collecting vulnerability details as you work as well as running auditing scans. If your organization can afford an enterprise license, the tools that come with it will make the cost well worth it. Some highlights that are worth noting include the auditing scans to test for every exploit possible against every URL - though it&#39;s very important that this is only run against a staging environment that can be broken and you should not rely on this to find everything exploitable. Another highlight is that while you browse the site, Burp will passively note vulnerable components. For instance potentially there was a JS dependency that was missed by your manual investigation. OWASP Zap &nbsp;&nbsp; &nbsp;The lesser known cousin to Burp. It has much the same toolkit but in a slightly different UI. There&#39;s not much to say here, it&#39;s a cool tool and you can&#39;t go wrong using it.&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;If you&#39;re coming from Burp, this UI makes far less sense initially. But as you use it, it quickly becomes apparent where the features you&#39;ve come to expect with Burp hide under, and one bonus is that Zap will do passive enumeration of issues similar to how Burp Enterprise does.&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; As well as the passive enumeration, the request editor works much the same was as Burp Suites version, just a slightly different UI. &nbsp; SQLMap &nbsp;&nbsp; &nbsp;If you see SQL errors during an engagement, you can break out SQLMap to see if any of it is truly exploitable. I personally find SQLMap is best used with a valid request taken from Zap or Burp saved to a text file. This way you don&#39;t have to spend time messing with authorization parameters to reach the point you want to test. The tool will be demonstrated further below but your typical flow will look like this:&nbsp; sqlmap -r request.txt # SQLMap will figure out what position is exploitable in the request sqlmap -r request.txt --dbs&nbsp; # We then get the different databases sqlmap -r request.txt -D target_DB --tables # Get the tables from the target DBsqlmap -r request.txt -D target_DB -T target_table -dump # Then finally dump the contents of the table SSLscan&nbsp; &nbsp;&nbsp; &nbsp;This tool, for the most part, is covered by what&#39;s provided through Burp Enterprise. But if you don&#39;t have one of those licenses, this will be a nice compliment to your toolkit. SSLScan examines encrypted communications, such as HTTPS, and finds all the ciphers that are supported. This is the non flashy side of web app testing. Determining if weak ciphers are in use or if protocols that would be regulatory failings are in use is very important. Common vulnerabilities you&#39;ll test for &nbsp;&nbsp;&nbsp; Now that you&#39;ve got your tools selected and tested, you&#39;re going to start wanting to test the website. But what do you look for and why? Do you stick with the OWASP top 10? It&#39;s a respectable list but it&#39;s not nearly inclusive of everything you should look at. CSRF &nbsp;&nbsp; &nbsp;Cross-site request forgery. An easy one to test for and really important for testers to find attackable examples. This occurs when you are allowed to send requests with the referer field being set to another host. Typically, when you click a function in a site, a request is sent and the referer field tells the site where this is coming from. &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;But with CSRF, this field is not properly validated. For example, see the below request. &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;In the above picture, the referer is set to attacker.com. Why is this bad? Take for example a site that requires admins manually add new users to it. Through testing, you may be able to determine the fields that are expected to sign up a user with but you still don&#39;t have the required permissions to add yourself. If you can trick an admin level user into clicking a button on another site that fires off this POST though, and that admin has a currently valid session, all of a sudden you&#39;re signed up!&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;An important note, validating the referer field is not the only way to protect against CSRF. There are token based systems that will be more reliable, but these are more complex and simply validating the referer will get you 99.99% of the way there. XSS &nbsp;&nbsp; &nbsp;Cross-site scripting. Everyone&#39;s heard of it and everyone looks for it. What is it actually doing though and why is this dangerous?&nbsp; First, there&#39;s a few different types of XSS to test for.&nbsp; The most common one I&#39;ve seen is stored, which is where you enter something like a comment on a site and then any visitors afterwards will be affected.&nbsp;Followed by that is reflected, which is when you send someone a link like https://cr.culbertreport.com/search?q=&lt;script&gt;alert(1)&lt;/script&gt; and upon clicking this link they trigger the alert popup.&nbsp;And finally is DOM. This refers to the document object model and can be thought of similarly to reflected XSS, but they attack two different functions. This one will be by far the most complicated to attack. I really encourage anyone curious to read the OWASP entry as it explains it in the best way possible. This is the only XSS that can be executed in such a way that the server has no idea that the user fell victim to this as well. This is accomplished by using a # in the URI to fragment it and have the XSS be loaded client side by the DOM.&nbsp; &nbsp;&nbsp;&nbsp; What each of these are doing is modifying web pages to have attacker supplied elements due to improper sanitization of supplied input. This can then be leveraged by an attacker to do things like stealing session cookies from users. So with the stored XSS example, we can insert an element to get the document.cookie value from users who browse there and send it off to requestbin.net. This would then let you hijack their sessions and perform actions as those compromised users.&nbsp; &nbsp;&nbsp;&nbsp; The typical protections for this are to escape special characters and sanitize the user input. Escaping in this case means to invalidate potential HTML characters like &quot;&lt;&quot; through methods like encoding. Sanitizing would be to strip those special characters entirely from the supplied input. SQLi &nbsp;&nbsp;&nbsp; Another common one. This attack exploits sites that do not properly validate user supplied input before executing SQL queries with it. A common test to do this is to append a &#39; to the end of every input field and look for the 500 internal error response or a 200 OK that returns the SQL error. What you&#39;re doing with this test is starting a string and then not closing it, hence why the server responds with a SQL error. This can be leveraged either manually or automatically with SQLMap to then do things like dump database contents or pop a shell. &nbsp;&nbsp;&nbsp; There are a number of protections against SQL injection ranging from using prepared statements to what we did with XSS and try to escape the supplied input and treat it as a string. They each have pros and cons and it&#39;s important to remember that no solution is perfect.&nbsp; Directory traversal &nbsp;&nbsp;&nbsp; This occurs when attackers can access files outside of the web sites root directory. You typically see this with people putting a series of &#39;../&#39; into the URL hoping to escape as this gets interpreted by the web server sometimes as user input to move up a directory. &nbsp;&nbsp; &nbsp;Protecting against this is typically equally as simple as the attack itself. First, ensure that user input is valid and remove unexpected characters. Then second, when processing resource requests, append the requested path to the folders canonical path. This will ensure that any requests stay inside the websites root directory. User account takeover &nbsp;&nbsp;&nbsp; This is important to test for as it could allow another bigger issue, privilege escalation. This typically takes advantage of the password reset function. Often times, this function uses your cookie to identify who you are and whose password to reset. But sometimes the application passes a user ID to the back-end which can then be modified allowing the attacker to take over another users account.&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; This falls under broken access control - a user should only have access to their own resources and so any requests like this need to be validated against their permissions. If proper validation were in place, the back-end would see this request and see that the requested user ID to edit did not match the users ID or permission level and then kick back an error. Privilege escalation &nbsp;&nbsp;&nbsp; Privilege escalation is right behind user account take over because they often use the same method - poor validation on a password reset. Another method is forceful browsing. Sometimes when logging in, the page will return a redirect to the standard user page and this can be modified to point to the admin page instead, allowing elevation of user privileges especially if functions within the admin panel do not do validation on user privilege level. Forceful browsing like this can in some cases take guessing to determine the correct admin page location unless you use a tool like Dirbuster to automate this. &nbsp;&nbsp;&nbsp; Developers should ensure that all requests are validated against the users permission level. Both of these scenarios, forced browsing and accessing other users information, also falls under broken access control. Sensitive information disclosure &nbsp;&nbsp;&nbsp; Web developers often overlook the advantage that these disclosures in error messages can give attackers. You can determine software versions, if something is a SQL back-end, what file types are allowed to be uploaded, and where in your exploitation the server stopped and kicked back an error to name a few.&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;In the above example, I&#39;ve now determined the framework version, the PHP version, and the MySQL version, as well as where errors are logged on the hosting server. This is all sensitive information as I can now look up attacks specific to these version numbers and it really simplifies the exploitation job.&nbsp; &nbsp;&nbsp; &nbsp;Returning errors like this is really handy in development, since it helps pinpoint exactly what is breaking, but in a production environment it gives away too much information. Instead, return generic error pages that only let users know something went wrong or the requested page is missing. Malicious file uploads &nbsp;&nbsp;&nbsp; If a site allows you to upload things like PHP or HTML, this can be leveraged by attackers to perform actions like listing /etc/passwd. &nbsp; &nbsp;&nbsp;&nbsp; This one is overall pretty simple. If you can upload files other than what was intended, that&#39;s an issue that needs fixing. Sometimes developers do put filters and only look for image files, but they only look for strings like jpeg in the file name. So if you upload file.jpeg.php, this will bypass their filter. &nbsp;&nbsp;&nbsp; Developers should use an allow list of extensions and avoid deny lists - the possible number of extension is far too much for any one person to keep track of. In addition to this, you should review that the allowed list of extensions only contains the bare minimum of file types needed for your application to function properly. You found a vulnerability, so what? &nbsp;&nbsp; &nbsp;Finding the vulnerability is not the end, your next responsibility is helping the client and developers fix the issues. Understanding what goes into fixing these issues is absolutely an important skill for quality pentesters to have. &nbsp;&nbsp; &nbsp;There&#39;s no shame in looking up the vulnerability on OWASP and finding a suggested solution there, but you should definitely understand why that solution works in the supplied example and be prepared for developer use cases to veer from the recommendations. Also be prepared for company priorities to shift and your finding to be downgraded. Just because OWASP says it&#39;s a high doesn&#39;t mean that your client or development team will feel the same way and ultimately it&#39;s their issue to deal with how they want.&nbsp; &nbsp;&nbsp;&nbsp; Take for example SQL injection. This is a common vulnerability to encounter and OWASP has a number of suggestions for protecting against it, so which should you pick? You have prepared statements, stored procedures, allow list input validation, and escaping all user supplied input. They each have pros and cons. For instance, escaping user supplied input assumes that you are actually catching all escape attempts. On the other hand, prepared statements are generally thought of as being able to stop SQL injection attempts against the parser, but it still leaves things like logging who writes what and user defined triggers vulnerable to SQL injection. Not to mention some people join supplied input strings to create prepared statements which defeats the purpose. There are a lot of ways that attempting to solve an issue can actually open you up to further damage, so understanding the environment and the solutions you will suggest is critical. Writing your report &nbsp;&nbsp;&nbsp; This can vary organization to organization, but typically this will include a high level discussion of the issues detected, their impact, and a total count of all the detected vulnerabilities followed by a table of each and supporting evidence. You should sort the detected vulnerabilities from high to low so that important issues catch the readers attention early and include clear steps for how to reproduce the detected issues to make developers lives easier. The faster the developers can see it in action, the faster they can determine where a fix needs to be placed and get it rolled out to staging.&nbsp;&nbsp;&nbsp; &nbsp;The high level discussion allows you to outline vulnerabilities that you thought were of note and discuss their potential impact if left unpatched. Getting across the right amount of urgency is crucial as too little will result in people leaving gaping holes while too much makes them treating future findings much more lightly then maybe they should. Think about the potential impact to client and customer data or reputational impact in order to judge how critical it is that something be patched in a week or in 90 days.&nbsp;&nbsp;&nbsp; Adding as much detail in the client facing report will reduce frustration on both ends as the developers can begin implementing fixes and the testers can focus on other work that needs to be done. Make sure you have your target audience in mind too when writing this, as going to technical will result in misunderstandings but leaving it too high level will have the report receivers scratching their heads figuring out the exact thing you meant. And that&#39;s it!&nbsp;&nbsp; This is what it takes at a basic level to be a competent pentester. Writing detailed reports and working with developers will be more than half your job. This is not a position where you can succeed by not working with others and especially be prepared to work with developers who are completely unfamiliar with working within a security context. Have sympathy as it&#39;s not their realm of expertise and they brought you in specifically to help them shore up this area. You can also learn a great deal from them on architecture and design philosophy.","headline":"A Beginners Guide To Everything WebApp Pentesting","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/a-beginners-guide-to-webapp-pentesting/"},"url":"/posts/a-beginners-guide-to-webapp-pentesting/"}</script><title>A Beginners Guide To Everything WebApp Pentesting | Culbert Report</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Culbert Report"><meta name="application-name" content="Culbert Report"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/thumb.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Culbert Report</a></div><div class="site-subtitle font-italic">Get in loser, we're hating AI and bringing back real learning. Site art by Kenton Drumm</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/matt-culbert" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/mattculbert" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['matt','culbertreport.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>A Beginners Guide To Everything WebApp Pentesting</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>A Beginners Guide To Everything WebApp Pentesting</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1658888280" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 27, 2022 </em> </span> <span> Updated <em class="" data-ts="1662492881" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 6, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3140 words"> <em>17 min</em> read</span></div></div></div><div class="post-content"><h2 style="text-align: left;">So you want to be a pentester</h2><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>There's a ton of different types of pentesting that you can do. What we'll talk about here though is website pentesting. This is the type of pentesting that will help developers secure websites that you and other people, potentially globally, will have access to so it's pretty important. But there are a lot of ways to remove any of the value that it can bring project owners. Some testers for instance will only use automated tools and don't understand the output that they generate and just hand over a report. This is unhelpful because as a pentester it's your duty to know why vulnerabilities appear on Burp and how to resolve them. Building off of that, as well as knowing the vulnerabilities, you should understand any solutions you offer and avoid canned suggestions. Today we will review the necessary prep work, what tools to use, common vulnerabilities to look for, and how to put it together in a report. This post is intended for people who are new to web app pentesting or those who want to know whats needed at a semi technical level in order to succeed. Also note, all demonstrations are either using culbertreport.com or a vulnerable version of OrangeHRM/LotusCMS.<br /></p><h2 style="text-align: left;">The paperwork</h2><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Before you begin an actual pentest, there are some important items that you need to get out of the way. Of those, permission and scope will be the most important ones. Get a proper scope defined for what URLs are valid, what accounts can be targeted, and what must be explicitly avoided. In the same vein, make sure you have full permission from the web site owners to perform the pentest. Without these, you're treading on thin ice.</div><div class="separator" style="clear: both; text-align: center;">&nbsp; <br /><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi2n9CPv2DR-2scsd4yAsZWVqtLo5mWfOVpLaYWHFdUx6IT_AQNKkGc-WlQ816wGghQQhMIcl8246DPrXHCDwWK9OFiyuPRjALpEJbBvH1hGLaSGjiDGCchUfZ_aLlOsylcH_EElGZ5HdeFaXPh9are4YIetlSwALu1pk3U1AmYhB9k4vVX1WtX8JdS3g/s520/thinandcrispy.gif" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 513 289'%3E%3C/svg%3E" border="0" data-original-height="293" data-original-width="520" height="289" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi2n9CPv2DR-2scsd4yAsZWVqtLo5mWfOVpLaYWHFdUx6IT_AQNKkGc-WlQ816wGghQQhMIcl8246DPrXHCDwWK9OFiyuPRjALpEJbBvH1hGLaSGjiDGCchUfZ_aLlOsylcH_EElGZ5HdeFaXPh9are4YIetlSwALu1pk3U1AmYhB9k4vVX1WtX8JdS3g/w513-h289/thinandcrispy.gif" width="513" class="lazyload" data-proofer-ignore></a> <br /></div></div><p><span>&nbsp;&nbsp; &nbsp;</span>The typical scope discussion and documentation will tell you that there are numerous URLs like <span style="font-family: courier;">subdir1.staging.culbertreport.com </span>that are in scope, whether or not you're testing the staging environment (and you should really only test there) and whether or not it contains real data - you need to know whether or not the data you may see is potentially real PHI, for example, as there are other liabilities around this and BAA's that need to be signed. You also may or may not be given an account to use and you should also be given a point of contact who controls the webapp environment. This is to be used to relay findings but also in case you get locked out of the testing environment, something gets broken, or an attack accidentally leaks over to production and it needs to be remedied. <br /></p><h2 style="text-align: left;">Tools to use</h2><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Now that you've gotten the paper work out of the way, what tools do you use? Well there are a ton of tools, both paid and free, out there but really you will be fine with using 3/5 of the below for 99% of your engagements.&nbsp; <br /></div><h4 style="text-align: left;">Burp Suite</h4><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Tried and true. This is in everyone's tool box because it has 99% of everything you will need in an engagement and, if it doesn't, there's either a plugin already made for it or you can write one for it.&nbsp;</div><div style="text-align: left;">&nbsp;</div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhOd_yIVvQXk_Fl-BrJWYt3i81nUg2P7iLJOpaS7U_P68NfxizbLuBnq2u9z1dRStxV8G6ZNZDFlVCE-HF3YDQWjnnTj2Jyww_h6-_WCOBk_IYxeGBce4TQzA1u-9-Rsbr5UtKJm_T51347XAYNRhPAizcdoTOMaPs6PkvlMKBtmoNzKrDdra4lGrTFEQ/s1266/Burp%20dashboard.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 582 456'%3E%3C/svg%3E" border="0" data-original-height="993" data-original-width="1266" height="456" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhOd_yIVvQXk_Fl-BrJWYt3i81nUg2P7iLJOpaS7U_P68NfxizbLuBnq2u9z1dRStxV8G6ZNZDFlVCE-HF3YDQWjnnTj2Jyww_h6-_WCOBk_IYxeGBce4TQzA1u-9-Rsbr5UtKJm_T51347XAYNRhPAizcdoTOMaPs6PkvlMKBtmoNzKrDdra4lGrTFEQ/w582-h456/Burp%20dashboard.png" width="582" class="lazyload" data-proofer-ignore></a></div><span>&nbsp;&nbsp; &nbsp;</span>&nbsp;</div><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>For those unfamiliar with the tool, there's a LOT to take in with this screen. The majority of your work will be done in the proxy and the repeater tab. The proxy is where you will either direct your browsers traffic through or launch a custom Chromium instance and see all of the traffic you've generated pass through, and the repeater allows you to send different requests repeatedly while changing whatever parameters you wish to in that request. Other tabs you may use include the sequencer, which will tell you whether or not there are issues with how cookies are generated, and the extender page where you can download extensions like I have for JSON Web Tokens.<br /></div><div style="text-align: left;"><ul style="text-align: left;"><li><h4 style="text-align: left;">Burp Suite Enterprise</h4><div style="margin-left: 40px; text-align: left;">Burp Enterprise is fantastic for automating the more mundane portions of your engagements and for passively collecting vulnerability details as you work as well as running auditing scans. If your organization can afford an enterprise license, the tools that come with it will make the cost well worth it. Some highlights that are worth noting include the auditing scans to test for every exploit possible against every URL - though it's very important that this is only run against a staging environment that can be broken and you should not rely on this to find everything exploitable. Another highlight is that while you browse the site, Burp will passively note vulnerable components. For instance potentially there was a JS dependency that was missed by your manual investigation.<br /></div></ul></div><h4 style="text-align: left;">OWASP Zap</h4><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>The lesser known cousin to Burp. It has much the same toolkit but in a slightly different UI. There's not much to say here, it's a cool tool and you can't go wrong using it.&nbsp;</div><div style="text-align: left;">&nbsp;</div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiW9on4HChmiz1jOZHAYIeDRfbr0orignZJ7mqYrVSR5LXqGnpnWJ258W0eGRGmSCD4ZI2DmudqNSVCksu9DsOBUfR3tDO_w_y1_9njhOEJmaBmz4llAGbowgJjo3vWJYsslimiMDNayiPuhQBRA1tjAumUZgWsk1rEbOH0b5JM-6yT3m36mi79PI_VGg/s1143/ZAP%20dashboard.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 568 389'%3E%3C/svg%3E" border="0" data-original-height="781" data-original-width="1143" height="389" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiW9on4HChmiz1jOZHAYIeDRfbr0orignZJ7mqYrVSR5LXqGnpnWJ258W0eGRGmSCD4ZI2DmudqNSVCksu9DsOBUfR3tDO_w_y1_9njhOEJmaBmz4llAGbowgJjo3vWJYsslimiMDNayiPuhQBRA1tjAumUZgWsk1rEbOH0b5JM-6yT3m36mi79PI_VGg/w568-h389/ZAP%20dashboard.png" width="568" class="lazyload" data-proofer-ignore></a></div><span>&nbsp;&nbsp; &nbsp;</span>&nbsp;</div><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>If you're coming from Burp, this UI makes far less sense initially. But as you use it, it quickly becomes apparent where the features you've come to expect with Burp hide under, and one bonus is that Zap will do passive enumeration of issues similar to how Burp Enterprise does.&nbsp;</div><div style="text-align: left;">&nbsp;</div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjcdTkvGztms3c72z8WUuNVqPFEc4g5UUmY4EpSXp7dWzijG6vxWsIxQxZQuBwc_moMrSGTCQBToZ-XqCVoFfqaZSd3ss-xkGX9BAB0HfYb0KOjZWYY8VlWL54chkv_w8xf2dSELd9ya7C74B0ZQe-9m2ZEvD3qt9yTc-6Ta3Kp7_FSxL0UzNANFmgx4w/s1599/zap%20vulns.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 565 411'%3E%3C/svg%3E" border="0" data-original-height="1161" data-original-width="1599" height="411" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjcdTkvGztms3c72z8WUuNVqPFEc4g5UUmY4EpSXp7dWzijG6vxWsIxQxZQuBwc_moMrSGTCQBToZ-XqCVoFfqaZSd3ss-xkGX9BAB0HfYb0KOjZWYY8VlWL54chkv_w8xf2dSELd9ya7C74B0ZQe-9m2ZEvD3qt9yTc-6Ta3Kp7_FSxL0UzNANFmgx4w/w565-h411/zap%20vulns.png" width="565" class="lazyload" data-proofer-ignore></a></div><br /></div><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; As well as the passive enumeration, t</span>he request editor works much the same was as Burp Suites version, just a slightly different UI.</div><div style="text-align: left;">&nbsp;</div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhp-4luaD4TpFUua1rLP3isca5R8dzbznfDYRhkX-Vk-Q5Z_qUyU3MWqxRLYtNhrXpvcTOINYJq01BFAPLznD7Rzy0bG61Zt9f2vi3rQ2J0ZNjax6Y4vzd8xZMfQsJYJyz3rjR3_4CRK2A8w8YU8uGB_u-6anEStOwBPRiUPvjeNs43MR3DfY-g5hUF0A/s786/request%20editor%202.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 574 432'%3E%3C/svg%3E" border="0" data-original-height="593" data-original-width="786" height="432" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhp-4luaD4TpFUua1rLP3isca5R8dzbznfDYRhkX-Vk-Q5Z_qUyU3MWqxRLYtNhrXpvcTOINYJq01BFAPLznD7Rzy0bG61Zt9f2vi3rQ2J0ZNjax6Y4vzd8xZMfQsJYJyz3rjR3_4CRK2A8w8YU8uGB_u-6anEStOwBPRiUPvjeNs43MR3DfY-g5hUF0A/w574-h432/request%20editor%202.png" width="574" class="lazyload" data-proofer-ignore></a></div><h4 style="text-align: left;">SQLMap</h4><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>If you see SQL errors during an engagement, you can break out SQLMap to see if any of it is truly exploitable. I personally find SQLMap is best used with a valid request taken from Zap or Burp saved to a text file. This way you don't have to spend time messing with authorization parameters to reach the point you want to test. The tool will be demonstrated further below but your typical flow will look like this:&nbsp;</div><ol style="text-align: left;"><li><span style="font-family: courier;">sqlmap -r request.txt</span> # SQLMap will figure out what position is exploitable in the request<li><span style="font-family: courier;">sqlmap -r request.txt --dbs</span>&nbsp; # We then get the different databases<li><span style="font-family: courier;">sqlmap -r request.txt -D target_DB --tables</span> # Get the tables from the target DB<li><span style="font-family: courier;">sqlmap -r request.txt -D target_DB -T target_table -dump</span> # Then finally dump the contents of the table</ol><h4 style="text-align: left;">SSLscan&nbsp;</h4><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>This tool, for the most part, is covered by what's provided through Burp Enterprise. But if you don't have one of those licenses, this will be a nice compliment to your toolkit. SSLScan examines encrypted communications, such as HTTPS, and finds all the ciphers that are supported. This is the non flashy side of web app testing. Determining if weak ciphers are in use or if protocols that would be regulatory failings are in use is very important. <br /></p><h2 style="text-align: left;">Common vulnerabilities you'll test for</h2><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Now that you've got your tools selected and tested, you're going to start wanting to test the website. But what do you look for and why? Do you stick with the OWASP top 10? It's a respectable list but it's not nearly inclusive of everything you should look at. <br /></div><h4 style="text-align: left;">CSRF</h4><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Cross-site request forgery. An easy one to test for and really important for testers to find attackable examples. This occurs when you are allowed to send requests with the referer field being set to another host. Typically, when you click a function in a site, a request is sent and <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer" rel="nofollow" target="_blank">the referer field tells the site where this is coming from. </a><br /></div><div style="text-align: left;">&nbsp;</div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjcA19F50pJauA-BZK1jgJbY1pnSrFzcd4P6E7GRv3SIylzyJe5YpycgKSu4el9-tw700Rpvgyv8RaXPnwFDtl58PraaVHVTNZdxB1jGf-RHZpBfc-YsPHjsRJ3E9jSDQG-yNaJM4L4xA0942jfByjMyjsRt_-ZKsKVA8S8Zcw5b2kc3cd2awg-PKd81A/s899/normal%20web%20request.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 562 188'%3E%3C/svg%3E" border="0" data-original-height="301" data-original-width="899" height="188" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjcA19F50pJauA-BZK1jgJbY1pnSrFzcd4P6E7GRv3SIylzyJe5YpycgKSu4el9-tw700Rpvgyv8RaXPnwFDtl58PraaVHVTNZdxB1jGf-RHZpBfc-YsPHjsRJ3E9jSDQG-yNaJM4L4xA0942jfByjMyjsRt_-ZKsKVA8S8Zcw5b2kc3cd2awg-PKd81A/w562-h188/normal%20web%20request.png" width="562" class="lazyload" data-proofer-ignore></a></div>&nbsp;</div><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>But with CSRF, this field is not properly validated. For example, see the below request.</div><div style="text-align: left;">&nbsp;</div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhg0F1nSB_MIToD0QSc54HTIP7Lp0fbWPYCKtakxywKyf0ntHgiPpGSSBbMMB4zf10-AwybxX1YSM9wpfHX75-0ikjybQp216xFYthwE2rU98Y_IrmjhBOSSxyYPPKvj9LGVrRg69VWorgmchRuYmgrSLZ_GSq3u6Y3ysOqrIcBYojUPjSgnAdmBAcQ7w/s969/csrf.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 611 193'%3E%3C/svg%3E" border="0" data-original-height="306" data-original-width="969" height="193" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhg0F1nSB_MIToD0QSc54HTIP7Lp0fbWPYCKtakxywKyf0ntHgiPpGSSBbMMB4zf10-AwybxX1YSM9wpfHX75-0ikjybQp216xFYthwE2rU98Y_IrmjhBOSSxyYPPKvj9LGVrRg69VWorgmchRuYmgrSLZ_GSq3u6Y3ysOqrIcBYojUPjSgnAdmBAcQ7w/w611-h193/csrf.png" width="611" class="lazyload" data-proofer-ignore></a></div></div><div style="text-align: left;"></div><div style="text-align: left;"></div><div style="text-align: left;"></div><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>&nbsp;</div><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>In the above picture, the referer is set to attacker.com. Why is this bad? Take for example a site that requires admins manually add new users to it. Through testing, you may be able to determine the fields that are expected to sign up a user with but you still don't have the required permissions to add yourself. If you can trick an admin level user into clicking a button on another site that fires off this POST though, and that admin has a currently valid session, all of a sudden you're signed up!&nbsp;</div><div style="text-align: left;">&nbsp;</div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqSxlqKvnvMMY4Hivf2tWwSCkg7587bpCVRSehBAPFrnLnEmH7oImAakmzLu7D-tqtYbHdDy169PVDmwJE9XdijSjfCAQV1OGZdj_fKw5bDtA9Y0BfFVoVxPcerRsFxgwefsCS3I59kpc-bh6aJX81jL9tyzM6NxiUPgtV0GXYI33E5EMDY1cDDPYD-Q/s331/csrf%20example.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 462 384'%3E%3C/svg%3E" border="0" data-original-height="275" data-original-width="331" height="384" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqSxlqKvnvMMY4Hivf2tWwSCkg7587bpCVRSehBAPFrnLnEmH7oImAakmzLu7D-tqtYbHdDy169PVDmwJE9XdijSjfCAQV1OGZdj_fKw5bDtA9Y0BfFVoVxPcerRsFxgwefsCS3I59kpc-bh6aJX81jL9tyzM6NxiUPgtV0GXYI33E5EMDY1cDDPYD-Q/w462-h384/csrf%20example.png" width="462" class="lazyload" data-proofer-ignore></a></div></div><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span></div><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>An important note, validating the referer field is not the only way to protect against CSRF. There are token based systems that will be more reliable, but these are more complex and simply validating the referer will get you 99.99% of the way there.<br /></div><h4 style="text-align: left;">XSS</h4><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Cross-site scripting. Everyone's heard of it and everyone looks for it. What is it actually doing though and why is this dangerous?&nbsp; First, there's a few different types of XSS to test for.&nbsp; <br /></div><div style="text-align: left;"><ol style="text-align: left;"><li>The most common one I've seen is stored, which is where you enter something like a comment on a site and then any visitors afterwards will be affected.&nbsp;<li>Followed by that is reflected, which is when you send someone a link like https://cr.culbertreport.com/search?q=&lt;script&gt;alert(1)&lt;/script&gt; and upon clicking this link they trigger the alert popup.&nbsp;<li>And finally is DOM. This refers to the document object model and can be thought of similarly to reflected XSS, but they attack two different functions. This one will be by far the most complicated to attack. I really encourage anyone curious to <a href="https://owasp.org/www-community/attacks/DOM_Based_XSS" rel="nofollow" target="_blank">read the OWASP entry as it explains it in the best way possible</a>. This is the only XSS that can be executed in such a way that the server has no idea that the user fell victim to this as well. This is accomplished by using a # in the URI to fragment it and have the XSS be loaded client side by the DOM.&nbsp; <br /></ol><span>&nbsp;&nbsp;&nbsp; </span>What each of these are doing is modifying web pages to have attacker supplied elements due to improper sanitization of supplied input. This can then be leveraged by an attacker to do things like stealing session cookies from users. So with the stored XSS example, we can insert an element to get the document.cookie value from users who browse there and send it off to requestbin.net. This would then let you hijack their sessions and perform actions as those compromised users.&nbsp;</div><div style="text-align: left;"><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>The typical protections for this are to escape special characters and sanitize the user input. Escaping in this case means to invalidate potential HTML characters like "&lt;" through methods like encoding. Sanitizing would be to strip those special characters entirely from the supplied input. <br /></p></div><h4 style="text-align: left;">SQLi</h4><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Another common one. This attack exploits sites that do not properly validate user supplied input before executing SQL queries with it. A common test to do this is to append a ' to the end of every input field and look for the 500 internal error response or a 200 OK that returns the SQL error. What you're doing with this test is starting a string and then not closing it, hence why the server responds with a SQL error. This can be leveraged either manually or automatically with SQLMap to then do things like dump database contents or pop a shell.<br /></div><div style="text-align: left;"><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhiBAO6UZ8zHNuGf6meqfTURJ33V4_vzHjplxaDpu2D50etcU7NcLs-aQ4Kz8Wmdoe9B6uhHWktKfPlaFSmdSxMgDY93OUOrUVQTagBHpFqd0zvbcAjAFU59QODG-TAZDOull6JMFyIM-W7XAzkNGs66c1mvREQD74nkG0RlZbMzzQIzb67CibR7-CvCg/s1900/sqlmap.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 571 291'%3E%3C/svg%3E" border="0" data-original-height="967" data-original-width="1900" height="291" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhiBAO6UZ8zHNuGf6meqfTURJ33V4_vzHjplxaDpu2D50etcU7NcLs-aQ4Kz8Wmdoe9B6uhHWktKfPlaFSmdSxMgDY93OUOrUVQTagBHpFqd0zvbcAjAFU59QODG-TAZDOull6JMFyIM-W7XAzkNGs66c1mvREQD74nkG0RlZbMzzQIzb67CibR7-CvCg/w571-h291/sqlmap.png" width="571" class="lazyload" data-proofer-ignore></a></div></div><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>There are a number of protections against SQL injection ranging from using prepared statements to what we did with XSS and try to escape the supplied input and treat it as a string. They each have pros and cons and it's important to remember that no solution is perfect.&nbsp; <br /></p><h4 style="text-align: left;">Directory traversal</h4><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>This occurs when attackers can access files outside of the web sites root directory. You typically see this with people putting a series of '../' into the URL hoping to escape as this gets interpreted by the web server sometimes as user input to move up a directory.</div><div style="text-align: left;"><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;Protecting against this is typically equally as simple as the attack itself. First, ensure that user input is valid and remove unexpected characters. Then second, when processing resource requests, append the requested path to the folders canonical path. This will ensure that any requests stay inside the websites root directory.<br /></span></p></div><h4 style="text-align: left;">User account takeover</h4><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>This is important to test for as it could allow another bigger issue, privilege escalation. This typically takes advantage of the password reset function. Often times, this function uses your cookie to identify who you are and whose password to reset. But sometimes the application passes a user ID to the back-end which can then be modified allowing the attacker to take over another users account.&nbsp;</div><div style="text-align: left;">&nbsp;</div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgiVPhQ4EqnQtJAXNfdojazQQWHJ5y65L0RYYdQdiF4fWRj9u4ZilLhss-w3V8CjiWQgNH1PVK_fqrxL_xyy-ErfAGYlIkaRySeCzPS1XaZzyqEY6796IzpPl2kF_Z_0mMNlV7KD6zJWaILMlv2CppNL7lpePA8FPVK9zOLPGXsg-CJ8elsTcPULvgpUA/s623/password%20reset.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 550 275'%3E%3C/svg%3E" border="0" data-original-height="312" data-original-width="623" height="275" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgiVPhQ4EqnQtJAXNfdojazQQWHJ5y65L0RYYdQdiF4fWRj9u4ZilLhss-w3V8CjiWQgNH1PVK_fqrxL_xyy-ErfAGYlIkaRySeCzPS1XaZzyqEY6796IzpPl2kF_Z_0mMNlV7KD6zJWaILMlv2CppNL7lpePA8FPVK9zOLPGXsg-CJ8elsTcPULvgpUA/w550-h275/password%20reset.png" width="550" class="lazyload" data-proofer-ignore></a></div></div><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>This falls under broken access control - a user should only have access to their own resources and so any requests like this need to be validated against their permissions. If proper validation were in place, the back-end would see this request and see that the requested user ID to edit did not match the users ID or permission level and then kick back an error. <br /></p><h4 style="text-align: left;">Privilege escalation</h4><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Privilege escalation is right behind user account take over because they often use the same method - poor validation on a password reset. Another method is forceful browsing. Sometimes when logging in, the page will return a redirect to the standard user page and this can be modified to point to the admin page instead, allowing elevation of user privileges especially if functions within the admin panel do not do validation on user privilege level. Forceful browsing like this can in some cases take guessing to determine the correct admin page location unless you use a tool like Dirbuster to automate this.</div><div style="text-align: left;"><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Developers should ensure that all requests are validated against the users permission level. Both of these scenarios, forced browsing and accessing other users information, also falls under broken access control.<br /></p></div><h4 style="text-align: left;">Sensitive information disclosure</h4><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Web developers often overlook the advantage that these disclosures in error messages can give attackers. You can determine software versions, if something is a SQL back-end, what file types are allowed to be uploaded, and where in your exploitation the server stopped and kicked back an error to name a few.&nbsp;&nbsp;</div><div style="text-align: left;">&nbsp;</div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiTuGnRuu7REGPKR0yFNS-qUMEIrkETcaHVEOMZQnt6iFmPEDi7rCD9p5swYETnWRfhiWFiTh2W8RYxxTTewwsikzO1hbp-JxLLu1S7koIk8ERUpLHPioyux-Bawiolc4WNivS8DiANPGyibdJ-N5yo-vrOQt5jmAuHJUYPiQ4jnNOyUdb3fuAuJINO8A/s625/verbose%20errors.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 503 307'%3E%3C/svg%3E" border="0" data-original-height="380" data-original-width="625" height="307" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiTuGnRuu7REGPKR0yFNS-qUMEIrkETcaHVEOMZQnt6iFmPEDi7rCD9p5swYETnWRfhiWFiTh2W8RYxxTTewwsikzO1hbp-JxLLu1S7koIk8ERUpLHPioyux-Bawiolc4WNivS8DiANPGyibdJ-N5yo-vrOQt5jmAuHJUYPiQ4jnNOyUdb3fuAuJINO8A/w503-h307/verbose%20errors.png" width="503" class="lazyload" data-proofer-ignore></a></div></div><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></div><div style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>In the above example, I've now determined the framework version, the PHP version, and the MySQL version, as well as where errors are logged on the hosting server. This is all sensitive information as I can now look up attacks specific to these version numbers and it really simplifies the exploitation job.&nbsp;</div><div style="text-align: left;"><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;Returning errors like this is really handy in development, since it helps pinpoint exactly what is breaking, but in a production environment it gives away too much information. Instead, return generic error pages that only let users know something went wrong or the requested page is missing. <br /></span></p></div><h4 style="text-align: left;">Malicious file uploads</h4><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>If a site allows you to upload things like PHP or HTML, this can be leveraged by attackers to perform actions like listing /etc/passwd.<br /></div><div style="text-align: left;">&nbsp;</div><div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhiw0XXcrRFT5EJosxyCMcduo-wcRsbsgVm-TG5coKJ5fw-RfT5v3yJ9zHSLYBGLB_FNUse-VOa3BIcTv3BDyb5FpP90f_dAVxHBhOO0xmOH6blGITJH49XXEHYGJ8m5xFqi3yscniatXOTEchWzXfm6cejwnmwZJIZa1aU3RPqxMBecJMDQxzqsJ1JBg/s628/malicious%20file%20upload.png" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 595 212'%3E%3C/svg%3E" border="0" data-original-height="224" data-original-width="628" height="212" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhiw0XXcrRFT5EJosxyCMcduo-wcRsbsgVm-TG5coKJ5fw-RfT5v3yJ9zHSLYBGLB_FNUse-VOa3BIcTv3BDyb5FpP90f_dAVxHBhOO0xmOH6blGITJH49XXEHYGJ8m5xFqi3yscniatXOTEchWzXfm6cejwnmwZJIZa1aU3RPqxMBecJMDQxzqsJ1JBg/w595-h212/malicious%20file%20upload.png" width="595" class="lazyload" data-proofer-ignore></a></div></div><div style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>This one is overall pretty simple. If you can upload files other than what was intended, that's an issue that needs fixing. Sometimes developers do put filters and only look for image files, but they only look for strings like jpeg in the file name. So if you upload <span style="font-family: courier;">file.jpeg.php</span>, this will bypass their filter.</div><div style="text-align: left;"><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Developers should use an allow list of extensions and avoid deny lists - the possible number of extension is far too much for any one person to keep track of. In addition to this, you should review that the allowed list of extensions only contains the bare minimum of file types needed for your application to function properly.<br /></p></div><h2 style="text-align: left;">You found a vulnerability, so what?</h2><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>Finding the vulnerability is not the end, your next responsibility is helping the client and developers fix the issues. Understanding what goes into fixing these issues is absolutely an important skill for quality pentesters to have. <br /></p><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhM4F7oBHIkuQiKLQuFC196luBn0j7zZDh4fHJKLzI0J0JOnzpiy717Y82MCTKzuqKOBsTBmU7ySDM7hux2-7hg_IiR6UDvquia5x25MBE08GrFdRGVCztLwJa5cXwT_hCFfw7mm_8wmyEZzZAQryaBEMsZ2dD5ZTg9c_TnPMbg1DC02uMtNslfzHc60g/s520/okhowdoifix.jpg" style="margin-left: 1em; margin-right: 1em;" class="img-link shimmer" ><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 439 423'%3E%3C/svg%3E" border="0" data-original-height="500" data-original-width="520" height="423" data-src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhM4F7oBHIkuQiKLQuFC196luBn0j7zZDh4fHJKLzI0J0JOnzpiy717Y82MCTKzuqKOBsTBmU7ySDM7hux2-7hg_IiR6UDvquia5x25MBE08GrFdRGVCztLwJa5cXwT_hCFfw7mm_8wmyEZzZAQryaBEMsZ2dD5ZTg9c_TnPMbg1DC02uMtNslfzHc60g/w439-h423/okhowdoifix.jpg" width="439" class="lazyload" data-proofer-ignore></a></div><p><span>&nbsp;&nbsp; &nbsp;</span>There's no shame in looking up the vulnerability on OWASP and finding a suggested solution there, but you should definitely understand why that solution works in the supplied example and be prepared for developer use cases to veer from the recommendations. Also be prepared for company priorities to shift and your finding to be downgraded. Just because OWASP says it's a high doesn't mean that your client or development team will feel the same way and ultimately it's their issue to deal with how they want.&nbsp;</p><p><span>&nbsp;&nbsp;&nbsp; </span>Take for example SQL injection. This is a common vulnerability to encounter and OWASP has a number of suggestions for protecting against it, so which should you pick? You have prepared statements, stored procedures, allow list input validation, and escaping all user supplied input. They each have pros and cons. For instance, escaping user supplied input assumes that you are actually catching all escape attempts. On the other hand, prepared statements are generally thought of as being able to stop SQL injection attempts against the parser, but it still leaves things like logging who writes what and user defined triggers vulnerable to SQL injection. Not to mention some people join supplied input strings to create prepared statements which defeats the purpose. There are a lot of ways that attempting to solve an issue can actually open you up to further damage, so understanding the environment and the solutions you will suggest is critical.<br /></p><h2 style="text-align: left;">Writing your report</h2><div style="text-align: left;"><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>This can vary organization to organization, but typically this will include a high level discussion of the issues detected, their impact, and a total count of all the detected vulnerabilities followed by a table of each and supporting evidence. You should sort the detected vulnerabilities from high to low so that important issues catch the readers attention early and include clear steps for how to reproduce the detected issues to make developers lives easier. The faster the developers can see it in action, the faster they can determine where a fix needs to be placed and get it rolled out to staging.&nbsp;</p><p style="text-align: left;"><span>&nbsp;&nbsp; &nbsp;</span>The high level discussion allows you to outline vulnerabilities that you thought were of note and discuss their potential impact if left unpatched. Getting across the right amount of urgency is crucial as too little will result in people leaving gaping holes while too much makes them treating future findings much more lightly then maybe they should. Think about the potential impact to client and customer data or reputational impact in order to judge how critical it is that something be patched in a week or in 90 days.<br /></p><p style="text-align: left;"><span>&nbsp;&nbsp;&nbsp; </span>Adding as much detail in the client facing report will reduce frustration on both ends as the developers can begin implementing fixes and the testers can focus on other work that needs to be done. Make sure you have your target audience in mind too when writing this, as going to technical will result in misunderstandings but leaving it too high level will have the report receivers scratching their heads figuring out the exact thing you meant. <br /></p></div><div style="text-align: left;"><h2 style="text-align: left;">And that's it!</h2><div style="text-align: left;"><span>&nbsp;&nbsp; This is what it takes at a basic level to be a competent pentester. Writing detailed reports and working with developers will be more than half your job. This is not a position where you can succeed by not working with others and especially be prepared to work with developers who are completely unfamiliar with working within a security context. Have sympathy as it's not their realm of expertise and they brought you in specifically to help them shore up this area. You can also learn a great deal from them on architecture and design philosophy.<br /></span></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=A%20Beginners%20Guide%20To%20Everything%20WebApp%20Pentesting%20-%20Culbert%20Report&url=%2Fposts%2Fa-beginners-guide-to-webapp-pentesting%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=A%20Beginners%20Guide%20To%20Everything%20WebApp%20Pentesting%20-%20Culbert%20Report&u=%2Fposts%2Fa-beginners-guide-to-webapp-pentesting%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fa-beginners-guide-to-webapp-pentesting%2F&text=A%20Beginners%20Guide%20To%20Everything%20WebApp%20Pentesting%20-%20Culbert%20Report" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Making-Red-Teaming-Safer/">Making Red Teaming Safer</a><li><a href="/posts/Human-Learning-Is-Irreplaceable/">Human Learning Is Irreplaceable</a><li><a href="/posts/Building-A-Detection-Lab-Around-Suricata/">Building A Detection Lab Around Suricata</a><li><a href="/posts/The-evolution-of-evasion/">The Evolution Of Evasion</a><li><a href="/posts/C2-Smackdown-Empire-vs-Mythic/">C2 Smackdown Empire Vs Mythic</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/We-have-lost-the-plot-with-LLMs/"><div class="card-body"> <em class="small" data-ts="1771804800" data-df="ll" > Feb 23, 2026 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>We Have Lost The Plot With Llms</h3><div class="text-muted small"><p> Weve collectively lost the plot In IT and security we say that users are the weakest link, but this is no longer true; now, the weakest link is whatever LLM your company is using to act as both a ...</p></div></div></a></div><div class="card"> <a href="/posts/Language-models-cannot-make-art/"><div class="card-body"> <em class="small" data-ts="1770249600" data-df="ll" > Feb 5, 2026 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Language Models Cannot Make Art</h3><div class="text-muted small"><p> I was in a random coffee shop a few months back and I noticed that they had little coffee table books for sale. One that caught my eye was a Japanese color combination dictionary, originally prin...</p></div></div></a></div><div class="card"> <a href="/posts/Human-Learning-Is-Irreplaceable/"><div class="card-body"> <em class="small" data-ts="1759881600" data-df="ll" > Oct 8, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Human Learning Is Irreplaceable</h3><div class="text-muted small"><p> What we call AI is really just a cancer attacking our ability to learn and we have very little time remaining to carve it out. A note When I began writing this, it was June in Vermont and one ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/covenant-in-2022/" class="btn btn-outline-primary" prompt="Older"><p>Covenant In 2022</p></a> <a href="/posts/setting-up-phishing-platform-with/" class="btn btn-outline-primary" prompt="Newer"><p>Setting Up A Phishing Platform With GoPhish</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0">  2026 <a href="https://twitter.com/">Matt Culbert</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
