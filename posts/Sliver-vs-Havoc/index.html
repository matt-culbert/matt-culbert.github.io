<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Sliver vs Havoc" /><meta property="og:locale" content="en" /><meta name="description" content="Sliver vs Havoc - Two Adversary Emulation Frameworks I wanted to objectively measure two well known frameworks against one another and see which fits certain needs best. To this end, each platform has been measured by if you can expand on them, how easy they are to get using, and why you might want one over the other. Before going further, for those unfamiliar, both Sliver and Havoc are command and control frameworks that are free to use on GitHub. Sliver is developed by BishopFox and is a reasonably old project that first started in 2019. It’s seen some major upgrades since then, with the most recent being in October 2022. Havoc is a much newer tool developed by three independent contributors that was first started in September 2022. Both teams are responsive to questions and issues and, since they’re open source, you are free to expand on them as you need. With that said, the first question that should be answered is how easy is it to spin one of these up? How easy is it to spin one up and get going vs the other? Havoc Havoc utilizes team profiles at launch to dictate implant functionality The documentation is fairly well laid out, but online only. You should have prior knowledge with C++ and implementing bypass techniques because out of the box the implants are detected quickly. Havoc is very neat. Much like Cobaltstrike, you can start the teamserver by passing it a json profile of users and their passwords as well as some general functionality things like sleep time and jitter of your implants. An opsec concern right off the bat for teams may be that the passwords in this file not encrypted, so setting proper read permissions of it and the directory is very important. Once the server is started, the dashboard is very intuitively laid out if you’ve ever used Cobaltstrike. Starting a listener is easy as well. Hitting view -&gt; listeners allows us to add a new one. From here, you just step through the simple option menu and configure a few things like the port, if we’ll be using hostnames, and the header to use, and you’re set. And the payload options, while slim, have enough to them that we can make the necessary modifications to let them slip by the EDR we anticipate meeting. We can output in four file formats. These are exe, dll, shellcode, or service exe. The default implant of an EXE gets detected very quickly, so we’ll be testing the shellcode option here and implant it through the resource section of another EXE we develop ourselves. Next, we have to select the memory allocation and execution methods. For those, our options are syscalls or Win32. My understanding is that this means either performing a VirtualAlloc or NtAllocateVirtualMemory in the case of allocation, and for execution it would be NtCreateThreadEx or CreateRemoteThread. NtAllocateVirtualMemory is typically called through VirtualAlloc since it is an undocumented function. As we briefly touched on in the NTDLL article in September 2022, these undocumented functions can change on a dime but are very useful for bypassing detection methods that focus solely on break points in NTDLL when called. Their downside is that seeing syscalls like this is quite unusual and alarming, so EDR watching for this could alert very quickly. VirtualAlloc on the other hand is the lowest level call from user space that we can perform and hooks into Ring0 using syscalls to allocate memory within the bounds of what’s known as the system granularity boundary. For most Windows systems, this will be 64kb. Allocations also must be a multiple of this boundary, so for example a 3 byte allocation would cause errors. Moving to the execution methods, NtCreateThreadEx is the undocumented, lower level, version of CreateRemoteThread. Like NtAllocateVirtualMemory, it is contingent on syscalls being up to date and suffers from the same pitfalls. CreateRemoteThread is much safer but also easier to detect. Finding a balance between the two options is important when generating your implant. Different EDR might be tuned to detect one method more over the other. After taking all this into account and developing our executable for the shellcode, we can see that the detection levels has dropped from 26 to 16. That’s not ideal, but if your target platform is Microsoft, you’ve made it past stage 1 with only a few changes. While using Havoc, it felt like their target audience was professionals who are experienced with other C2 platforms and want something that they can build off of on their own. It’s hard to get leadership buy in on a project that is only maintaned by three people and doesn’t have a company backing it like BishopFox, so it’s hard to say how likely you are to encounter it in an enterprise. For those who really enjoy working in a GUI though, this will definitely scratch that itch. Sliver Let’s now shift a little and check out Sliver. Sliver is completely terminal based meaning if you need a GUI to be able to visualize things, this won’t work for you. The documentation is expansive and intimidating, which is great, and you can type help for any function. Sliver also lets you set expiration dates for beacons, so they stop working after a set time. Sliver gives you everything and expects you know what to do with it. If you don’t know what to do with it, there’s a help dialogue for each option, but aside from that you are left to figure it out. Just check out the options for compiling an implant. If you don’t know why you might want to disable the Shikata-Ga-Nai shellcode encoder, you’re offered no explanation. There are numerous guides available online for Sliver, which lowers the learning curve significantly and if you would like to get started, these are almost mandatory readings. Some can be found here. The linked reading does a deep dive into Slivers code and finds some interesting shortcuts taken by the developers. For example, generating stagers under the hood is handled through MSFVenom and, while you can specify a DNS name, only hardcoded IPs are passed. This is not publicly documented and a potential drawback when trying to fly under the radar. Again, we will be compiling and outputting shellcode for us to further obfuscate and hide. This can be done with the -f flag. Because Sliver does not make it obvious what their execution and injection methods are like Havoc does, we’ll have to do some digging. Looking at the task_windows.go file, VirtualAlloc and CreateRemoteThread are both used to allocate and execute the in memory objects. Really interestingly, BishopFox has gone out of their way to implement their own syscalls package, which only has the commands that they will need to use. It’s a smart way of limiting bloat and reducing imports. For comparison, 7zip has 69 imports from Kernel32 alone. This is definitely a key piece as well in reducing their detection rate combined with EDR sometimes not being equipped to analyze Go binaries. Sliver also has its own methods for evasion, though this is not something the authors have focused heavily on. They provide two functions that work in tandem in order to accomplish this. The first is RefreshPE which reloads the .text section of a file from disk. The second is what they call writeGoodBytes. This function takes a process name and a few other variables and proceeds to reload the clean version of a dll into the current processes memory through the first function mentioned. This is called through err := evasion.RefreshPE(&#39;c:\windows\system32\ntdll.dll&#39;). Do note, to do this they allocated RWX memory sections, which will set off EDR. Havoc also allocates memory in the same way, so it’s a knock against both. Now that we have an idea of how things are executed, we can go back to loading our shellcode into the resource section of our executable. Without even encrypting it, we see a strikingly lower detection rate than Havocs shellcode loaded the same way. A final piece to touch on, BOFs. Sliver allows operators to port over custom beacon object files that were written for Cobaltstrike, as well as downloading prebuilt ones. Let’s see how easy they are to drop. Sliver uses something called Armory to manage these in a sort of extension manner. You can list extensions available through armory and install them through armory install. Then, once you’ve gotten the BOFs installed, you hop into a session for a beacon and can run any of them just by typing their name and the flags that they require. This is very reminiscent of Metasploit modules and is intuitive to use and figure out. In fact, the whole program is reminiscent of Metasploit down to the help dialogue and how information is presented. This is not surprising, Sliver utilizes MSF internally and has built in functionality that allows operators to do things like inject MSF payloads. Sliver had a lot of touches to it that really gave it the feel of an enterprise ready software. There’s a reputable company backing it, it has touches like beacon kill dates built in, and there’s a wide range of support for expanding the software while staying within their ecosystem such as with BOFs. It’s no surprise that threat actors have caught onto this framework and are integrating it with more and more campaigns. Microsoft has even noted that it is being used in tandem with Cobaltstrike in some attacks. How can you expand on them? Havoc Custom agents are a little tricky to figure out but there are examples provided. It will take some trial and error on your end to determine the exact way to call arguments and add functionality, but CodeXTF2 was kind enough to include their own demo agent written in Python as a demonstration for ease of understanding. Aside from custom agents, if you wish to add your own functionality to the teamserver, the codebase is vast and somewhat poorly commented which makes customization not the easiest. Sliver Sliver allows you to use beacon object files from Cobaltstrike to extend the post exploitation capabilities of the framework. While this isn’t necessarily a custom agent, this allows customization of agents to add further capabilities. To the unfamiliar, BOF are compiled C programs that are position independent code. Meaning that like Donut, no matter where it is placed in memory, it can execute. BOFs are injected directly into the beacon process typically, avoiding IoC’s associated with alternative approaches like execute-assembly which spawns a new empty process to run these assemblies in. Cobaltstrike never intended for BOFs to be executing long-running commands, that’s what execute-assembly, is for. Instead, these are for quick functions that return data shortly after launch. Sliver including these as a method for expanding functionality is a very neat approach. Read more about BOFs in the sources section. Regarding their codebase it’s only marginally better commented with comments above primary functions describing what they do, but very little otherwise. This is disappointing to see, I wish commenting code was a more common practice as it helps new people get up to speed with each functions purpose much quicker. Why might you want one over the other? Havoc The GUI is very intuitive and well thought out. Visualizing compromised machines and SSH tunnels was intelligently setup. Less can be more. Giving people less to work with means they go deeper on working with what they have. Breeds innovation. Havoc has the more user-friendly GUI of the two and makes it easy to start and deploy listeners and implants. If you’re wanting to get an introduction to C2s and customization, their GUI makes it much easier for newer operators to get accustomed to the environment. The profiles also work more intuitively than Slivers method of saving configurations for listeners and implants by having you edit a JSON file. The roundrobin technique of hosts and URIs is also very clever, allowing much more randomness to be added, which it makes the defenders job that much harder. Sliver Multi platform framework. Deeper resources to put into development. BOFs implementation is very smooth. More listener options like wireguard and mTLS. If you want the end game experience of free C2’s, this hands down goes to Sliver with their implementation of BOFs. Sliver also has agents that can be deployed to not only Windows machines, but also Mac and Linux. On top of this, their default detection rate with shellcode was also much lower. These can all be attributed to the number of resources that BishopFox has to throw at things compared to Havocs development team. Sources (BOF) https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/ (BOF) https://www.cobaltstrike.com/blog/writing-beacon-object-files-flexible-stealthy-and-compatible/ https://0x00sec.org/t/process-injection-remote-thread-injection-or-createremotethread/24399 https://github.com/BishopFox/sliver https://github.com/HavocFramework/Havoc https://mez0.cc/posts/detecting-syscalls-with-fennec/" /><meta property="og:description" content="Sliver vs Havoc - Two Adversary Emulation Frameworks I wanted to objectively measure two well known frameworks against one another and see which fits certain needs best. To this end, each platform has been measured by if you can expand on them, how easy they are to get using, and why you might want one over the other. Before going further, for those unfamiliar, both Sliver and Havoc are command and control frameworks that are free to use on GitHub. Sliver is developed by BishopFox and is a reasonably old project that first started in 2019. It’s seen some major upgrades since then, with the most recent being in October 2022. Havoc is a much newer tool developed by three independent contributors that was first started in September 2022. Both teams are responsive to questions and issues and, since they’re open source, you are free to expand on them as you need. With that said, the first question that should be answered is how easy is it to spin one of these up? How easy is it to spin one up and get going vs the other? Havoc Havoc utilizes team profiles at launch to dictate implant functionality The documentation is fairly well laid out, but online only. You should have prior knowledge with C++ and implementing bypass techniques because out of the box the implants are detected quickly. Havoc is very neat. Much like Cobaltstrike, you can start the teamserver by passing it a json profile of users and their passwords as well as some general functionality things like sleep time and jitter of your implants. An opsec concern right off the bat for teams may be that the passwords in this file not encrypted, so setting proper read permissions of it and the directory is very important. Once the server is started, the dashboard is very intuitively laid out if you’ve ever used Cobaltstrike. Starting a listener is easy as well. Hitting view -&gt; listeners allows us to add a new one. From here, you just step through the simple option menu and configure a few things like the port, if we’ll be using hostnames, and the header to use, and you’re set. And the payload options, while slim, have enough to them that we can make the necessary modifications to let them slip by the EDR we anticipate meeting. We can output in four file formats. These are exe, dll, shellcode, or service exe. The default implant of an EXE gets detected very quickly, so we’ll be testing the shellcode option here and implant it through the resource section of another EXE we develop ourselves. Next, we have to select the memory allocation and execution methods. For those, our options are syscalls or Win32. My understanding is that this means either performing a VirtualAlloc or NtAllocateVirtualMemory in the case of allocation, and for execution it would be NtCreateThreadEx or CreateRemoteThread. NtAllocateVirtualMemory is typically called through VirtualAlloc since it is an undocumented function. As we briefly touched on in the NTDLL article in September 2022, these undocumented functions can change on a dime but are very useful for bypassing detection methods that focus solely on break points in NTDLL when called. Their downside is that seeing syscalls like this is quite unusual and alarming, so EDR watching for this could alert very quickly. VirtualAlloc on the other hand is the lowest level call from user space that we can perform and hooks into Ring0 using syscalls to allocate memory within the bounds of what’s known as the system granularity boundary. For most Windows systems, this will be 64kb. Allocations also must be a multiple of this boundary, so for example a 3 byte allocation would cause errors. Moving to the execution methods, NtCreateThreadEx is the undocumented, lower level, version of CreateRemoteThread. Like NtAllocateVirtualMemory, it is contingent on syscalls being up to date and suffers from the same pitfalls. CreateRemoteThread is much safer but also easier to detect. Finding a balance between the two options is important when generating your implant. Different EDR might be tuned to detect one method more over the other. After taking all this into account and developing our executable for the shellcode, we can see that the detection levels has dropped from 26 to 16. That’s not ideal, but if your target platform is Microsoft, you’ve made it past stage 1 with only a few changes. While using Havoc, it felt like their target audience was professionals who are experienced with other C2 platforms and want something that they can build off of on their own. It’s hard to get leadership buy in on a project that is only maintaned by three people and doesn’t have a company backing it like BishopFox, so it’s hard to say how likely you are to encounter it in an enterprise. For those who really enjoy working in a GUI though, this will definitely scratch that itch. Sliver Let’s now shift a little and check out Sliver. Sliver is completely terminal based meaning if you need a GUI to be able to visualize things, this won’t work for you. The documentation is expansive and intimidating, which is great, and you can type help for any function. Sliver also lets you set expiration dates for beacons, so they stop working after a set time. Sliver gives you everything and expects you know what to do with it. If you don’t know what to do with it, there’s a help dialogue for each option, but aside from that you are left to figure it out. Just check out the options for compiling an implant. If you don’t know why you might want to disable the Shikata-Ga-Nai shellcode encoder, you’re offered no explanation. There are numerous guides available online for Sliver, which lowers the learning curve significantly and if you would like to get started, these are almost mandatory readings. Some can be found here. The linked reading does a deep dive into Slivers code and finds some interesting shortcuts taken by the developers. For example, generating stagers under the hood is handled through MSFVenom and, while you can specify a DNS name, only hardcoded IPs are passed. This is not publicly documented and a potential drawback when trying to fly under the radar. Again, we will be compiling and outputting shellcode for us to further obfuscate and hide. This can be done with the -f flag. Because Sliver does not make it obvious what their execution and injection methods are like Havoc does, we’ll have to do some digging. Looking at the task_windows.go file, VirtualAlloc and CreateRemoteThread are both used to allocate and execute the in memory objects. Really interestingly, BishopFox has gone out of their way to implement their own syscalls package, which only has the commands that they will need to use. It’s a smart way of limiting bloat and reducing imports. For comparison, 7zip has 69 imports from Kernel32 alone. This is definitely a key piece as well in reducing their detection rate combined with EDR sometimes not being equipped to analyze Go binaries. Sliver also has its own methods for evasion, though this is not something the authors have focused heavily on. They provide two functions that work in tandem in order to accomplish this. The first is RefreshPE which reloads the .text section of a file from disk. The second is what they call writeGoodBytes. This function takes a process name and a few other variables and proceeds to reload the clean version of a dll into the current processes memory through the first function mentioned. This is called through err := evasion.RefreshPE(&#39;c:\windows\system32\ntdll.dll&#39;). Do note, to do this they allocated RWX memory sections, which will set off EDR. Havoc also allocates memory in the same way, so it’s a knock against both. Now that we have an idea of how things are executed, we can go back to loading our shellcode into the resource section of our executable. Without even encrypting it, we see a strikingly lower detection rate than Havocs shellcode loaded the same way. A final piece to touch on, BOFs. Sliver allows operators to port over custom beacon object files that were written for Cobaltstrike, as well as downloading prebuilt ones. Let’s see how easy they are to drop. Sliver uses something called Armory to manage these in a sort of extension manner. You can list extensions available through armory and install them through armory install. Then, once you’ve gotten the BOFs installed, you hop into a session for a beacon and can run any of them just by typing their name and the flags that they require. This is very reminiscent of Metasploit modules and is intuitive to use and figure out. In fact, the whole program is reminiscent of Metasploit down to the help dialogue and how information is presented. This is not surprising, Sliver utilizes MSF internally and has built in functionality that allows operators to do things like inject MSF payloads. Sliver had a lot of touches to it that really gave it the feel of an enterprise ready software. There’s a reputable company backing it, it has touches like beacon kill dates built in, and there’s a wide range of support for expanding the software while staying within their ecosystem such as with BOFs. It’s no surprise that threat actors have caught onto this framework and are integrating it with more and more campaigns. Microsoft has even noted that it is being used in tandem with Cobaltstrike in some attacks. How can you expand on them? Havoc Custom agents are a little tricky to figure out but there are examples provided. It will take some trial and error on your end to determine the exact way to call arguments and add functionality, but CodeXTF2 was kind enough to include their own demo agent written in Python as a demonstration for ease of understanding. Aside from custom agents, if you wish to add your own functionality to the teamserver, the codebase is vast and somewhat poorly commented which makes customization not the easiest. Sliver Sliver allows you to use beacon object files from Cobaltstrike to extend the post exploitation capabilities of the framework. While this isn’t necessarily a custom agent, this allows customization of agents to add further capabilities. To the unfamiliar, BOF are compiled C programs that are position independent code. Meaning that like Donut, no matter where it is placed in memory, it can execute. BOFs are injected directly into the beacon process typically, avoiding IoC’s associated with alternative approaches like execute-assembly which spawns a new empty process to run these assemblies in. Cobaltstrike never intended for BOFs to be executing long-running commands, that’s what execute-assembly, is for. Instead, these are for quick functions that return data shortly after launch. Sliver including these as a method for expanding functionality is a very neat approach. Read more about BOFs in the sources section. Regarding their codebase it’s only marginally better commented with comments above primary functions describing what they do, but very little otherwise. This is disappointing to see, I wish commenting code was a more common practice as it helps new people get up to speed with each functions purpose much quicker. Why might you want one over the other? Havoc The GUI is very intuitive and well thought out. Visualizing compromised machines and SSH tunnels was intelligently setup. Less can be more. Giving people less to work with means they go deeper on working with what they have. Breeds innovation. Havoc has the more user-friendly GUI of the two and makes it easy to start and deploy listeners and implants. If you’re wanting to get an introduction to C2s and customization, their GUI makes it much easier for newer operators to get accustomed to the environment. The profiles also work more intuitively than Slivers method of saving configurations for listeners and implants by having you edit a JSON file. The roundrobin technique of hosts and URIs is also very clever, allowing much more randomness to be added, which it makes the defenders job that much harder. Sliver Multi platform framework. Deeper resources to put into development. BOFs implementation is very smooth. More listener options like wireguard and mTLS. If you want the end game experience of free C2’s, this hands down goes to Sliver with their implementation of BOFs. Sliver also has agents that can be deployed to not only Windows machines, but also Mac and Linux. On top of this, their default detection rate with shellcode was also much lower. These can all be attributed to the number of resources that BishopFox has to throw at things compared to Havocs development team. Sources (BOF) https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/ (BOF) https://www.cobaltstrike.com/blog/writing-beacon-object-files-flexible-stealthy-and-compatible/ https://0x00sec.org/t/process-injection-remote-thread-injection-or-createremotethread/24399 https://github.com/BishopFox/sliver https://github.com/HavocFramework/Havoc https://mez0.cc/posts/detecting-syscalls-with-fennec/" /><link rel="canonical" href="/posts/Sliver-vs-Havoc/" /><meta property="og:url" content="/posts/Sliver-vs-Havoc/" /><meta property="og:site_name" content="Culbert Report" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-01-13T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Sliver vs Havoc" /><meta name="twitter:site" content="@mattculbert" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-12T14:46:38+00:00","datePublished":"2023-01-13T00:00:00+00:00","description":"Sliver vs Havoc - Two Adversary Emulation Frameworks I wanted to objectively measure two well known frameworks against one another and see which fits certain needs best. To this end, each platform has been measured by if you can expand on them, how easy they are to get using, and why you might want one over the other. Before going further, for those unfamiliar, both Sliver and Havoc are command and control frameworks that are free to use on GitHub. Sliver is developed by BishopFox and is a reasonably old project that first started in 2019. It’s seen some major upgrades since then, with the most recent being in October 2022. Havoc is a much newer tool developed by three independent contributors that was first started in September 2022. Both teams are responsive to questions and issues and, since they’re open source, you are free to expand on them as you need. With that said, the first question that should be answered is how easy is it to spin one of these up? How easy is it to spin one up and get going vs the other? Havoc Havoc utilizes team profiles at launch to dictate implant functionality The documentation is fairly well laid out, but online only. You should have prior knowledge with C++ and implementing bypass techniques because out of the box the implants are detected quickly. Havoc is very neat. Much like Cobaltstrike, you can start the teamserver by passing it a json profile of users and their passwords as well as some general functionality things like sleep time and jitter of your implants. An opsec concern right off the bat for teams may be that the passwords in this file not encrypted, so setting proper read permissions of it and the directory is very important. Once the server is started, the dashboard is very intuitively laid out if you’ve ever used Cobaltstrike. Starting a listener is easy as well. Hitting view -&gt; listeners allows us to add a new one. From here, you just step through the simple option menu and configure a few things like the port, if we’ll be using hostnames, and the header to use, and you’re set. And the payload options, while slim, have enough to them that we can make the necessary modifications to let them slip by the EDR we anticipate meeting. We can output in four file formats. These are exe, dll, shellcode, or service exe. The default implant of an EXE gets detected very quickly, so we’ll be testing the shellcode option here and implant it through the resource section of another EXE we develop ourselves. Next, we have to select the memory allocation and execution methods. For those, our options are syscalls or Win32. My understanding is that this means either performing a VirtualAlloc or NtAllocateVirtualMemory in the case of allocation, and for execution it would be NtCreateThreadEx or CreateRemoteThread. NtAllocateVirtualMemory is typically called through VirtualAlloc since it is an undocumented function. As we briefly touched on in the NTDLL article in September 2022, these undocumented functions can change on a dime but are very useful for bypassing detection methods that focus solely on break points in NTDLL when called. Their downside is that seeing syscalls like this is quite unusual and alarming, so EDR watching for this could alert very quickly. VirtualAlloc on the other hand is the lowest level call from user space that we can perform and hooks into Ring0 using syscalls to allocate memory within the bounds of what’s known as the system granularity boundary. For most Windows systems, this will be 64kb. Allocations also must be a multiple of this boundary, so for example a 3 byte allocation would cause errors. Moving to the execution methods, NtCreateThreadEx is the undocumented, lower level, version of CreateRemoteThread. Like NtAllocateVirtualMemory, it is contingent on syscalls being up to date and suffers from the same pitfalls. CreateRemoteThread is much safer but also easier to detect. Finding a balance between the two options is important when generating your implant. Different EDR might be tuned to detect one method more over the other. After taking all this into account and developing our executable for the shellcode, we can see that the detection levels has dropped from 26 to 16. That’s not ideal, but if your target platform is Microsoft, you’ve made it past stage 1 with only a few changes. While using Havoc, it felt like their target audience was professionals who are experienced with other C2 platforms and want something that they can build off of on their own. It’s hard to get leadership buy in on a project that is only maintaned by three people and doesn’t have a company backing it like BishopFox, so it’s hard to say how likely you are to encounter it in an enterprise. For those who really enjoy working in a GUI though, this will definitely scratch that itch. Sliver Let’s now shift a little and check out Sliver. Sliver is completely terminal based meaning if you need a GUI to be able to visualize things, this won’t work for you. The documentation is expansive and intimidating, which is great, and you can type help for any function. Sliver also lets you set expiration dates for beacons, so they stop working after a set time. Sliver gives you everything and expects you know what to do with it. If you don’t know what to do with it, there’s a help dialogue for each option, but aside from that you are left to figure it out. Just check out the options for compiling an implant. If you don’t know why you might want to disable the Shikata-Ga-Nai shellcode encoder, you’re offered no explanation. There are numerous guides available online for Sliver, which lowers the learning curve significantly and if you would like to get started, these are almost mandatory readings. Some can be found here. The linked reading does a deep dive into Slivers code and finds some interesting shortcuts taken by the developers. For example, generating stagers under the hood is handled through MSFVenom and, while you can specify a DNS name, only hardcoded IPs are passed. This is not publicly documented and a potential drawback when trying to fly under the radar. Again, we will be compiling and outputting shellcode for us to further obfuscate and hide. This can be done with the -f flag. Because Sliver does not make it obvious what their execution and injection methods are like Havoc does, we’ll have to do some digging. Looking at the task_windows.go file, VirtualAlloc and CreateRemoteThread are both used to allocate and execute the in memory objects. Really interestingly, BishopFox has gone out of their way to implement their own syscalls package, which only has the commands that they will need to use. It’s a smart way of limiting bloat and reducing imports. For comparison, 7zip has 69 imports from Kernel32 alone. This is definitely a key piece as well in reducing their detection rate combined with EDR sometimes not being equipped to analyze Go binaries. Sliver also has its own methods for evasion, though this is not something the authors have focused heavily on. They provide two functions that work in tandem in order to accomplish this. The first is RefreshPE which reloads the .text section of a file from disk. The second is what they call writeGoodBytes. This function takes a process name and a few other variables and proceeds to reload the clean version of a dll into the current processes memory through the first function mentioned. This is called through err := evasion.RefreshPE(&#39;c:\\windows\\system32\\ntdll.dll&#39;). Do note, to do this they allocated RWX memory sections, which will set off EDR. Havoc also allocates memory in the same way, so it’s a knock against both. Now that we have an idea of how things are executed, we can go back to loading our shellcode into the resource section of our executable. Without even encrypting it, we see a strikingly lower detection rate than Havocs shellcode loaded the same way. A final piece to touch on, BOFs. Sliver allows operators to port over custom beacon object files that were written for Cobaltstrike, as well as downloading prebuilt ones. Let’s see how easy they are to drop. Sliver uses something called Armory to manage these in a sort of extension manner. You can list extensions available through armory and install them through armory install. Then, once you’ve gotten the BOFs installed, you hop into a session for a beacon and can run any of them just by typing their name and the flags that they require. This is very reminiscent of Metasploit modules and is intuitive to use and figure out. In fact, the whole program is reminiscent of Metasploit down to the help dialogue and how information is presented. This is not surprising, Sliver utilizes MSF internally and has built in functionality that allows operators to do things like inject MSF payloads. Sliver had a lot of touches to it that really gave it the feel of an enterprise ready software. There’s a reputable company backing it, it has touches like beacon kill dates built in, and there’s a wide range of support for expanding the software while staying within their ecosystem such as with BOFs. It’s no surprise that threat actors have caught onto this framework and are integrating it with more and more campaigns. Microsoft has even noted that it is being used in tandem with Cobaltstrike in some attacks. How can you expand on them? Havoc Custom agents are a little tricky to figure out but there are examples provided. It will take some trial and error on your end to determine the exact way to call arguments and add functionality, but CodeXTF2 was kind enough to include their own demo agent written in Python as a demonstration for ease of understanding. Aside from custom agents, if you wish to add your own functionality to the teamserver, the codebase is vast and somewhat poorly commented which makes customization not the easiest. Sliver Sliver allows you to use beacon object files from Cobaltstrike to extend the post exploitation capabilities of the framework. While this isn’t necessarily a custom agent, this allows customization of agents to add further capabilities. To the unfamiliar, BOF are compiled C programs that are position independent code. Meaning that like Donut, no matter where it is placed in memory, it can execute. BOFs are injected directly into the beacon process typically, avoiding IoC’s associated with alternative approaches like execute-assembly which spawns a new empty process to run these assemblies in. Cobaltstrike never intended for BOFs to be executing long-running commands, that’s what execute-assembly, is for. Instead, these are for quick functions that return data shortly after launch. Sliver including these as a method for expanding functionality is a very neat approach. Read more about BOFs in the sources section. Regarding their codebase it’s only marginally better commented with comments above primary functions describing what they do, but very little otherwise. This is disappointing to see, I wish commenting code was a more common practice as it helps new people get up to speed with each functions purpose much quicker. Why might you want one over the other? Havoc The GUI is very intuitive and well thought out. Visualizing compromised machines and SSH tunnels was intelligently setup. Less can be more. Giving people less to work with means they go deeper on working with what they have. Breeds innovation. Havoc has the more user-friendly GUI of the two and makes it easy to start and deploy listeners and implants. If you’re wanting to get an introduction to C2s and customization, their GUI makes it much easier for newer operators to get accustomed to the environment. The profiles also work more intuitively than Slivers method of saving configurations for listeners and implants by having you edit a JSON file. The roundrobin technique of hosts and URIs is also very clever, allowing much more randomness to be added, which it makes the defenders job that much harder. Sliver Multi platform framework. Deeper resources to put into development. BOFs implementation is very smooth. More listener options like wireguard and mTLS. If you want the end game experience of free C2’s, this hands down goes to Sliver with their implementation of BOFs. Sliver also has agents that can be deployed to not only Windows machines, but also Mac and Linux. On top of this, their default detection rate with shellcode was also much lower. These can all be attributed to the number of resources that BishopFox has to throw at things compared to Havocs development team. Sources (BOF) https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/ (BOF) https://www.cobaltstrike.com/blog/writing-beacon-object-files-flexible-stealthy-and-compatible/ https://0x00sec.org/t/process-injection-remote-thread-injection-or-createremotethread/24399 https://github.com/BishopFox/sliver https://github.com/HavocFramework/Havoc https://mez0.cc/posts/detecting-syscalls-with-fennec/","headline":"Sliver vs Havoc","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/Sliver-vs-Havoc/"},"url":"/posts/Sliver-vs-Havoc/"}</script><title>Sliver vs Havoc | Culbert Report</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Culbert Report"><meta name="application-name" content="Culbert Report"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/thumb.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Culbert Report</a></div><div class="site-subtitle font-italic">Get in loser, we're hating AI and bringing back real learning. Site art by Kenton Drumm</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/matt-culbert" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/mattculbert" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['matt','culbertreport.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Sliver vs Havoc</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Sliver vs Havoc</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1673568000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jan 13, 2023 </em> </span> <span> Updated <em class="" data-ts="1681310798" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 12, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/">Matt Culbert</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2117 words"> <em>11 min</em> read</span></div></div></div><div class="post-content"><h1 id="sliver-vs-havoc---two-adversary-emulation-frameworks">Sliver vs Havoc - Two Adversary Emulation Frameworks</h1><p>I wanted to objectively measure two well known frameworks against one another and see which fits certain needs best. To this end, each platform has been measured by if you can expand on them, how easy they are to get using, and why you might want one over the other. Before going further, for those unfamiliar, both Sliver and Havoc are command and control frameworks that are free to use on GitHub. Sliver is developed by BishopFox and is a reasonably old project that first started in 2019. It’s seen some major upgrades since then, with the most recent being in October 2022. Havoc is a much newer tool developed by three independent contributors that was first started in September 2022. Both teams are responsive to questions and issues and, since they’re open source, you are free to expand on them as you need. With that said, the first question that should be answered is how easy is it to spin one of these up?</p><h2 id="how-easy-is-it-to-spin-one-up-and-get-going-vs-the-other"><span class="mr-2">How easy is it to spin one up and get going vs the other?</span><a href="#how-easy-is-it-to-spin-one-up-and-get-going-vs-the-other" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="havoc"><span class="mr-2">Havoc</span><a href="#havoc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Havoc utilizes team profiles at launch to dictate implant functionality<li>The documentation is fairly well laid out, but online only.<li>You should have prior knowledge with C++ and implementing bypass techniques because out of the box the implants are detected quickly.</ul><p>Havoc is very neat. Much like Cobaltstrike, you can start the teamserver by passing it a json profile of users and their passwords as well as some general functionality things like sleep time and jitter of your implants. An opsec concern right off the bat for teams may be that the passwords in this file not encrypted, so setting proper read permissions of it and the directory is very important. Once the server is started, the dashboard is very intuitively laid out if you’ve ever used Cobaltstrike.</p><p><a href="/assets/img/Sliver-v-Havoc/havoc-dashboard.png" class="popup img-link "><img data-src="/assets/img/Sliver-v-Havoc/havoc-dashboard.png" alt="Havoc dashboard" class="lazyload" data-proofer-ignore></a></p><p>Starting a listener is easy as well. Hitting <code class="language-plaintext highlighter-rouge">view -&gt; listeners</code> allows us to add a new one. From here, you just step through the simple option menu and configure a few things like the port, if we’ll be using hostnames, and the header to use, and you’re set.</p><p><a href="/assets/img/Sliver-v-Havoc/Havoc-listener-default-options.png" class="popup img-link "><img data-src="/assets/img/Sliver-v-Havoc/Havoc-listener-default-options.png" alt="Listener" class="lazyload" data-proofer-ignore></a></p><p>And the payload options, while slim, have enough to them that we can make the necessary modifications to let them slip by the EDR we anticipate meeting. We can output in four file formats. These are exe, dll, shellcode, or service exe.</p><p><a href="/assets/img/Sliver-v-Havoc/havoc-payload-formats.png" class="popup img-link "><img data-src="/assets/img/Sliver-v-Havoc/havoc-payload-formats.png" alt="File formats" class="lazyload" data-proofer-ignore></a></p><p>The default implant of an EXE gets detected very quickly, so we’ll be testing the shellcode option here and implant it through the resource section of another EXE we develop ourselves.</p><p>Next, we have to select the memory allocation and execution methods. For those, our options are syscalls or Win32. My understanding is that this means either performing a VirtualAlloc or NtAllocateVirtualMemory in the case of allocation, and for execution it would be NtCreateThreadEx or CreateRemoteThread.</p><p>NtAllocateVirtualMemory is typically called through VirtualAlloc since it is an undocumented function. As we briefly touched on in the NTDLL article in September 2022, these undocumented functions can change on a dime but are very useful for bypassing detection methods that focus solely on break points in NTDLL when called. Their downside is that seeing syscalls like this is quite unusual and alarming, so EDR watching for this could alert very quickly. VirtualAlloc on the other hand is the lowest level call from user space that we can perform and hooks into Ring0 using syscalls to allocate memory within the bounds of what’s known as the system granularity boundary. For most Windows systems, this will be 64kb. Allocations also must be a multiple of this boundary, so for example a 3 byte allocation would cause errors. Moving to the execution methods, NtCreateThreadEx is the undocumented, lower level, version of CreateRemoteThread. Like NtAllocateVirtualMemory, it is contingent on syscalls being up to date and suffers from the same pitfalls. CreateRemoteThread is much safer <em>but</em> also easier to detect. Finding a balance between the two options is important when generating your implant. Different EDR might be tuned to detect one method more over the other.</p><p>After taking all this into account and developing our executable for the shellcode, we can see that the detection levels has dropped from 26 to 16. That’s not ideal, but if your target platform is Microsoft, you’ve made it past stage 1 with only a few changes.</p><p><a href="/assets/img/Sliver-v-Havoc/Havoc-improved-detection.png" class="popup img-link "><img data-src="/assets/img/Sliver-v-Havoc/Havoc-improved-detection.png" alt="Improvements" class="lazyload" data-proofer-ignore></a></p><p>While using Havoc, it felt like their target audience was professionals who are experienced with other C2 platforms and want something that they can build off of on their own. It’s hard to get leadership buy in on a project that is only maintaned by three people and doesn’t have a company backing it like BishopFox, so it’s hard to say how likely you are to encounter it in an enterprise. For those who really enjoy working in a GUI though, this will definitely scratch that itch.</p><h3 id="sliver"><span class="mr-2">Sliver</span><a href="#sliver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Let’s now shift a little and check out Sliver.</p><ul><li>Sliver is completely terminal based meaning if you need a GUI to be able to visualize things, this won’t work for you.<li>The documentation is expansive and intimidating, which is great, and you can type help for any function.<li>Sliver also lets you set expiration dates for beacons, so they stop working after a set time.</ul><p>Sliver gives you everything and expects you know what to do with it. If you don’t know what to do with it, there’s a help dialogue for each option, but aside from that you are left to figure it out. Just check out the options for compiling an implant.</p><p><a href="/assets/img/Sliver-v-Havoc/sliver-implant-flags.png" class="popup img-link "><img data-src="/assets/img/Sliver-v-Havoc/sliver-implant-flags.png" alt="Compile Options" class="lazyload" data-proofer-ignore></a></p><p>If you don’t know why you might want to disable the Shikata-Ga-Nai shellcode encoder, you’re offered no explanation. There are numerous guides available online for Sliver, which lowers the learning curve significantly and if you would like to get started, these are almost mandatory readings. <a href="https://dominicbreuker.com/post/learning_sliver_c2_06_stagers/">Some can be found here</a>. The linked reading does a deep dive into Slivers code and finds some interesting shortcuts taken by the developers. For example, generating stagers under the hood is handled through MSFVenom and, while you can specify a DNS name, only hardcoded IPs are passed. This is not publicly documented and a potential drawback when trying to fly under the radar.</p><p>Again, we will be compiling and outputting shellcode for us to further obfuscate and hide. This can be done with the <code class="language-plaintext highlighter-rouge">-f</code> flag.</p><p>Because Sliver does not make it obvious what their execution and injection methods are like Havoc does, we’ll have to do some digging. Looking at the <code class="language-plaintext highlighter-rouge">task_windows.go</code> file, <code class="language-plaintext highlighter-rouge">VirtualAlloc</code> and <code class="language-plaintext highlighter-rouge">CreateRemoteThread</code> are both used to allocate and execute the in memory objects. Really interestingly, BishopFox has gone out of their way to implement their own syscalls package, which only has the commands that they will need to use. It’s a smart way of limiting bloat and reducing imports. For comparison, 7zip has 69 imports from Kernel32 alone. This is definitely a key piece as well in reducing their detection rate combined with EDR sometimes not being equipped to analyze Go binaries.</p><p>Sliver also has its own methods for evasion, though this is not something the authors have focused heavily on. They provide two functions that work in tandem in order to accomplish this. The first is <code class="language-plaintext highlighter-rouge">RefreshPE</code> which reloads the .text section of a file from disk. The second is what they call <code class="language-plaintext highlighter-rouge">writeGoodBytes</code>. This function takes a process name and a few other variables and proceeds to reload the clean version of a dll into the current processes memory through the first function mentioned. This is called through <code class="language-plaintext highlighter-rouge">err := evasion.RefreshPE('c:\windows\system32\ntdll.dll')</code>. Do note, to do this they allocated RWX memory sections, which will set off EDR. Havoc also allocates memory in the same way, so it’s a knock against both.</p><p>Now that we have an idea of how things are executed, we can go back to loading our shellcode into the resource section of our executable. Without even encrypting it, we see a strikingly lower detection rate than Havocs shellcode loaded the same way.</p><p><a href="/assets/img/Sliver-v-Havoc/sliver-unencrypted-payload-test.png" class="popup img-link "><img data-src="/assets/img/Sliver-v-Havoc/sliver-unencrypted-payload-test.png" alt="Sliver exe" class="lazyload" data-proofer-ignore></a></p><p>A final piece to touch on, BOFs. Sliver allows operators to port over custom beacon object files that were written for Cobaltstrike, as well as downloading prebuilt ones. Let’s see how easy they are to drop. Sliver uses something called Armory to manage these in a sort of extension manner. You can list extensions available through <code class="language-plaintext highlighter-rouge">armory</code> and install them through <code class="language-plaintext highlighter-rouge">armory install</code>. Then, once you’ve gotten the BOFs installed, you hop into a session for a beacon and can run any of them just by typing their name and the flags that they require. This is very reminiscent of Metasploit modules and is intuitive to use and figure out. In fact, the whole program is reminiscent of Metasploit down to the help dialogue and how information is presented. This is not surprising, Sliver utilizes MSF internally and has built in functionality that allows operators to do things like inject MSF payloads.</p><p><a href="/assets/img/Sliver-v-Havoc/sliver-vs-msf.png" class="popup img-link "><img data-src="/assets/img/Sliver-v-Havoc/sliver-vs-msf.png" alt="msf" class="lazyload" data-proofer-ignore></a></p><p>Sliver had a lot of touches to it that really gave it the feel of an enterprise ready software. There’s a reputable company backing it, it has touches like beacon kill dates built in, and there’s a wide range of support for expanding the software while staying within their ecosystem such as with BOFs. It’s no surprise that threat actors have caught onto this framework and are integrating it with more and more campaigns. Microsoft has even noted that it is being used in tandem with Cobaltstrike in some attacks.</p><h2 id="how-can-you-expand-on-them"><span class="mr-2">How can you expand on them?</span><a href="#how-can-you-expand-on-them" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="havoc-1"><span class="mr-2">Havoc</span><a href="#havoc-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Custom agents are a little tricky to figure out but there are examples provided. It will take some trial and error on your end to determine the exact way to call arguments and add functionality, but CodeXTF2 was <a href="https://github.com/CodeXTF2/PyHmmm">kind enough to include their own demo agent</a> written in Python as a demonstration for ease of understanding. Aside from custom agents, if you wish to add your own functionality to the teamserver, the codebase is vast and somewhat poorly commented which makes customization not the easiest.</p><h3 id="sliver-1"><span class="mr-2">Sliver</span><a href="#sliver-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Sliver allows you to use beacon object files from Cobaltstrike to extend the post exploitation capabilities of the framework. While this isn’t necessarily a custom agent, this allows customization of agents to add further capabilities. To the unfamiliar, BOF are compiled C programs that are position independent code. Meaning that like Donut, no matter where it is placed in memory, it can execute. BOFs are injected directly into the beacon process typically, avoiding IoC’s associated with alternative approaches like execute-assembly which spawns a new empty process to run these assemblies in. Cobaltstrike never intended for BOFs to be executing long-running commands, that’s what execute-assembly, is for. Instead, these are for quick functions that return data shortly after launch. Sliver including these as a method for expanding functionality is a very neat approach. Read more about BOFs in the sources section. Regarding their codebase it’s only marginally better commented with comments above primary functions describing what they do, but very little otherwise. This is disappointing to see, I wish commenting code was a more common practice as it helps new people get up to speed with each functions purpose much quicker.</p><h2 id="why-might-you-want-one-over-the-other"><span class="mr-2">Why might you want one over the other?</span><a href="#why-might-you-want-one-over-the-other" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="havoc-2"><span class="mr-2">Havoc</span><a href="#havoc-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>The GUI is very intuitive and well thought out.<li>Visualizing compromised machines and SSH tunnels was intelligently setup.<li>Less can be more. Giving people less to work with means they go deeper on working with what they have. Breeds innovation.</ul><p>Havoc has the more user-friendly GUI of the two and makes it easy to start and deploy listeners and implants. If you’re wanting to get an introduction to C2s and customization, their GUI makes it much easier for newer operators to get accustomed to the environment. The profiles also work more intuitively than Slivers method of saving configurations for listeners and implants by having you edit a JSON file. The roundrobin technique of hosts and URIs is also very clever, allowing much more randomness to be added, which it makes the defenders job that much harder.</p><h3 id="sliver-2"><span class="mr-2">Sliver</span><a href="#sliver-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Multi platform framework.<li>Deeper resources to put into development.<li>BOFs implementation is very smooth.<li>More listener options like wireguard and mTLS.</ul><p>If you want the end game experience of free C2’s, this hands down goes to Sliver with their implementation of BOFs. Sliver also has agents that can be deployed to not only Windows machines, but also Mac and Linux. On top of this, their default detection rate with shellcode was also much lower. These can all be attributed to the number of resources that BishopFox has to throw at things compared to Havocs development team.</p><blockquote><p>Sources</p><p>(BOF) https://www.trustedsec.com/blog/a-developers-introduction-to-beacon-object-files/</p><p>(BOF) https://www.cobaltstrike.com/blog/writing-beacon-object-files-flexible-stealthy-and-compatible/</p><p>https://0x00sec.org/t/process-injection-remote-thread-injection-or-createremotethread/24399</p><p>https://github.com/BishopFox/sliver</p><p>https://github.com/HavocFramework/Havoc</p><p>https://mez0.cc/posts/detecting-syscalls-with-fennec/</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/redteam/'>redteam</a>, <a href='/categories/technical/'>TECHNICAL</a>, <a href='/categories/offensive-security/'>offensive-security</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/redteam/" class="post-tag no-text-decoration" >redteam</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Sliver%20vs%20Havoc%20-%20Culbert%20Report&url=%2Fposts%2FSliver-vs-Havoc%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Sliver%20vs%20Havoc%20-%20Culbert%20Report&u=%2Fposts%2FSliver-vs-Havoc%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FSliver-vs-Havoc%2F&text=Sliver%20vs%20Havoc%20-%20Culbert%20Report" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Making-Red-Teaming-Safer/">Making Red Teaming Safer</a><li><a href="/posts/Human-Learning-Is-Irreplaceable/">Human Learning Is Irreplaceable</a><li><a href="/posts/Building-A-Detection-Lab-Around-Suricata/">Building A Detection Lab Around Suricata</a><li><a href="/posts/The-evolution-of-evasion/">The Evolution Of Evasion</a><li><a href="/posts/C2-Smackdown-Empire-vs-Mythic/">C2 Smackdown Empire Vs Mythic</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Adversary-Emulation-Exercise/"><div class="card-body"> <em class="small" data-ts="1681084800" data-df="ll" > Apr 10, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Adversary Emulation Exercises</h3><div class="text-muted small"><p> Running An Adversary Emulation Exercise Adversary emulation can take many forms, but it will always have the same end goal. Helping companies come away knowing how to defend themselves better. You...</p></div></div></a></div><div class="card"> <a href="/posts/Ever-wondered-how-AV-knows/"><div class="card-body"> <em class="small" data-ts="1663891200" data-df="ll" > Sep 23, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How AV Hooks NTDLL</h3><div class="text-muted small"><p> How Does AV Know? Have you ever wondered how AV knows what that the application you’re trying to run is malicious when it doesn’t have a known signature? NTDLL is the answer. Before we begin It’...</p></div></div></a></div><div class="card"> <a href="/posts/Bloodhound/"><div class="card-body"> <em class="small" data-ts="1678233600" data-df="ll" > Mar 8, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Bloodhound basics</h3><div class="text-muted small"><p> Bloodhound What is it? Bloodhound describes their product as using graph theory to reveal hidden and unintended links between users and groups that makes lateral movement easier for attackers. Natu...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Breaking-Down-Creating-A-Redteam-Framework/" class="btn btn-outline-primary" prompt="Older"><p>Breaking Down Creating A Redteam Framework</p></a> <a href="/posts/Bloodhound/" class="btn btn-outline-primary" prompt="Newer"><p>Bloodhound basics</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/">Matt Culbert</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
